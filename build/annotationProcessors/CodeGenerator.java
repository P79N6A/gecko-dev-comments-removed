



package org.mozilla.gecko.annotationProcessors;

import org.mozilla.gecko.annotationProcessors.utils.Utils;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.HashSet;

public class CodeGenerator {
    
    private final StringBuilder wrapperStartupCode = new StringBuilder();
    private final StringBuilder wrapperMethodBodies = new StringBuilder();
    private final StringBuilder headerFields = new StringBuilder();
    private final StringBuilder headerMethods = new StringBuilder();

    private final HashSet<String> seenClasses = new HashSet<String>();

    private final String GENERATED_COMMENT = "// GENERATED CODE\n" +
            "// Generated by the Java program at /build/annotationProcessors at compile time from\n" +
            "// annotations on Java methods. To update, change the annotations on the corresponding Java\n" +
            "// methods and rerun the build. Manually updating this file will cause your build to fail.\n\n";

    public CodeGenerator() {
        
        
        
        
        wrapperStartupCode.append(GENERATED_COMMENT);
        wrapperStartupCode.append(
                "#include \"nsXPCOMStrings.h\"\n" +
                "#include \"AndroidBridge.h\"\n" +
                "#include \"AndroidBridgeUtilities.h\"\n" +
                "\n" +
                "#ifdef DEBUG\n" +
                "#define ALOG_BRIDGE(args...) ALOG(args)\n" +
                "#else\n" +
                "#define ALOG_BRIDGE(args...) ((void)0)\n" +
                "#endif\n" +
                "\n" +
                "using namespace mozilla;\n" +
                "void AndroidBridge::InitStubs(JNIEnv *jEnv) {\n" +
                "    ALOG_BRIDGE(\"%s\", __PRETTY_FUNCTION__);\n" +
                "    initInit();\n");
        

        headerFields.append("protected:\n\n");
        headerMethods.append(GENERATED_COMMENT);
        headerMethods.append("public:\n\n");
    }

    





    public void generateMethod(MethodWithAnnotationInfo aMethodTuple, Class<?> aClass) {
        
        Method aMethod = aMethodTuple.method;
        String CMethodName = aMethodTuple.wrapperName;

        String javaMethodName = aMethod.getName();

        ensureClassHeaderAndStartup(aClass);

        writeHeaderField(CMethodName);
        writeStartupCode(CMethodName, javaMethodName, aMethod, aClass);

        
        String implementationSignature = Utils.getCImplementationMethodSignature(aMethod, CMethodName);
        String headerSignature = Utils.getCHeaderMethodSignature(aMethod, CMethodName, aMethodTuple.isStatic);

        
        headerMethods.append(headerSignature);
        headerMethods.append(";\n");

        
        writeMethodBody(implementationSignature, CMethodName, aMethod, aClass, aMethodTuple.isStatic, aMethodTuple.isMultithreaded);
    }

    





    private void ensureClassHeaderAndStartup(Class<?> aClass) {
        String className = aClass.getCanonicalName();
        if (seenClasses.contains(className)) {
            return;
        }

        
        headerFields.append("\njclass ");
        headerFields.append(Utils.getClassReferenceName(aClass));
        headerFields.append(";\n");

        
        wrapperStartupCode.append('\n');
        wrapperStartupCode.append(Utils.getStartupLineForClass(aClass));

        seenClasses.add(className);
    }

    








    private void writeMethodBody(String methodSignature, String aCMethodName, Method aMethod, Class<?> aClass, boolean aIsStaticBridgeMethod, boolean aIsMultithreaded) {
        Class<?>[] argumentTypes = aMethod.getParameterTypes();
        Class<?> returnType = aMethod.getReturnType();

        
        wrapperMethodBodies.append('\n');
        wrapperMethodBodies.append(methodSignature);

        wrapperMethodBodies.append(" {\n" +
                                   "    ALOG_BRIDGE(\"%s\", __PRETTY_FUNCTION__);\n");

        
        if (aIsStaticBridgeMethod) {
            wrapperMethodBodies.append("    if (!sBridge) {\n" +
                                       "        ALOG_BRIDGE(\"Aborted: No sBridge - %s\", __PRETTY_FUNCTION__);\n" +
                                       "        return").append(Utils.getFailureReturnForType(returnType)).append(";\n" +
                                       "    }\n\n");
        }
        wrapperMethodBodies.append("    JNIEnv *env = ");
        if (!aIsMultithreaded) {
            wrapperMethodBodies.append("GetJNIEnv();\n");
        } else {
            wrapperMethodBodies.append("GetJNIForThread();\n");
        }
        wrapperMethodBodies.append("    if (!env) {\n" +
                                   "        ALOG_BRIDGE(\"Aborted: No env - %s\", __PRETTY_FUNCTION__);\n" +
                                   "        return").append(Utils.getFailureReturnForType(returnType)).append(";\n" +
                                   "    }\n\n");

        boolean isObjectReturningMethod = !returnType.getCanonicalName().equals("void") && Utils.doesReturnObjectType(aMethod);

        
        
        int localReferencesNeeded = Utils.enumerateReferenceArguments(aMethod);
        if (isObjectReturningMethod) {
            localReferencesNeeded++;
        }
        wrapperMethodBodies.append("    if (env->PushLocalFrame(").append(localReferencesNeeded).append(") != 0) {\n" +
                                   "        ALOG_BRIDGE(\"Exceptional exit of: %s\", __PRETTY_FUNCTION__);\n" +
                                   "        env->ExceptionDescribe();\n"+
                                   "        env->ExceptionClear();\n" +
                                   "        return").append(Utils.getFailureReturnForType(returnType)).append(";\n" +
                                   "    }\n\n");

        
        boolean hasArguments = argumentTypes.length != 0;

        
        
        
        
        
        StringBuilder argumentContent = new StringBuilder();
        if (hasArguments) {
            argumentContent.append(", ");
            
            if (argumentTypes.length > 2) {
                wrapperMethodBodies.append("    jvalue args[").append(argumentTypes.length).append("];\n");
                for (int aT = 0; aT < argumentTypes.length; aT++) {
                    wrapperMethodBodies.append("    args[").append(aT).append("].");
                    wrapperMethodBodies.append(Utils.getArrayArgumentMashallingLine(argumentTypes[aT], "a" + aT));
                }

                
                argumentContent.append("args");
                wrapperMethodBodies.append('\n');
            } else {
                
                boolean needsNewline = false;
                for (int aT = 0; aT < argumentTypes.length; aT++) {
                    
                    
                    if (Utils.isCharSequence(argumentTypes[aT])) {
                        wrapperMethodBodies.append("    jstring j").append(aT).append(" = NewJavaString(env, a").append(aT).append(");\n");
                        needsNewline = true;
                        
                        
                        argumentContent.append('j').append(aT);
                    } else {
                        argumentContent.append('a').append(aT);
                    }
                    if (aT != argumentTypes.length - 1) {
                        argumentContent.append(", ");
                    }
                }
                if (needsNewline) {
                    wrapperMethodBodies.append('\n');
                }
            }
        }

        wrapperMethodBodies.append("    ");
        if (!returnType.getCanonicalName().equals("void")) {
            if (isObjectReturningMethod) {
                wrapperMethodBodies.append("jobject");
            } else {
                wrapperMethodBodies.append(Utils.getCReturnType(returnType));
            }
            wrapperMethodBodies.append(" temp = ");
        }

        boolean isStaticJavaMethod = Utils.isMethodStatic(aMethod);

        
        wrapperMethodBodies.append("env->");
        wrapperMethodBodies.append(Utils.getCallPrefix(returnType, isStaticJavaMethod));
        if (argumentTypes.length > 2) {
            wrapperMethodBodies.append('A');
        }

        wrapperMethodBodies.append('(');
        
        if (!isStaticJavaMethod) {
            wrapperMethodBodies.append("aTarget, ");
        } else {
            
            
            if (aIsStaticBridgeMethod) {
                wrapperMethodBodies.append("sBridge->");
            }
            
            
            wrapperMethodBodies.append(Utils.getClassReferenceName(aClass)).append(", ");
        }

        
        if (aIsStaticBridgeMethod) {
            wrapperMethodBodies.append("sBridge->");
        }
        wrapperMethodBodies.append('j');
        wrapperMethodBodies.append(aCMethodName);

        
        wrapperMethodBodies.append(argumentContent);
        wrapperMethodBodies.append(");\n\n");

        
        wrapperMethodBodies.append("    if (env->ExceptionCheck()) {\n" +
                                   "        ALOG_BRIDGE(\"Exceptional exit of: %s\", __PRETTY_FUNCTION__);\n" +
                                   "        env->ExceptionDescribe();\n" +
                                   "        env->ExceptionClear();\n" +
                                   "        env->PopLocalFrame(NULL);\n" +
                                   "        return").append(Utils.getFailureReturnForType(returnType)).append(";\n" +
                                   "    }\n");

        
        
        if (isObjectReturningMethod) {
            wrapperMethodBodies.append("    ");
            wrapperMethodBodies.append(Utils.getCReturnType(returnType));
            wrapperMethodBodies.append(" ret = static_cast<").append(Utils.getCReturnType(returnType)).append(">(env->PopLocalFrame(temp));\n" +
                                       "    ALOG_BRIDGE(\"Exit of: %s\", __PRETTY_FUNCTION__);\n" +
                                       "    return ret;\n");
        } else if (!returnType.getCanonicalName().equals("void")) {
            
            
            wrapperMethodBodies.append("    env->PopLocalFrame(NULL);\n" +
                                       "    ALOG_BRIDGE(\"Exit of: %s\", __PRETTY_FUNCTION__);\n" +
                                       "    return temp;\n");
        } else {
            
            wrapperMethodBodies.append("    ALOG_BRIDGE(\"Exit of: %s\", __PRETTY_FUNCTION__);\n" +
                                       "    env->PopLocalFrame(NULL);\n");
        }
        wrapperMethodBodies.append("}\n");
    }

    






    private void writeStartupCode(String aCMethodName, String aJavaMethodName, Method aMethod, Class<?> aClass) {
        wrapperStartupCode.append("    j");
        wrapperStartupCode.append(aCMethodName);
        wrapperStartupCode.append(" = get");
        if (Utils.isMethodStatic(aMethod)) {
            wrapperStartupCode.append("Static");
        }
        wrapperStartupCode.append("Method(\"");
        wrapperStartupCode.append(aJavaMethodName);
        wrapperStartupCode.append("\", \"");
        wrapperStartupCode.append(Utils.getTypeSignatureString(aMethod));
        wrapperStartupCode.append("\");\n");
    }

    




    private void writeHeaderField(String aMethodName) {
        headerFields.append("jmethodID j");
        headerFields.append(aMethodName);
        headerFields.append(";\n");
    }

    




    public byte[] getWrapperFileContents() {
        wrapperStartupCode.append("}\n");
        wrapperStartupCode.append(wrapperMethodBodies);
        wrapperMethodBodies.setLength(0);
        return wrapperStartupCode.toString().getBytes();
    }

    




    public byte[] getHeaderFileContents() {
        headerFields.append('\n');
        headerFields.append(headerMethods);
        headerMethods.setLength(0);
        return headerFields.toString().getBytes();
    }
}
