<!doctype html>
<meta charset=utf-8>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<div id="log"></div>
<style>
@keyframes empty { }
</style>
<script>
'use strict';

function waitForDocLoad() {
  return new Promise(function(resolve, reject) {
    if (document.readyState === 'complete') {
      resolve();
    } else {
      window.addEventListener('load', resolve);
    }
  });
}

async_test(function(t) {
  var div = addDiv(t);
  var cs = window.getComputedStyle(div);

  // Test that empty animations actually start.
  //
  // Normally we tie the start of animations to when their first frame of
  // the animation is rendered. However, for animations that don't actually
  // trigger a paint (e.g. because they are empty, or are animating something
  // that doesn't render or is offscreen) we want to make sure they still
  // start.
  //
  // Before we start, wait for the document to finish loading. This is because
  // during loading we will have other paint events taking place which might,
  // by luck, happen to trigger animations that otherwise would not have been
  // triggered, leading to false positives.
  //
  // As a result, it's better to wait until we have a more stable state before
  // continuing.
  var promiseCallbackDone = false;
  waitForDocLoad().then(function() {
    div.style.animation = 'empty 1000s';
    var player = div.getAnimationPlayers()[0];

    player.ready.then(function() {
      promiseCallbackDone = true;
    }).catch(function() {
      assert_unreached('ready promise was rejected');
    });

  }).then(waitForFrame).then(t.step_func(function() {
    assert_true(promiseCallbackDone,
                'ready promise callback was called before the next'
                + ' requestAnimationFrame callback');
    t.done();
  }));
}, 'AnimationPlayer.ready is resolved for an empty animation');

</script>
