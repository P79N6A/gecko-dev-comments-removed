<!DOCTYPE HTML>
<html>
<head>
  <title>Test Encrypted Media Extensions</title>
  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
  <script type="text/javascript" src="manifest.js"></script>
  <script type="text/javascript" src="http://test1.mochi.test:8888/tests/dom/media/test/eme.js"></script>
</head>
<body>
<pre id="test">
<script class="testbody" type="text/javascript">
SimpleTest.requestCompleteLog();
var manager = new MediaTestManager;


function KeysChangeFunc(session, keys, token) {
  session.keyIdsReceived = [];
  for (var keyid in keys) {
    Log(token, "Set " + keyid + " to false in session[" + session.sessionId + "].keyIdsReceived");
    session.keyIdsReceived[keyid] = false;
  }
  return function(ev) {
    var session = ev.target;
    session.gotKeysChanged = true;

    var map = session.keyStatuses;
    for (var [key, val] of map.entries()) {
      is(val, "usable", token + ": key status should be usable");
      var kid = Base64ToHex(window.btoa(ArrayBufferToString(key)));
      ok(kid in session.keyIdsReceived, TimeStamp(token) + " session[" + session.sessionId + "].keyIdsReceived contained " + kid + " as expected.");
      session.keyIdsReceived[kid] = true;
    }
  }
}

function startTest(test, token)
{
  manager.started(token);

  var sessions = [];
  var updatedSessions = [];
  var loaded = false;

  var v = SetupControlledEME(test, token,
    {
      onsessioncreated: function(session) {
        ok(sessions.indexOf(session) === -1, "Session[" + session.sessionId + "] should only be created once");
        sessions.push(session);
        session.addEventListener("keystatuseschange", KeysChangeFunc(session, test.keys, token), false);
      },
      onsessionupdated: function(session) {
        if (session) {
          ok(sessions.indexOf(session) !== -1, "Updated session[" + session.sessionId + "] should be in previously-created session list");
          ok(updatedSessions.indexOf(session) === -1, "Session[" + session.sessionId + "] should only be updated once");
          updatedSessions.push(session);
        } else {
          // Special case for this early test: Just assume 2nd session is updated ok.
          // Dummy "updatedSessions" for we start loading data...
          updatedSessions.push("dummy");
        }
        if (updatedSessions.length == test.sessionCount) {
          if (loaded) {
            Log(token, "Updated all sessions, loading complete -> Play");
            Play();
          } else {
            Log(token, "Updated all sessions, loading not complete -> Don't play yet");
          }
        } else {
          Log(token, "Updated " + updatedSessions.length + "/" + test.sessionCount + " sessions so far");
        }
      },
    }
  );

  var gotEncrypted = 0;
  var gotPlaying = false;

  v.addEventListener("encrypted", function(ev) {
    gotEncrypted += 1;
  });

  v.addEventListener("playing", function () { gotPlaying = true; });

  v.addEventListener("loadedmetadata", function() {
    ok(SpecialPowers.do_lookupGetter(v, "isEncrypted").apply(v),
       TimeStamp(token) + " isEncrypted should be true");
    is(v.isEncrypted, undefined, "isEncrypted should not be accessible from content");
  });

  v.addEventListener("ended", function(ev) {
    ok(true, TimeStamp(token) + " got ended event");

    is(gotEncrypted, test.sessionCount,
       TimeStamp(token) + " encrypted events expected: " + test.sessionCount
       + ", actual: " + gotEncrypted);
    ok(gotPlaying, TimeStamp(token) + " playing event should have fired");

    ok(Math.abs(test.duration - v.duration) < 0.1,
       TimeStamp(token) + " Duration of video should be corrrect");
    ok(Math.abs(test.duration - v.currentTime) < 0.1,
       TimeStamp(token) + " Current time should be same as duration");

    // Verify all sessions had all keys went sent the to the CDM usable, and thus
    // that we received keystatuseschange event(s).
    is(sessions.length, test.sessionCount, TimeStamp(token) + " should have "
                        + test.sessionCount + " session" + (test.sessionCount === 1 ? "" : "s"));
    for (var i = 0; i < sessions.length; i++) {
      var session = sessions[i];
      ok(session.gotKeysChanged, TimeStamp(token) + " should have received at least one keychange event");
      for (var kid in session.keyIdsReceived) {
        ok(session.keyIdsReceived[kid], TimeStamp(token) + " key with id " + kid + " was usable as expected");
      }
    }

    manager.finished(token);
  });

  LoadControlledEME(v)
  .then(function() {
    loaded = true;
    if (updatedSessions.length === test.sessionCount) {
      Log(token, "Loaded all segments, all sessions up-to-date -> Play.");
      Play();
    } else {
      Log(token, "Loaded all segments, only " + updatedSessions.length
                 + "/" + test.sessionCount + " sessions up-to-date -> Don't play yet");
    }
  }).catch(function(reason) {
    ok(false, token + " failed to load, reason: " + (reason ? reason : "?"));
    manager.finished(token);
  });

  function Play()
  {
    var lastState = "(before play)";
    var maxWait_ms = (test.duration * 2 + 1) * 1000;
    var playTimer = setTimeout(function() {
      if (lastState !== "ended") {
        ok(false, TimeStamp(token) + " expected 'ended' around "
                  + test.duration + "s, got '" + lastState
                  + "' after " + (maxWait_ms / 1000) + "s");
        manager.finished(token);
      }
    }, maxWait_ms);
    v.addEventListener("ended", function(ev) {
      clearTimeout(playTimer);
      lastState = "ended";
    });
    [ "canplay", "canplaythrough", "error", "loadeddata",
      "loadedmetadata", "loadstart", "pause", "play", "playing", "progress",
      "stalled", "suspend", "waiting",
    ].forEach(function(e) {
      v.addEventListener(e, function(event) {
        lastState = e;
      });
    });

    v.play();
  }
}

function beginTest() {
  manager.runTests(gEMETests, startTest);
}

var prefs = [
  [ "media.mediasource.enabled", true ],
  [ "media.mediasource.whitelist", false ],
  [ "media.mediasource.mp4.enabled", true ],
];

if (/Linux/.test(navigator.userAgent) ||
    !document.createElement('video').canPlayType("video/mp4")) {
  // XXX remove once we have mp4 PlatformDecoderModules on all platforms.
  prefs.push([ "media.fragmented-mp4.exposed", true ]);
  prefs.push([ "media.fragmented-mp4.use-blank-decoder", true ]);
}

SimpleTest.waitForExplicitFinish();
SpecialPowers.pushPrefEnv({ "set" : prefs }, beginTest);
</script>
</pre>
</body>
</html>
