<?xml version="1.0"?>
<?xml-stylesheet href="chrome://global/skin" type="text/css"?>
<?xml-stylesheet href="chrome://mochikit/content/tests/SimpleTest/test.css"
                 type="text/css"?>
<window title="Testing nsITextInputProcessor behavior"
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
  onunload="onunload();">
<script type="application/javascript"
        src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>
<body  xmlns="http://www.w3.org/1999/xhtml">
<p id="display">
<input id="input" type="text"/><br/>
<iframe id="iframe" width="300" height="150"
        src="data:text/html,&lt;textarea id='textarea' cols='20' rows='4'&gt;&lt;/textarea&gt;"></iframe><br/>
</p>
<div id="content" style="display: none">
  
</div>
<pre id="test">
</pre>
</body>

<script class="testbody" type="application/javascript">
<![CDATA[

var SpecialPowers = window.opener.wrappedJSObject.SpecialPowers;
var SimpleTest = window.opener.wrappedJSObject.SimpleTest;

SimpleTest.waitForFocus(runTests, window);

function ok(aCondition, aMessage)
{
  SimpleTest.ok(aCondition, aMessage);
}

function is(aLeft, aRight, aMessage)
{
  SimpleTest.is(aLeft, aRight, aMessage);
}

function isnot(aLeft, aRight, aMessage)
{
  SimpleTest.isnot(aLeft, aRight, aMessage);
}

function todo_is(aLeft, aRight, aMessage)
{
  SimpleTest.todo_is(aLeft, aRight, aMessage);
}

function finish()
{
  window.close();
}

function onunload()
{
  SimpleTest.finish();
}

var iframe = document.getElementById("iframe");
var childWindow = iframe.contentWindow;
var textareaInFrame;
var input = document.getElementById("input");
var otherWindow = window.opener;
var otherDocument = otherWindow.document;
var inputInChildWindow = otherDocument.getElementById("input");

function createTIP()
{
  return Components.classes["@mozilla.org/text-input-processor;1"].
           createInstance(Components.interfaces.nsITextInputProcessor);
}

function runBeginInputTransactionMethodTests()
{
  var description = "runBeginInputTransactionMethodTests: ";
  input.value = "";
  input.focus();

  var simpleCallback = function (aTIP, aNotification)
  {
    switch (aNotification.type) {
      case "request-to-commit":
        aTIP.commitComposition();
        break;
      case "request-to-cancel":
        aTIP.cancelComposition();
        break;
    }
    return true;
  };

  var TIP1 = createTIP();
  var TIP2 = createTIP();
  isnot(TIP1, TIP2,
        description + "TIP instances should be different");

  // beginInputTransaction() and beginInputTransactionForTests() can take ownership if there is no composition.
  ok(TIP1.beginInputTransaction(window, simpleCallback),
     description + "TIP1.beginInputTransaction(window) should succeed because there is no composition");
  ok(TIP1.beginInputTransactionForTests(window),
     description + "TIP1.beginInputTransactionForTests(window) should succeed because there is no composition");
  ok(TIP2.beginInputTransaction(window, simpleCallback),
     description + "TIP2.beginInputTransaction(window) should succeed because there is no composition");
  ok(TIP2.beginInputTransactionForTests(window),
     description + "TIP2.beginInputTransactionForTests(window) should succeed because there is no composition");

  // Start composition with TIP1, then, other TIPs cannot take ownership during a composition.
  ok(TIP1.beginInputTransactionForTests(window),
     description + "TIP1.beginInputTransactionForTests() should succeed because there is no composition");
  var composingStr = "foo";
  TIP1.setPendingCompositionString(composingStr);
  TIP1.appendClauseToPendingComposition(composingStr.length, TIP1.ATTR_RAW_CLAUSE);
  ok(TIP1.flushPendingComposition(),
     description + "TIP1.flushPendingComposition() should return true becuase it should be valid composition");
  is(input.value, composingStr,
     description + "The input element should have composing string");

  // Composing nsITextInputProcessor instance shouldn't allow initialize it again.
  try {
    TIP1.beginInputTransaction(window, simpleCallback);
    ok(false,
       "TIP1.beginInputTransaction(window) should cause throwing an exception because it's composing with different purpose");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ALREADY_INITIALIZED"),
       description + "TIP1.beginInputTransaction(window) should cause throwing an exception including NS_ERROR_ALREADY_INITIALIZED because it's composing for tests");
  }
  try {
    TIP1.beginInputTransactionForTests(otherWindow);
    ok(false,
       "TIP1.beginInputTransactionForTests(otherWindow) should cause throwing an exception because it's composing on different window");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ALREADY_INITIALIZED"),
       description + "TIP1.beginInputTransaction(otherWindow) should cause throwing an exception including NS_ERROR_ALREADY_INITIALIZED because it's composing on this window");
  }
  ok(TIP1.beginInputTransactionForTests(window),
     description + "TIP1.beginInputTransactionForTests(window) should succeed because TextEventDispatcher was initialized with same purpose");
  ok(TIP1.beginInputTransactionForTests(childWindow),
     description + "TIP1.beginInputTransactionForTests(childWindow) should succeed because TextEventDispatcher was initialized with same purpose and is shared by window and childWindow");
  ok(!TIP2.beginInputTransaction(window, simpleCallback),
     description + "TIP2.beginInputTransaction(window) should not succeed because there is composition synthesized by TIP1");
  ok(!TIP2.beginInputTransactionForTests(window),
     description + "TIP2.beginInputTransactionForTests(window) should not succeed because there is composition synthesized by TIP1");
  ok(!TIP2.beginInputTransaction(childWindow, simpleCallback),
     description + "TIP2.beginInputTransaction(childWindow) should not succeed because there is composition synthesized by TIP1");
  ok(!TIP2.beginInputTransactionForTests(childWindow),
     description + "TIP2.beginInputTransactionForTests(childWindow) should not succeed because there is composition synthesized by TIP1");
  ok(TIP2.beginInputTransaction(otherWindow, simpleCallback),
     description + "TIP2.beginInputTransaction(otherWindow) should succeed because there is composition synthesized by TIP1 but it's in other window");
  ok(TIP2.beginInputTransactionForTests(otherWindow),
     description + "TIP2.beginInputTransactionForTests(otherWindow) should succeed because there is composition synthesized by TIP1 but it's in other window");

  // Let's confirm that the composing string is NOT committed by above tests.
  ok(TIP1.commitComposition(),
     description + "TIP1.commitString() should succeed because there should be composing string");
  is(input.value, composingStr,
     description + "TIP1.commitString() without specifying commit string should be committed with the last composing string");

  ok(TIP1.beginInputTransaction(window, simpleCallback),
     description + "TIP1.beginInputTransaction() should succeed because there is no composition #2");
  ok(TIP1.beginInputTransactionForTests(window),
     description + "TIP1.beginInputTransactionForTests() should succeed because there is no composition #2");
  ok(TIP2.beginInputTransactionForTests(window),
     description + "TIP2.beginInputTransactionForTests() should succeed because the composition was already committed #2");

  // Let's check if startComposition() throws an exception after ownership is strolen.
  input.value = "";
  try {
    TIP1.startComposition();
    ok(false,
       description + "TIP1.startComposition() should cause throwing an exception because TIP2 took the ownership");
    TIP1.cancelComposition();
  } catch (e) {
    ok(e.message.contains("NS_ERROR_NOT_INITIALIZED"),
       description + "TIP1.startComposition() should cause throwing an exception including NS_ERROR_NOT_INITIALIZED");
  } finally {
    is(input.value, "",
       description + "The input element should not have commit string");
  }

  // Let's check if flushPendingComposition() throws an exception after ownership is stolen.
  ok(TIP1.beginInputTransactionForTests(window),
     description + "TIP1.beginInputTransactionForTests() should succeed because there is no composition");
  ok(TIP2.beginInputTransactionForTests(window),
     description + "TIP2.beginInputTransactionForTests() should succeed because there is no composition");
  input.value = "";
  try {
    TIP1.setPendingCompositionString(composingStr);
    TIP1.appendClauseToPendingComposition(composingStr.length, TIP1.ATTR_RAW_CLAUSE);
    TIP1.flushPendingComposition()
    ok(false,
       description + "TIP1.flushPendingComposition() should cause throwing an exception because TIP2 took the ownership");
    TIP1.cancelComposition();
  } catch (e) {
    ok(e.message.contains("NS_ERROR_NOT_INITIALIZED"),
       description + "TIP1.flushPendingComposition() should cause throwing an exception including NS_ERROR_NOT_INITIALIZED");
  } finally {
    is(input.value, "",
       description + "The input element should not have commit string");
  }

  // Let's check if commitComposition("bar") throws an exception after ownership is stolen.
  ok(TIP1.beginInputTransactionForTests(window),
     description + "TIP1.beginInputTransactionForTests() should succeed because there is no composition");
  ok(TIP2.beginInputTransactionForTests(window),
     description + "TIP2.beginInputTransactionForTests() should succeed because there is no composition");
  input.value = "";
  try {
    TIP1.commitComposition("bar");
    ok(false,
       description + "TIP1.commitComposition(\"bar\") should cause throwing an exception because TIP2 took the ownership");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_NOT_INITIALIZED"),
       description + "TIP1.commitComposition(\"bar\") should cause throwing an exception including NS_ERROR_NOT_INITIALIZED");
  } finally {
    is(input.value, "",
       description + "The input element should not have commit string");
  }

  // Let's check if keydown() throws an exception after ownership is stolen.
  ok(TIP1.beginInputTransactionForTests(window),
     description + "TIP1.beginInputTransactionForTests() should succeed because there is no composition");
  ok(TIP2.beginInputTransactionForTests(window),
     description + "TIP2.beginInputTransactionForTests() should succeed because there is no composition");
  input.value = "";
  try {
    var keyF = new KeyboardEvent("", { key: "f", code: "KeyF", keyCode: KeyboardEvent.DOM_VK_F });
    TIP1.keydown(keyF);
    ok(false,
       description + "TIP1.keydown(keyF) should cause throwing an exception because TIP2 took the ownership");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_NOT_INITIALIZED"),
       description + "TIP1.keydown(keyF) should cause throwing an exception including NS_ERROR_NOT_INITIALIZED");
  } finally {
    is(input.value, "",
       description + "The input element should not be modified");
  }

  // Let's check if keyup() throws an exception after ownership is stolen.
  ok(TIP1.beginInputTransactionForTests(window),
     description + "TIP1.beginInputTransactionForTests() should succeed because there is no composition");
  ok(TIP2.beginInputTransactionForTests(window),
     description + "TIP2.beginInputTransactionForTests() should succeed because there is no composition");
  input.value = "";
  try {
    var keyF = new KeyboardEvent("", { key: "f", code: "KeyF", keyCode: KeyboardEvent.DOM_VK_F });
    TIP1.keyup(keyF);
    ok(false,
       description + "TIP1.keyup(keyF) should cause throwing an exception because TIP2 took the ownership");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_NOT_INITIALIZED"),
       description + "TIP1.keyup(keyF) should cause throwing an exception including NS_ERROR_NOT_INITIALIZED");
  } finally {
    is(input.value, "",
       description + "The input element should not be modified");
  }

  // aCallback of nsITextInputProcessor.beginInputTransaction() must not be omitted.
  try {
    TIP1.beginInputTransaction(window);
    ok(false,
       description + "TIP1.beginInputTransaction(window) should be failed since aCallback is omitted");
  } catch (e) {
    ok(e.message.contains("Not enough arguments"),
       description + "TIP1.beginInputTransaction(window) should cause throwing an exception including \"Not enough arguments\" since aCallback is omitted");
  }

  // aCallback of nsITextInputProcessor.beginInputTransaction() must not be undefined.
  try {
    TIP1.beginInputTransaction(window, undefined);
    ok(false,
       description + "TIP1.beginInputTransaction(window, undefined) should be failed since aCallback is undefined");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "TIP1.beginInputTransaction(window, undefined) should cause throwing an exception including NS_ERROR_ILLEGAL_VALUE since aCallback is undefined");
  }

  // aCallback of nsITextInputProcessor.beginInputTransaction() must not be null.
  try {
    TIP1.beginInputTransaction(window, null);
    ok(false,
       description + "TIP1.beginInputTransaction(window, null) should be failed since aCallback is null");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "TIP1.beginInputTransaction(window, null) should cause throwing an exception including NS_ERROR_ILLEGAL_VALUE since aCallback is null");
  }
}

function runReleaseTests()
{
  var description = "runReleaseTests(): ";

  var TIP = createTIP();
  ok(TIP.beginInputTransactionForTests(window),
     description + "TIP.beginInputTransactionForTests() should succeed");

  input.value = "";
  input.focus();

  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  is(input.value, "foo",
     description + "the input should have composition string");

  // Release the TIP
  TIP = null;
  // Needs to run GC forcibly for testing this.
  SpecialPowers.gc();

  is(input.value, "",
     description + "the input should be empty because the composition should be canceled");

  TIP = createTIP();
  ok(TIP.beginInputTransactionForTests(window),
     description + "TIP.beginInputTransactionForTests() should succeed #2");
}

function runCompositionTests()
{
  var description = "runCompositionTests(): ";

  var TIP = createTIP();
  ok(TIP.beginInputTransactionForTests(window),
     description + "TIP.beginInputTransactionForTests() should succeed");

  var events;

  function reset()
  {
    events = [];
  }

  function handler(aEvent)
  {
    events.push({ "type": aEvent.type, "data": aEvent.data });
  }

  window.addEventListener("compositionstart", handler, false);
  window.addEventListener("compositionupdate", handler, false);
  window.addEventListener("compositionend", handler, false);

  input.value = "";
  input.focus();

  // nsITextInputProcessor.startComposition()
  reset();
  TIP.startComposition();
  is(events.length, 1,
     description + "startComposition() should cause only compositionstart");
  is(events[0].type, "compositionstart",
     description + "startComposition() should cause only compositionstart");
  is(input.value, "",
     description + "startComposition() shouldn't modify the focused editor");

  // Setting composition string "foo" as a raw clause
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);

  reset();
  TIP.flushPendingComposition();
  is(events.length, 1,
     description + "flushPendingComposition() after startComposition() should cause compositionupdate");
  is(events[0].type, "compositionupdate",
     description + "flushPendingComposition() after startComposition() should cause compositionupdate");
  is(events[0].data, "foo",
     description + "compositionupdate caused by flushPendingComposition() should have new composition string in its data");
  is(input.value, "foo",
     description + "modifying composition string should cause modifying the focused editor");

  // Changing the raw clause to a selected clause
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_SELECTED_CLAUSE);

  reset();
  TIP.flushPendingComposition();
  is(events.length, 0,
     description + "flushPendingComposition() changing only clause information shouldn't cause compositionupdate");
  is(input.value, "foo",
     description + "modifying composition clause shouldn't cause modifying the focused editor");

  // Separating the selected clause to two clauses
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(2, TIP.ATTR_SELECTED_CLAUSE);
  TIP.appendClauseToPendingComposition(1, TIP.ATTR_CONVERTED_CLAUSE);
  TIP.setCaretInPendingComposition(2);

  reset();
  TIP.flushPendingComposition();
  is(events.length, 0,
     description + "flushPendingComposition() separating a clause information shouldn't cause compositionupdate");
  is(input.value, "foo",
     description + "separating composition clause shouldn't cause modifying the focused editor");

  // Modifying the composition string
  TIP.setPendingCompositionString("FOo");
  TIP.appendClauseToPendingComposition(2, TIP.ATTR_SELECTED_CLAUSE);
  TIP.appendClauseToPendingComposition(1, TIP.ATTR_CONVERTED_CLAUSE);
  TIP.setCaretInPendingComposition(2);

  reset();
  TIP.flushPendingComposition();
  is(events.length, 1,
     description + "flushPendingComposition() causing modifying composition string should cause compositionupdate");
  is(events[0].type, "compositionupdate",
     description + "flushPendingComposition() causing modifying composition string should cause compositionupdate");
  is(events[0].data, "FOo",
     description + "compositionupdate caused by flushPendingComposition() should have new composition string in its data");
  is(input.value, "FOo",
     description + "modifying composition clause shouldn't cause modifying the focused editor");

  // Committing the composition string
  reset();
  TIP.commitComposition();
  is(events.length, 1,
     description + "commitComposition() should cause compositionend but shoudn't cause compositionupdate");
  is(events[0].type, "compositionend",
     description + "commitComposition() should cause compositionend");
  is(events[0].data, "FOo",
     description + "compositionend caused by commitComposition() should have the committed string in its data");
  is(input.value, "FOo",
     description + "commitComposition() shouldn't cause modifying the focused editor");

  // Starting new composition without a call of startComposition()
  TIP.setPendingCompositionString("bar");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);

  reset();
  TIP.flushPendingComposition();
  is(events.length, 2,
     description + "flushPendingComposition() without a call of startComposition() should cause both compositionstart and compositionupdate");
  is(events[0].type, "compositionstart",
     description + "flushPendingComposition() without a call of startComposition() should cause compositionstart");
  is(events[1].type, "compositionupdate",
     description + "flushPendingComposition() without a call of startComposition() should cause compositionupdate after compositionstart");
  is(events[1].data, "bar",
     description + "compositionupdate caused by flushPendingComposition() without a call of startComposition() should have the composition string in its data");
  is(input.value, "FOobar",
     description + "new composition string should cause appending composition string to the focused editor");

  // Canceling the composition
  reset();
  TIP.cancelComposition();
  is(events.length, 2,
     description + "cancelComposition() should cause both compositionupdate and compositionend");
  is(events[0].type, "compositionupdate",
     description + "cancelComposition() should cause compositionupdate");
  is(events[0].data, "",
     description + "compositionupdate caused by cancelComposition() should have empty string in its data");
  is(events[1].type, "compositionend",
     description + "cancelComposition() should cause compositionend after compositionupdate");
  is(events[1].data, "",
     description + "compositionend caused by cancelComposition() should have empty string in its data");
  is(input.value, "FOo",
     description + "canceled composition string should be removed from the focused editor");

  // Starting composition explicitly and canceling it
  reset();
  TIP.startComposition();
  TIP.cancelComposition();
  is(events.length, 2,
     description + "canceling composition immediately after startComposition() should cause compositionstart and compositionend");
  is(events[0].type, "compositionstart",
     description + "canceling composition immediately after startComposition() should cause compositionstart first");
  is(events[1].type, "compositionend",
     description + "canceling composition immediately after startComposition() should cause compositionend after compositionstart");
  is(events[1].data, "",
     description + "compositionend caused by canceling composition should have empty string in its data");
  is(input.value, "FOo",
     description + "canceling composition shouldn't modify the focused editor");

  // Create composition for next test.
  TIP.setPendingCompositionString("bar");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.flushPendingComposition();
  is(input.value, "FOobar",
     description + "The focused editor should have new composition string \"bar\"");

  // Allow to set empty composition string
  reset();
  TIP.flushPendingComposition();
  is(events.length, 1,
     description + "making composition string empty should cause only compositionupdate");
  is(events[0].type, "compositionupdate",
     description + "making composition string empty should cause compositionupdate");
  is(events[0].data, "",
     description + "compositionupdate caused by making composition string empty should have empty string in its data");

  // Allow to insert new composition string without compositionend/compositionstart
  TIP.setPendingCompositionString("buzz");
  TIP.appendClauseToPendingComposition(4, TIP.ATTR_RAW_CLAUSE);

  reset();
  TIP.flushPendingComposition();
  is(events.length, 1,
     description + "modifying composition string from empty string should cause only compositionupdate");
  is(events[0].type, "compositionupdate",
     description + "modifying composition string from empty string should cause compositionupdate");
  is(events[0].data, "buzz",
     description + "compositionupdate caused by modifying composition string from empty string should have new composition string in its data");
  is(input.value, "FOobuzz",
     description + "new composition string should be appended to the focused editor");

  // Committing with different string
  reset();
  TIP.commitComposition("bar");
  is(events.length, 2,
     description + "committing with different string should cause compositionupdate and compositionend");
  is(events[0].type, "compositionupdate",
     description + "committing with different string should cause compositionupdate first");
  is(events[0].data, "bar",
     description + "compositionupdate caused by committing with different string should have the committing string in its data");
  is(events[1].type, "compositionend",
     description + "committing with different string should cause compositionend after compositionupdate");
  is(events[1].data, "bar",
     description + "compositionend caused by committing with different string should have the committing string in its data");
  is(input.value, "FOobar",
     description + "new committed string should be appended to the focused editor");

  // Appending new composition string
  TIP.setPendingCompositionString("buzz");
  TIP.appendClauseToPendingComposition(4, TIP.ATTR_RAW_CLAUSE);
  TIP.flushPendingComposition();
  is(input.value, "FOobarbuzz",
     description + "new composition string should be appended to the focused editor");

  // Committing with same string
  reset();
  TIP.commitComposition("buzz");
  is(events.length, 1,
     description + "committing with same string should cause only compositionend");
  is(events[0].type, "compositionend",
     description + "committing with same string should cause compositionend");
  is(events[0].data, "buzz",
     description + "compositionend caused by committing with same string should have the committing string in its data");
  is(input.value, "FOobarbuzz",
     description + "new committed string should be appended to the focused editor");

  // Inserting commit string directly
  reset();
  TIP.commitComposition("boo!");
  is(events.length, 3,
     description + "committing text directly should cause compositionstart, compositionupdate and compositionend");
  is(events[0].type, "compositionstart",
     description + "committing text directly should cause compositionstart first");
  is(events[1].type, "compositionupdate",
     description + "committing text directly should cause compositionupdate after compositionstart");
  is(events[1].data, "boo!",
     description + "compositionupdate caused by committing text directly should have the committing text in its data");
  is(events[2].type, "compositionend",
     description + "committing text directly should cause compositionend after compositionupdate");
  is(events[2].data, "boo!",
     description + "compositionend caused by committing text directly should have the committing text in its data");
  is(input.value, "FOobarbuzzboo!",
     description + "committing text directly should append the committing text to the focused editor");

  window.removeEventListener("compositionstart", handler, false);
  window.removeEventListener("compositionupdate", handler, false);
  window.removeEventListener("compositionend", handler, false);
}

function runKeyTests()
{
  var description = "runKeyTests(): ";

  var TIP = createTIP();
  ok(TIP.beginInputTransactionForTests(window),
     description + "TIP.beginInputTransactionForTests() should succeed");

  var events;
  var doPreventDefaults;

  function reset()
  {
    events = [];
    doPreventDefaults = [];
  }

  function handler(aEvent)
  {
    events.push(aEvent);
    if (doPreventDefaults.indexOf(aEvent.type) >= 0) {
      aEvent.preventDefault();
    }
  }

  function checkKeyAttrs(aMethodDescription, aEvent, aExpectedData)
  {
    var desc = description + aMethodDescription + ", type=\"" + aEvent.type + "\", key=\"" + aEvent.key + "\", code=\"" + aEvent.code + "\": ";
    var defaultValues = {
      key: "Unidentified", code: "", keyCode: 0, charCode: 0,
      location: KeyboardEvent.DOM_KEY_LOCATION_STANDARD, repeat: false, isComposing: false,
      shiftKey: false, ctrlKey: false, altKey: false, metaKey: false,
      defaultPrevented: false
    };
    var modifiers = [
      "AltGraph", "CapsLock", "Fn", "NumLock", "OS", "ScrollLock", "Symbol"
    ];
    function expectedValue(aAttr)
    {
      return aExpectedData[aAttr] !== undefined ? aExpectedData[aAttr] : defaultValues[aAttr];
    }
    is(aEvent.type, aExpectedData.type,
       desc + " should cause keydown event");
    if (aEvent.type != aExpectedData.type) {
      return;
    }
    is(aEvent.defaultPrevented, expectedValue("defaultPrevented"),
       desc + ".defaultPrevented is wrong");
    is(aEvent.key, expectedValue("key"),
       desc + ".key is wrong");
    if (SpecialPowers.getBoolPref("dom.keyboardevent.code.enabled")) {
      is(aEvent.code, expectedValue("code"),
         desc + ".code is wrong");
    }
    is(aEvent.location, expectedValue("location"),
       desc + ".location is wrong");
    is(aEvent.repeat, expectedValue("repeat"),
       desc + ".repeat is wrong");
    is(aEvent.isComposing, expectedValue("isComposing"),
       desc + ".isComposing is wrong");
    is(aEvent.keyCode, expectedValue("keyCode"),
       desc + ".keyCode is wrong");
    is(aEvent.charCode, expectedValue("charCode"),
       desc + ".charCode is wrong");
    is(aEvent.shiftKey, expectedValue("shiftKey"),
       desc + ".shiftKey is wrong");
    is(aEvent.ctrlKey, expectedValue("ctrlKey"),
       desc + ".ctrlKey is wrong");
    is(aEvent.altKey, expectedValue("altKey"),
       desc + ".altKey is wrong");
    is(aEvent.metaKey, expectedValue("metaKey"),
       desc + ".metaKey is wrong");
    for (var i = 0; i < modifiers.length; i++) {
      is(aEvent.getModifierState(modifiers[i]), aExpectedData[modifiers[i]] !== undefined ? aExpectedData[modifiers[i]] : false,
         desc + ".getModifierState(\"" + modifiers[i] + "\") is wrong");
    }
  }

  window.addEventListener("keydown", handler, false);
  window.addEventListener("keypress", handler, false);
  window.addEventListener("keyup", handler, false);

  input.value = "";
  input.focus();


  // Printable key test:
  // Emulates pressing 'a' key.
  var keyA = new KeyboardEvent("", { key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A });

  reset();
  var doDefaultKeydown = TIP.keydown(keyA);

  ok(!doDefaultKeydown,
     description + "TIP.keydown(keyA) should return false because the keypress event should be consumed by the input element");
  is(events.length, 2,
     description + "TIP.keydown(keyA) should cause keydown and keypress event");
  checkKeyAttrs("TIP.keydown(keyA)", events[0],
                { type: "keydown",  key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A, charCode: 0 });
  checkKeyAttrs("TIP.keydown(keyA)", events[1],
                { type: "keypress", key: "a", code: "KeyA", keyCode: 0,                      charCode: "a".charCodeAt(0), defaultPrevented: true });
  is(input.value, "a",
     description + "input.value should be \"a\" which is inputted by TIP.keydown(keyA)");

  // Emulates releasing 'a' key.
  reset();
  var doDefaultKeyup = TIP.keyup(keyA);
  ok(doDefaultKeyup,
     description + "TIP.keyup(keyA) should return true");
  is(events.length, 1,
     description + "TIP.keyup(keyA) should cause keyup event");
  checkKeyAttrs("TIP.keyup(keyA)", events[0],
                { type: "keyup",      key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A, charCode: 0 });
  is(input.value, "a",
     description + "input.value should stay \"a\" which was inputted by TIP.keydown(keyA)");


  // Non-printable key test:
  // Emulates pressing Enter key.
  var keyEnter = new KeyboardEvent("", { key: "Enter", code: "Enter" });

  reset();
  doDefaultKeydown = TIP.keydown(keyEnter);

  ok(doDefaultKeydown,
     description + "TIP.keydown(keyEnter) should return true");
  is(events.length, 2,
     description + "TIP.keydown(keyEnter) should cause keydown and keypress event");
  checkKeyAttrs("TIP.keydown(keyEnter)", events[0],
                { type: "keydown",  key: "Enter", code: "Enter" });
  checkKeyAttrs("TIP.keydown(keyEnter)", events[1],
                { type: "keypress", key: "Enter", code: "Enter" });
  is(input.value, "a",
     description + "input.value should stay \"a\" which was inputted by TIP.keydown(keyA)");

  // Emulates releasing Enter key.
  reset();
  doDefaultKeyup = TIP.keyup(keyEnter);
  ok(doDefaultKeyup,
     description + "TIP.keyup(keyEnter) should return true");
  is(events.length, 1,
     description + "TIP.keyup(keyEnter) should cause keyup event");
  checkKeyAttrs("TIP.keyup(keyEnter)", events[0],
                { type: "keyup",      key: "Enter", code: "Enter" });
  is(input.value, "a",
     description + "input.value should stay \"a\" which was inputted by TIP.keydown(keyA)");


  // KEY_DEFAULT_PREVENTED should cause defaultPrevented = true and not cause keypress event
  var keyB = new KeyboardEvent("", { key: "b", code: "KeyB", keyCode: KeyboardEvent.DOM_VK_B });

  reset();
  doDefaultKeydown = TIP.keydown(keyB, TIP.KEY_DEFAULT_PREVENTED);
  doDefaultKeyup   = TIP.keyup(keyB, TIP.KEY_DEFAULT_PREVENTED);

  ok(!doDefaultKeydown,
     description + "TIP.keydown(keyB, TIP.KEY_DEFAULT_PREVENTED) should return false because it's marked as consumed at dispatching the event");
  ok(!doDefaultKeyup,
     description + "TIP.keyup(keyB, TIP.KEY_DEFAULT_PREVENTED) should return false because it's marked as consumed at dispatching the event");
  is(events.length, 2,
     description + "TIP.keydown(keyB, TIP.KEY_DEFAULT_PREVENTED) and TIP.keyup(keyB, TIP.KEY_DEFAULT_PREVENTED) should cause keydown and keyup event");
  checkKeyAttrs("TIP.keydown(keyB, TIP.KEY_DEFAULT_PREVENTED) and TIP.keyup(keyB, TIP.KEY_DEFAULT_PREVENTED)", events[0],
                { type: "keydown", key: "b", code: "KeyB", keyCode: KeyboardEvent.DOM_VK_B, defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyB, TIP.KEY_DEFAULT_PREVENTED) and TIP.keyup(keyB, TIP.KEY_DEFAULT_PREVENTED)", events[1],
                { type: "keyup",   key: "b", code: "KeyB", keyCode: KeyboardEvent.DOM_VK_B, defaultPrevented: true });
  is(input.value, "a",
     description + "input.value shouldn't be modified by default prevented key events");

  // Assume that KeyX causes inputting text "abc"
  input.value = "";
  var keyABC = new KeyboardEvent("", { key: "abc", code: "KeyX", keyCode: KeyboardEvent.DOM_VK_A });

  reset();
  doDefaultKeydown = TIP.keydown(keyABC);
  doDefaultKeyup   = TIP.keyup(keyABC);

  ok(!doDefaultKeydown,
     description + "TIP.keydown(keyABC) should return false because the keypress events should be consumed by the input element");
  ok(doDefaultKeyup,
     description + "TIP.keyup(keyABC) should return true");
  is(events.length, 5,
     description + "TIP.keydown(keyABC) and TIP.keyup(keyABC) should cause keydown, keypress, keypress, keypress and keyup event");
  checkKeyAttrs("TIP.keydown(keyABC) and TIP.keyup(keyABC)", events[0],
                { type: "keydown",  key: "abc",           code: "KeyX", keyCode: KeyboardEvent.DOM_VK_A, charCode: 0,                   defaultPrevented: false });
  checkKeyAttrs("TIP.keydown(keyABC) and TIP.keyup(keyABC)", events[1],
                { type: "keypress", key: "abc".charAt(0), code: "KeyX", keyCode: 0,                      charCode: "abc".charCodeAt(0), defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyABC) and TIP.keyup(keyABC)", events[2],
                { type: "keypress", key: "abc".charAt(1), code: "KeyX", keyCode: 0,                      charCode: "abc".charCodeAt(1), defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyABC) and TIP.keyup(keyABC)", events[3],
                { type: "keypress", key: "abc".charAt(2), code: "KeyX", keyCode: 0,                      charCode: "abc".charCodeAt(2), defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyABC) and TIP.keyup(keyABC)", events[4],
                { type: "keyup",    key: "abc",           code: "KeyX", keyCode: KeyboardEvent.DOM_VK_A, charCode: 0,                   defaultPrevented: false });
  is(input.value, "abc",
     description + "input.value should be \"abc\"");

  // If KEY_FORCE_PRINTABLE_KEY is specified, registered key names can be a printable key which inputs the specified value.
  input.value = "";
  var keyEnterPrintable = new KeyboardEvent("", { key: "Enter", code: "Enter", keyCode: KeyboardEvent.DOM_VK_RETURN });

  reset();
  doDefaultKeydown = TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY);
  doDefaultKeyup   = TIP.keyup(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY);

  ok(!doDefaultKeydown,
     description + "TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) should return false because the keypress events should be consumed by the input element");
  ok(doDefaultKeyup,
     description + "TIP.keyup(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) should return true");
  is(events.length, 7,
     description + "TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) and TIP.keyup(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) should cause keydown, keypress, keypress, keypress, keypress, keypress and keyup event");
  checkKeyAttrs("TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) and TIP.keyup(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY)", events[0],
                { type: "keydown",  key: "Enter",           code: "Enter", keyCode: KeyboardEvent.DOM_VK_RETURN, charCode: 0,                    defaultPrevented: false });
  checkKeyAttrs("TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) and TIP.keyup(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY)", events[1],
                { type: "keypress", key: "Enter".charAt(0), code: "Enter", keyCode: 0,                           charCode: "Enter".charCodeAt(0), defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) and TIP.keyup(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY)", events[2],
                { type: "keypress", key: "Enter".charAt(1), code: "Enter", keyCode: 0,                           charCode: "Enter".charCodeAt(1), defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) and TIP.keyup(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY)", events[3],
                { type: "keypress", key: "Enter".charAt(2), code: "Enter", keyCode: 0,                           charCode: "Enter".charCodeAt(2), defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) and TIP.keyup(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY)", events[4],
                { type: "keypress", key: "Enter".charAt(3), code: "Enter", keyCode: 0,                           charCode: "Enter".charCodeAt(3), defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) and TIP.keyup(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY)", events[5],
                { type: "keypress", key: "Enter".charAt(4), code: "Enter", keyCode: 0,                           charCode: "Enter".charCodeAt(4), defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY) and TIP.keyup(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY)", events[6],
                { type: "keyup",    key: "Enter",           code: "Enter", keyCode: KeyboardEvent.DOM_VK_RETURN, charCode: 0,                     defaultPrevented: false });
  is(input.value, "Enter",
     description + "input.value should be \"Enter\"");

  // modifiers should be ignored.
  var keyWithModifiers = new KeyboardEvent("", { key: "Escape", code: "Escape", shiftKey: true, ctrlKey: true, altKey: true, metaKey: true });

  reset();
  doDefaultKeydown = TIP.keydown(keyWithModifiers);
  doDefaultKeyup   = TIP.keyup(keyWithModifiers);

  ok(doDefaultKeydown,
     description + "TIP.keydown(keyWithModifiers) should return true");
  ok(doDefaultKeyup,
     description + "TIP.keyup(keyWithModifiers) should return true");
  is(events.length, 3,
     description + "TIP.keydown(keyWithModifiers) and TIP.keyup(keyWithModifiers) should cause keydown, keypress and keyup event");
  checkKeyAttrs("TIP.keydown(keyWithModifiers) and TIP.keyup(keyWithModifiers)", events[0],
                { type: "keydown",  key: "Escape", code: "Escape" });
  checkKeyAttrs("TIP.keydown(keyWithModifiers) and TIP.keyup(keyWithModifiers)", events[1],
                { type: "keypress", key: "Escape", code: "Escape" });
  checkKeyAttrs("TIP.keydown(keyWithModifiers) and TIP.keyup(keyWithModifiers)", events[2],
                { type: "keyup",    key: "Escape", code: "Escape" });
  is(input.value, "Enter",
     description + "input.value should stay \"Enter\" which was inputted by TIP.keydown(keyEnterPrintable, TIP.KEY_FORCE_PRINTABLE_KEY)");

  // Call preventDefault() at keydown
  input.value = "";
  reset();
  doPreventDefaults = [ "keydown" ];
  doDefaultKeydown = TIP.keydown(keyA);
  doDefaultKeyup   = TIP.keyup(keyA);

  ok(!doDefaultKeydown,
     description + "TIP.keydown(keyA) should return false because keydown event's preventDefault should be called");
  ok(doDefaultKeyup,
     description + "TIP.keyup(keyA) should return true");
  is(events.length, 2,
     description + "TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keydown should cause keydown and keyup event");
  checkKeyAttrs("TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keydown", events[0],
                { type: "keydown",  key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A, defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keydown", events[1],
                { type: "keyup",    key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A, defaultPrevented: false });
  is(input.value, "",
     description + "input.value shouldn't be modified by TIP.keyup(keyA) if the keydown event is consumed");

  // Call preventDefault() at keypress
  reset();
  doPreventDefaults = [ "keypress" ];
  doDefaultKeydown = TIP.keydown(keyA);
  doDefaultKeyup   = TIP.keyup(keyA);

  ok(!doDefaultKeydown,
     description + "TIP.keydown(keyA) should return false because keypress event's preventDefault should be called");
  ok(doDefaultKeyup,
     description + "TIP.keyup(keyA) should return true");
  is(events.length, 3,
     description + "TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keypress should cause keydown, keypress and keyup event");
  checkKeyAttrs("TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keypress", events[0],
                { type: "keydown",  key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A, charCode: 0,                 defaultPrevented: false });
  checkKeyAttrs("TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keypress", events[1],
                { type: "keypress", key: "a", code: "KeyA", keyCode: 0,                      charCode: "a".charCodeAt(0), defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keypress", events[2],
                { type: "keyup",    key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A, charCode: 0,                 defaultPrevented: false });
  is(input.value, "",
     description + "input.value shouldn't be modified by TIP.keyup(keyA) if the keypress event is consumed");

  // Call preventDefault() at keyup
  input.value = "";
  reset();
  doPreventDefaults = [ "keyup" ];
  doDefaultKeydown = TIP.keydown(keyA);
  doDefaultKeyup   = TIP.keyup(keyA);

  ok(!doDefaultKeydown,
     description + "TIP.keydown(keyA) should return false because the key event should be consumed by the input element");
  ok(!doDefaultKeyup,
     description + "TIP.keyup(keyA) should return false because keyup event's preventDefault should be called");
  is(events.length, 3,
     description + "TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keyup should cause keydown, keypress and keyup event");
  checkKeyAttrs("TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keyup", events[0],
                { type: "keydown",  key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A, charCode: 0,                 defaultPrevented: false });
  checkKeyAttrs("TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keyup", events[1],
                { type: "keypress", key: "a", code: "KeyA", keyCode: 0,                      charCode: "a".charCodeAt(0), defaultPrevented: true });
  checkKeyAttrs("TIP.keydown(keyA) and TIP.keyup(keyA) with preventing default of keyup", events[2],
                { type: "keyup",    key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A, charCode: 0,                 defaultPrevented: true });
  is(input.value, "a",
     description + "input.value should be \"a\" by TIP.keyup(keyA) even if the keyup event is consumed");

  // key events during composition
  try {
    SpecialPowers.setBoolPref("dom.keyboardevent.dispatch_during_composition", false);

    ok(TIP.startComposition(), "TIP.startComposition() should start composition");

    input.value = "";
    reset();
    TIP.keydown(keyA);
    is(events.length, 0,
       description + "TIP.keydown(keyA) shouldn't cause key events during composition if it's disabled by the pref");
    reset();
    TIP.keyup(keyA);
    is(events.length, 0,
       description + "TIP.keyup(keyA) shouldn't cause key events during composition if it's disabled by the pref");

    SpecialPowers.setBoolPref("dom.keyboardevent.dispatch_during_composition", true);
    reset();
    TIP.keydown(keyA);
    is(events.length, 1,
       description + "TIP.keydown(keyA) should cause keydown event even composition if it's enabled by the pref");
    checkKeyAttrs("TIP.keydown(keyA) during composition", events[0],
                  { type: "keydown",  key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A, charCode: 0, isComposing: true });
    reset();
    TIP.keyup(keyA);
    is(events.length, 1,
       description + "TIP.keyup(keyA) should cause keyup event even composition if it's enabled by the pref");
    checkKeyAttrs("TIP.keyup(keyA) during composition", events[0],
                  { type: "keyup",    key: "a", code: "KeyA", keyCode: KeyboardEvent.DOM_VK_A, charCode: 0, isComposing: true });

  } finally {
    TIP.cancelComposition();
    SpecialPowers.clearUserPref("dom.keyboardevent.dispatch_during_composition");
  }

  window.removeEventListener("keydown", handler, false);
  window.removeEventListener("keypress", handler, false);
  window.removeEventListener("keyup", handler, false);
}

function runErrorTests()
{
  var description = "runErrorTests(): ";

  var TIP = createTIP();
  ok(TIP.beginInputTransactionForTests(window),
     description + "TIP.beginInputTransactionForTests() should succeed");

  input.value = "";
  input.focus();

  // startComposition() should throw an exception if there is already a composition
  TIP.startComposition();
  try {
    TIP.startComposition();
    ok(false,
       description + "startComposition() should fail if it was already called");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_FAILURE"),
       description + "startComposition() should cause NS_ERROR_FAILURE if there is already composition");
  } finally {
    TIP.cancelComposition();
  }

  // cancelComposition() should throw an exception if there is no composition
  try {
    TIP.cancelComposition();
    ok(false,
       description + "cancelComposition() should fail if there is no composition");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_FAILURE"),
       description + "cancelComposition() should cause NS_ERROR_FAILURE if there is no composition");
  }

  // commitComposition() without commit string should throw an exception if there is no composition
  try {
    TIP.commitComposition();
    ok(false,
       description + "commitComposition() should fail if there is no composition");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_FAILURE"),
       description + "commitComposition() should cause NS_ERROR_FAILURE if there is no composition");
  }

  // commitComposition("") should throw an exception if there is no composition
  try {
    TIP.commitComposition("");
    ok(false,
       description + "commitComposition(\"\") should fail if there is no composition");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_FAILURE"),
       description + "commitComposition(\"\") should cause NS_ERROR_FAILURE if there is no composition");
  }

  // Pending composition string should allow to flush without clause information (for compatibility)
  try {
    TIP.setPendingCompositionString("foo");
    TIP.flushPendingComposition();
    ok(true,
       description + "flushPendingComposition() should succeed even if appendClauseToPendingComposition() has never been called");
    TIP.cancelComposition();
  } catch (e) {
    ok(false,
       description + "flushPendingComposition() shouldn't cause an exception even if appendClauseToPendingComposition() has never been called");
  }

  // Pending composition string must be filled by clause information
  try {
    TIP.setPendingCompositionString("foo");
    TIP.appendClauseToPendingComposition(2, TIP.ATTR_RAW_CLAUSE);
    TIP.flushPendingComposition();
    ok(false,
       description + "flushPendingComposition() should fail if appendClauseToPendingComposition() doesn't fill all composition string");
    TIP.cancelComposition();
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "flushPendingComposition() should cause NS_ERROR_ILLEGAL_VALUE if appendClauseToPendingComposition() doesn't fill all composition string");
  }

  // Pending composition string must not be shorter than appended clause length
  try {
    TIP.setPendingCompositionString("foo");
    TIP.appendClauseToPendingComposition(4, TIP.ATTR_RAW_CLAUSE);
    TIP.flushPendingComposition();
    ok(false,
       description + "flushPendingComposition() should fail if appendClauseToPendingComposition() appends longer clause information");
    TIP.cancelComposition();
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "flushPendingComposition() should cause NS_ERROR_ILLEGAL_VALUE if appendClauseToPendingComposition() appends longer clause information");
  }

  // Pending composition must not have clause information with empty string
  try {
    TIP.appendClauseToPendingComposition(1, TIP.ATTR_RAW_CLAUSE);
    TIP.flushPendingComposition();
    ok(false,
       description + "flushPendingComposition() should fail if there is a clause with empty string");
    TIP.cancelComposition();
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "flushPendingComposition() should cause NS_ERROR_ILLEGAL_VALUE if there is a clause with empty string");
  }

  // Appending a clause whose length is 0 should cause an exception
  try {
    TIP.appendClauseToPendingComposition(0, TIP.ATTR_RAW_CLAUSE);
    ok(false,
       description + "appendClauseToPendingComposition() should fail if the length is 0");
    TIP.flushPendingComposition();
    TIP.cancelComposition();
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "appendClauseToPendingComposition() should cause NS_ERROR_ILLEGAL_VALUE if the length is 0");
  }

  // Appending a clause whose attribute is invalid should cause an exception
  try {
    TIP.setPendingCompositionString("foo");
    TIP.appendClauseToPendingComposition(3, 0);
    ok(false,
       description + "appendClauseToPendingComposition() should fail if the attribute is invalid");
    TIP.flushPendingComposition();
    TIP.cancelComposition();
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "appendClauseToPendingComposition() should cause NS_ERROR_ILLEGAL_VALUE if the attribute is invalid");
  }

  // Setting caret position outside of composition string should cause an exception
  try {
    TIP.setPendingCompositionString("foo");
    TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
    TIP.setCaretInPendingComposition(4);
    TIP.flushPendingComposition();
    ok(false,
       description + "flushPendingComposition() should fail if caret position is out of composition string");
    TIP.cancelComposition();
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "flushPendingComposition() should cause NS_ERROR_ILLEGAL_VALUE if caret position is out of composition string");
  }

  // Calling keydown() with a KeyboardEvent initialized with invalid code value should cause an exception.
  input.value = "";
  try {
    var keyInvalidCode = new KeyboardEvent("", { key: "f", code: "InvalidCodeValue", keyCode: KeyboardEvent.DOM_VK_F });
    TIP.keydown(keyInvalidCode);
    ok(false,
       description + "TIP.keydown(keyInvalidCode) should cause throwing an exception because its code value is not registered");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "TIP.keydown(keyInvalidCode) should cause throwing an exception including NS_ERROR_ILLEGAL_VALUE");
  } finally {
    is(input.value, "",
       description + "The input element should not be modified");
  }

  // Calling keyup() with a KeyboardEvent initialized with invalid code value should cause an exception.
  input.value = "";
  try {
    var keyInvalidCode = new KeyboardEvent("", { key: "f", code: "InvalidCodeValue", keyCode: KeyboardEvent.DOM_VK_F });
    TIP.keyup(keyInvalidCode);
    ok(false,
       description + "TIP.keyup(keyInvalidCode) should cause throwing an exception because its code value is not registered");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "TIP.keyup(keyInvalidCode) should cause throwing an exception including NS_ERROR_ILLEGAL_VALUE");
  } finally {
    is(input.value, "",
       description + "The input element should not be modified");
  }

  // Calling keydown(KEY_NON_PRINTABLE_KEY) with a KeyboardEvent initialized with non-key name should cause an exception.
  input.value = "";
  try {
    var keyInvalidKey = new KeyboardEvent("", { key: "ESCAPE", code: "Escape", keyCode: KeyboardEvent.DOM_VK_Escape});
    TIP.keydown(keyInvalidKey, TIP.KEY_NON_PRINTABLE_KEY);
    ok(false,
       description + "TIP.keydown(keyInvalidKey, TIP.KEY_NON_PRINTABLE_KEY) should cause throwing an exception because its key value is not registered");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "keydown(keyInvalidKey, TIP.KEY_NON_PRINTABLE_KEY) should cause throwing an exception including NS_ERROR_ILLEGAL_VALUE");
  } finally {
    is(input.value, "",
       description + "The input element should not be modified");
  }

  // Calling keyup(KEY_NON_PRINTABLE_KEY) with a KeyboardEvent initialized with non-key name should cause an exception.
  input.value = "";
  try {
    var keyInvalidKey = new KeyboardEvent("", { key: "ESCAPE", code: "Escape", keyCode: KeyboardEvent.DOM_VK_Escape});
    TIP.keydown(keyInvalidKey, TIP.KEY_NON_PRINTABLE_KEY);
    ok(false,
       description + "TIP.keyup(keyInvalidKey, TIP.KEY_NON_PRINTABLE_KEY) should cause throwing an exception because its key value is not registered");
  } catch (e) {
    ok(e.message.contains("NS_ERROR_ILLEGAL_VALUE"),
       description + "keyup(keyInvalidKey, TIP.KEY_NON_PRINTABLE_KEY) should cause throwing an exception including NS_ERROR_ILLEGAL_VALUE");
  } finally {
    is(input.value, "",
       description + "The input element should not be modified");
  }
}

function runCommitCompositionTests()
{
  var description = "runCommitCompositionTests(): ";

  var TIP = createTIP();
  ok(TIP.beginInputTransactionForTests(window),
     description + "TIP.beginInputTransactionForTests() should succeed");

  input.focus();

  // commitComposition() should commit the composition with the last data.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  TIP.commitComposition();
  is(input.value, "foo",
     description + "commitComposition() should commit the composition with the last data");

  // commitComposition("") should commit the composition with empty string.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  TIP.commitComposition("");
  is(input.value, "",
     description + "commitComposition(\"\") should commit the composition with empty string");

  // commitComposition(null) should commit the composition with empty string.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  TIP.commitComposition(null);
  is(input.value, "",
     description + "commitComposition(null) should commit the composition with empty string");

  // commitComposition(undefined) should commit the composition with the last data.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  TIP.commitComposition(undefined);
  todo_is(input.value, "foo",
          description + "commitComposition(undefined) should commit the composition with the last data");

  function doCommit(aText)
  {
    TIP.commitComposition(aText);
  }

  // doCommit() should commit the composition with the last data.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  doCommit();
  todo_is(input.value, "foo",
          description + "doCommit() should commit the composition with the last data");

  // doCommit("") should commit the composition with empty string.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  doCommit("");
  is(input.value, "",
     description + "doCommit(\"\") should commit the composition with empty string");

  // doCommit(null) should commit the composition with empty string.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  doCommit(null);
  is(input.value, "",
     description + "doCommit(null) should commit the composition with empty string");

  // doCommit(undefined) should commit the composition with the last data.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  doCommit(undefined);
  todo_is(input.value, "foo",
          description + "doCommit(undefined) should commit the composition with the last data");

  function doCommitWithNullCheck(aText)
  {
    TIP.commitComposition(aText ? aText : "");
  }

  // doCommitWithNullCheck() should commit the composition with the last data.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  doCommitWithNullCheck();
  is(input.value, "",
     description + "doCommitWithNullCheck() should commit the composition with empty string");

  // doCommitWithNullCheck("") should commit the composition with empty string.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  doCommitWithNullCheck("");
  is(input.value, "",
     description + "doCommitWithNullCheck(\"\") should commit the composition with empty string");

  // doCommitWithNullCheck(null) should commit the composition with empty string.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  doCommitWithNullCheck(null);
  is(input.value, "",
     description + "doCommitWithNullCheck(null) should commit the composition with empty string");

  // doCommitWithNullCheck(undefined) should commit the composition with the last data.
  input.value = "";
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  doCommitWithNullCheck(undefined);
  is(input.value, "",
     description + "doCommitWithNullCheck(undefined) should commit the composition with empty string");
}

function runUnloadTests1(aNextTest)
{
  var description = "runUnloadTests1(): ";

  var TIP1 = createTIP();
  ok(TIP1.beginInputTransactionForTests(childWindow),
     description + "TIP1.beginInputTransactionForTests() should succeed");

  var oldSrc = iframe.src;
  var parentWindow = window;

  iframe.addEventListener("load", function (aEvent) {
    ok(true, description + "dummy page is loaded");
    iframe.removeEventListener("load", arguments.callee, true);
    childWindow = iframe.contentWindow;
    textareaInFrame = null;
    iframe.addEventListener("load", function () {
      ok(true, description + "old iframe is restored");
      // And also restore the iframe information with restored contents.
      iframe.removeEventListener("load", arguments.callee, true);
      childWindow = iframe.contentWindow;
      textareaInFrame = iframe.contentDocument.getElementById("textarea");
      setTimeout(aNextTest, 0);
    }, true);

    // The composition should be committed internally.  So, another TIP should
    // be able to steal the rights to using TextEventDispatcher.
    var TIP2 = createTIP();
    ok(TIP2.beginInputTransactionForTests(parentWindow),
       description + "TIP2.beginInputTransactionForTests() should succeed");

    input.focus();
    input.value = "";

    TIP2.setPendingCompositionString("foo");
    TIP2.appendClauseToPendingComposition(3, TIP2.ATTR_RAW_CLAUSE);
    TIP2.setCaretInPendingComposition(3);
    TIP2.flushPendingComposition();
    is(input.value, "foo",
       description + "the input in the parent document should have composition string");

    TIP2.cancelComposition();

    // Restore the old iframe content.
    iframe.src = oldSrc;
  }, true);

  // Start composition in the iframe.
  textareaInFrame.value = "";
  textareaInFrame.focus();

  TIP1.setPendingCompositionString("foo");
  TIP1.appendClauseToPendingComposition(3, TIP1.ATTR_RAW_CLAUSE);
  TIP1.setCaretInPendingComposition(3);
  TIP1.flushPendingComposition();
  is(textareaInFrame.value, "foo",
     description + "the textarea in the iframe should have composition string");

  // Load different web page on the frame.
  iframe.src = "data:text/html,<body>dummy page</body>";
}

function runUnloadTests2(aNextTest)
{
  var description = "runUnloadTests2(): ";

  var TIP = createTIP();
  ok(TIP.beginInputTransactionForTests(childWindow),
     description + "TIP.beginInputTransactionForTests() should succeed");

  var oldSrc = iframe.src;
  var parentWindow = window;

  iframe.addEventListener("load", function (aEvent) {
    ok(true, description + "dummy page is loaded");
    iframe.removeEventListener("load", arguments.callee, true);
    childWindow = iframe.contentWindow;
    textareaInFrame = null;
    iframe.addEventListener("load", function () {
      ok(true, description + "old iframe is restored");
      // And also restore the iframe information with restored contents.
      iframe.removeEventListener("load", arguments.callee, true);
      childWindow = iframe.contentWindow;
      textareaInFrame = iframe.contentDocument.getElementById("textarea");
      setTimeout(aNextTest, 0);
    }, true);

    input.focus();
    input.value = "";

    // TIP should be still available in the same top level widget.
    TIP.setPendingCompositionString("bar");
    TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
    TIP.setCaretInPendingComposition(3);
    TIP.flushPendingComposition();
    is(input.value, "bar",
       description + "the input in the parent document should have composition string");

    TIP.cancelComposition();

    // Restore the old iframe content.
    iframe.src = oldSrc;
  }, true);

  // Start composition in the iframe.
  textareaInFrame.value = "";
  textareaInFrame.focus();

  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.setCaretInPendingComposition(3);
  TIP.flushPendingComposition();
  is(textareaInFrame.value, "foo",
     description + "the textarea in the iframe should have composition string");

  // Load different web page on the frame.
  iframe.src = "data:text/html,<body>dummy page</body>";
}

function runCallbackTests(aForTests)
{
  var description = "runCallbackTests(aForTests=" + aForTests + "): ";

  input.value = "";
  input.focus();
  input.blur();

  var TIP = createTIP();
  var notifications = [];
  function callback(aTIP, aNotification)
  {
    switch (aNotification.type) {
      case "request-to-commit":
        aTIP.commitComposition();
        break;
      case "request-to-cancel":
        aTIP.cancelComposition();
        break;
    }
    if (aTIP == TIP) {
      notifications.push(aNotification);
    }
    return true;
  }

  function dumpUnexpectedNotifications(aExpectedCount)
  {
    if (notifications.length <= aExpectedCount) {
      return;
    }
    for (var i = aExpectedCount; i < notifications.length; i++) {
      ok(false,
         description + "Unexpected notification: " + notifications[i].type);
    }
  }

  if (aForTests) {
    TIP.beginInputTransactionForTests(window, callback);
  } else {
    TIP.beginInputTransaction(window, callback);
  }

  notifications = [];
  input.focus();
  is(notifications.length, 1,
     description + "input.focus() should cause a notification");
  is(notifications[0].type, "notify-focus",
     description + "input.focus() should cause \"notify-focus\"");
  dumpUnexpectedNotifications(1);

  notifications = [];
  input.blur();
  is(notifications.length, 1,
     description + "input.blur() should cause a notification");
  is(notifications[0].type, "notify-blur",
     description + "input.blur() should cause \"notify-focus\"");
  dumpUnexpectedNotifications(1);

  input.focus();
  TIP.setPendingCompositionString("foo");
  TIP.appendClauseToPendingComposition(3, TIP.ATTR_RAW_CLAUSE);
  TIP.flushPendingComposition();
  notifications = [];
  synthesizeMouseAtCenter(input, {});
  is(notifications.length, 1,
     description + "synthesizeMouseAtCenter(input, {}) during composition should cause a notification");
  is(notifications[0].type, "request-to-commit",
     description + "synthesizeMouseAtCenter(input, {}) during composition should cause \"request-to-commit\"");
  dumpUnexpectedNotifications(1);

  notifications = [];
  var TIP2 = createTIP();
  if (aForTests) {
    TIP2.beginInputTransactionForTests(window, callback);
  } else {
    TIP2.beginInputTransaction(window, callback);
  }
  is(notifications.length, 1,
     description + "Initializing another TIP should cause a notification");
  is(notifications[0].type, "notify-end-input-transaction",
     description + "Initializing another TIP should cause \"notify-detached\"");
  dumpUnexpectedNotifications(1);
}

function runTests()
{
  textareaInFrame = iframe.contentDocument.getElementById("textarea");

  runBeginInputTransactionMethodTests();
  runReleaseTests();
  runCompositionTests();
  runKeyTests();
  runErrorTests();
  runCommitCompositionTests();
  runCallbackTests(false);
  runCallbackTests(true);
  runUnloadTests1(function () {
    runUnloadTests2(function () {
      finish();
    });
  });
}

]]>
</script>

</window>
