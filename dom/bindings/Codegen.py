





import operator
import os
import re
import string
import math
import itertools

from WebIDL import BuiltinTypes, IDLBuiltinType, IDLNullValue, IDLSequenceType, IDLType
from Configuration import NoSuchDescriptorError, getTypesFromDescriptor, getTypesFromDictionary, getTypesFromCallback, Descriptor

AUTOGENERATED_WARNING_COMMENT = \
    "/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */\n\n"
ADDPROPERTY_HOOK_NAME = '_addProperty'
FINALIZE_HOOK_NAME = '_finalize'
TRACE_HOOK_NAME = '_trace'
CONSTRUCT_HOOK_NAME = '_constructor'
LEGACYCALLER_HOOK_NAME = '_legacycaller'
HASINSTANCE_HOOK_NAME = '_hasInstance'
NEWRESOLVE_HOOK_NAME = '_newResolve'
ENUMERATE_HOOK_NAME= '_enumerate'
ENUM_ENTRY_VARIABLE_NAME = 'strings'

def replaceFileIfChanged(filename, newContents):
    """
    Read a copy of the old file, so that we don't touch it if it hasn't changed.
    Returns True if the file was updated, false otherwise.
    """
    oldFileContents = ""
    try:
        oldFile = open(filename, 'rb')
        oldFileContents = ''.join(oldFile.readlines())
        oldFile.close()
    except:
        pass

    if newContents == oldFileContents:
        return False

    f = open(filename, 'wb')
    f.write(newContents)
    f.close()
    return True

def toStringBool(arg):
    return str(not not arg).lower()

def toBindingNamespace(arg):
    return re.sub("((_workers)?$)", "Binding\\1", arg);

class CGThing():
    """
    Abstract base class for things that spit out code.
    """
    def __init__(self):
        pass 
    def declare(self):
        """Produce code for a header file."""
        assert(False)  
    def define(self):
        """Produce code for a cpp file."""
        assert(False) 
    def deps(self):
        """Produce the deps for a pp file"""
        assert(False) 

class CGNativePropertyHooks(CGThing):
    """
    Generate a NativePropertyHooks for a given descriptor
    """
    def __init__(self, descriptor, properties):
        CGThing.__init__(self)
        self.descriptor = descriptor
        self.properties = properties
    def declare(self):
        if self.descriptor.workers:
            return ""
        return """// We declare this as an array so that retrieving a pointer to this
// binding's property hooks only requires compile/link-time resolvable
// address arithmetic.  Declaring it as a pointer instead would require
// doing a run-time load to fetch a pointer to this binding's property
// hooks.  And then structures which embedded a pointer to this structure
// would require a run-time load for proper initialization, which would
// then induce static constructors.  Lots of static constructors.
extern const NativePropertyHooks sNativePropertyHooks[];"""
    def define(self):
        if self.descriptor.workers:
            return ""
        if self.descriptor.concrete and self.descriptor.proxy:
            resolveOwnProperty = "ResolveOwnProperty"
            enumerateOwnProperties = "EnumerateOwnProperties"
        elif self.descriptor.interface.getExtendedAttribute("NeedNewResolve"):
            resolveOwnProperty = "ResolveOwnPropertyViaNewresolve"
            enumerateOwnProperties = "EnumerateOwnPropertiesViaGetOwnPropertyNames"
        else:
            resolveOwnProperty = "nullptr"
            enumerateOwnProperties = "nullptr"
        if self.properties.hasNonChromeOnly():
            regular = "&sNativeProperties"
        else:
            regular = "nullptr"
        if self.properties.hasChromeOnly():
            chrome = "&sChromeOnlyNativeProperties"
        else:
            chrome = "nullptr"
        constructorID = "constructors::id::"
        if self.descriptor.interface.hasInterfaceObject():
            constructorID += self.descriptor.name
        else:
            constructorID += "_ID_Count"
        prototypeID = "prototypes::id::"
        if self.descriptor.interface.hasInterfacePrototypeObject():
            prototypeID += self.descriptor.name
        else:
            prototypeID += "_ID_Count"
        parent = self.descriptor.interface.parent
        parentHooks = (toBindingNamespace(parent.identifier.name) + "::sNativePropertyHooks"
                       if parent else 'nullptr')

        return CGWrapper(CGIndenter(CGList([CGGeneric(resolveOwnProperty),
                                            CGGeneric(enumerateOwnProperties),
                                            CGWrapper(CGList([CGGeneric(regular),
                                                              CGGeneric(chrome)],
                                                             ", "),
                                                      pre="{ ", post=" }"),
                                            CGGeneric(prototypeID),
                                            CGGeneric(constructorID),
                                            CGGeneric(parentHooks)],
                                           ",\n")),
                         pre="const NativePropertyHooks sNativePropertyHooks[] = { {\n",
                         post=("\n"
                               "} };\n")).define()

def NativePropertyHooks(descriptor):
    return "&sWorkerNativePropertyHooks" if descriptor.workers else "sNativePropertyHooks"

def DOMClass(descriptor):
        protoList = ['prototypes::id::' + proto for proto in descriptor.prototypeChain]
        
        
        
        
        protoList.extend(['prototypes::id::_ID_Count'] * (descriptor.config.maxProtoChainLength - len(protoList)))
        prototypeChainString = ', '.join(protoList)
        if descriptor.workers:
            participant = "nullptr"
        else:
            participant = "GetCCParticipant<%s>::Get()" % descriptor.nativeType
        getParentObject = "GetParentObject<%s>::Get" % descriptor.nativeType
        return """{
  { %s },
  IsBaseOf<nsISupports, %s >::value,
  %s,
  %s,
  GetProtoObject,
  %s
}""" % (prototypeChainString, descriptor.nativeType,
        NativePropertyHooks(descriptor),
        getParentObject,
        participant)

class CGDOMJSClass(CGThing):
    """
    Generate a DOMJSClass for a given descriptor
    """
    def __init__(self, descriptor):
        CGThing.__init__(self)
        self.descriptor = descriptor
        
        assert "Window" not in descriptor.interface.identifier.name
    def declare(self):
        return ""
    def define(self):
        traceHook = TRACE_HOOK_NAME if self.descriptor.customTrace else 'nullptr'
        callHook = LEGACYCALLER_HOOK_NAME if self.descriptor.operations["LegacyCaller"] else 'nullptr'
        classFlags = "JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(3)"
        if self.descriptor.interface.getExtendedAttribute("NeedNewResolve"):
            newResolveHook = "(JSResolveOp)" + NEWRESOLVE_HOOK_NAME
            classFlags += " | JSCLASS_NEW_RESOLVE"
            enumerateHook = ENUMERATE_HOOK_NAME
        else:
            newResolveHook = "JS_ResolveStub"
            enumerateHook = "JS_EnumerateStub"
        return """
static DOMJSClass Class = {
  { "%s",
    %s,
    %s, /* addProperty */
    JS_DeletePropertyStub, /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    %s, /* enumerate */
    %s, /* resolve */
    JS_ConvertStub,
    %s, /* finalize */
    nullptr,               /* checkAccess */
    %s, /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    %s, /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
%s
};
""" % (self.descriptor.interface.identifier.name,
       classFlags,
       ADDPROPERTY_HOOK_NAME if self.descriptor.concrete and not self.descriptor.workers and self.descriptor.wrapperCache else 'JS_PropertyStub',
       enumerateHook, newResolveHook, FINALIZE_HOOK_NAME, callHook, traceHook,
       CGIndenter(CGGeneric(DOMClass(self.descriptor))).define())

def PrototypeIDAndDepth(descriptor):
    prototypeID = "prototypes::id::"
    if descriptor.interface.hasInterfacePrototypeObject():
        prototypeID += descriptor.interface.identifier.name
        if descriptor.workers:
            prototypeID += "_workers"
        depth = "PrototypeTraits<%s>::Depth" % prototypeID
    else:
        prototypeID += "_ID_Count"
        depth = "0"
    return (prototypeID, depth)

def UseHolderForUnforgeable(descriptor):
    return (descriptor.concrete and
            descriptor.proxy and
            any(m for m in descriptor.interface.members if m.isAttr() and m.isUnforgeable()))

def CallOnUnforgeableHolder(descriptor, code, isXrayCheck=None):
    """
    Generate the code to execute the code in "code" on an unforgeable holder if
    needed. code should be a string containing the code to execute. If it
    contains a ${holder} string parameter it will be replaced with the
    unforgeable holder object.

    If isXrayCheck is not None it should be a string that contains a statement
    returning whether proxy is an Xray. If isXrayCheck is None the generated
    code won't try to unwrap Xrays.
    """
    code = string.Template(code).substitute({ "holder": "unforgeableHolder" })
    if not isXrayCheck is None:
        pre = """// Scope for 'global', 'ac' and 'unforgeableHolder'
{
  JS::Rooted<JSObject*> global(cx);
  Maybe<JSAutoCompartment> ac;
  if (""" + isXrayCheck + """) {
    global = js::GetGlobalForObjectCrossCompartment(js::UncheckedUnwrap(proxy));
    ac.construct(cx, global);
  } else {
    global = js::GetGlobalForObjectCrossCompartment(proxy);
  }"""
    else:
        pre = """// Scope for 'global' and 'unforgeableHolder'
{
  JSObject* global = js::GetGlobalForObjectCrossCompartment(proxy);"""

    return (pre + """
  JS::Rooted<JSObject*> unforgeableHolder(cx, GetUnforgeableHolder(global, prototypes::id::%s));
""" + CGIndenter(CGGeneric(code)).define() + """
}
""") % descriptor.name

class CGPrototypeJSClass(CGThing):
    def __init__(self, descriptor, properties):
        CGThing.__init__(self)
        self.descriptor = descriptor
        self.properties = properties
    def declare(self):
        
        return ""
    def define(self):
        (prototypeID, depth) = PrototypeIDAndDepth(self.descriptor)
        slotCount = "DOM_INTERFACE_PROTO_SLOTS_BASE"
        if UseHolderForUnforgeable(self.descriptor):
            slotCount += " + 1 /* slot for the JSObject holding the unforgeable properties */"
        return """static DOMIfaceAndProtoJSClass PrototypeClass = {
  {
    "%sPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(%s),
    JS_PropertyStub,       /* addProperty */
    JS_DeletePropertyStub, /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    nullptr,               /* call */
    nullptr,               /* hasInstance */
    nullptr,               /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterfacePrototype,
  %s,
  "[object %sPrototype]",
  %s,
  %s
};
""" % (self.descriptor.interface.identifier.name, slotCount,
       NativePropertyHooks(self.descriptor),
       self.descriptor.interface.identifier.name,
       prototypeID, depth)

def NeedsGeneratedHasInstance(descriptor):
    return descriptor.hasXPConnectImpls or descriptor.interface.isConsequential()

class CGInterfaceObjectJSClass(CGThing):
    def __init__(self, descriptor, properties):
        CGThing.__init__(self)
        self.descriptor = descriptor
        self.properties = properties
    def declare(self):
        
        return ""
    def define(self):
        if self.descriptor.interface.ctor():
            ctorname = CONSTRUCT_HOOK_NAME
        else:
            ctorname = "ThrowingConstructor"
        if NeedsGeneratedHasInstance(self.descriptor):
            hasinstance = HASINSTANCE_HOOK_NAME
        elif self.descriptor.interface.hasInterfacePrototypeObject():
            hasinstance = "InterfaceHasInstance"
        else:
            hasinstance = "nullptr"
        (prototypeID, depth) = PrototypeIDAndDepth(self.descriptor)
        slotCount = "DOM_INTERFACE_SLOTS_BASE"
        if len(self.descriptor.interface.namedConstructors) > 0:
            slotCount += (" + %i /* slots for the named constructors */" %
                          len(self.descriptor.interface.namedConstructors))
        return """
static DOMIfaceAndProtoJSClass InterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(%s),
    JS_PropertyStub,       /* addProperty */
    JS_DeletePropertyStub, /* delProperty */
    JS_PropertyStub,       /* getProperty */
    JS_StrictPropertyStub, /* setProperty */
    JS_EnumerateStub,
    JS_ResolveStub,
    JS_ConvertStub,
    nullptr,               /* finalize */
    nullptr,               /* checkAccess */
    %s, /* call */
    %s, /* hasInstance */
    %s, /* construct */
    nullptr,               /* trace */
    JSCLASS_NO_INTERNAL_MEMBERS
  },
  eInterface,
  %s,
  "function %s() {\\n    [native code]\\n}",
  %s,
  %s
};
""" % (slotCount, ctorname,
       hasinstance, ctorname, NativePropertyHooks(self.descriptor),
       self.descriptor.interface.identifier.name,
       prototypeID, depth)

class CGList(CGThing):
    """
    Generate code for a list of GCThings.  Just concatenates them together, with
    an optional joiner string.  "\n" is a common joiner.
    """
    def __init__(self, children, joiner=""):
        CGThing.__init__(self)
        
        
        
        self.children = list(children)
        self.joiner = joiner
    def append(self, child):
        self.children.append(child)
    def prepend(self, child):
        self.children.insert(0, child)
    def join(self, generator):
        return self.joiner.join(filter(lambda s: len(s) > 0, (child for child in generator)))
    def declare(self):
        return self.join(child.declare() for child in self.children if child is not None)
    def define(self):
        return self.join(child.define() for child in self.children if child is not None)
    def deps(self):
        deps = set()
        for child in self.children:
            if child is None:
                continue
            deps = deps.union(child.deps())
        return deps

class CGGeneric(CGThing):
    """
    A class that spits out a fixed string into the codegen.  Can spit out a
    separate string for the declaration too.
    """
    def __init__(self, define="", declare=""):
        self.declareText = declare
        self.defineText = define
    def declare(self):
        return self.declareText
    def define(self):
        return self.defineText
    def deps(self):
        return set()




lineStartDetector = re.compile("^(?=[^\n#])", re.MULTILINE)
class CGIndenter(CGThing):
    """
    A class that takes another CGThing and generates code that indents that
    CGThing by some number of spaces.  The default indent is two spaces.
    """
    def __init__(self, child, indentLevel=2, declareOnly=False):
        CGThing.__init__(self)
        self.child = child
        self.indent = " " * indentLevel
        self.declareOnly = declareOnly
    def declare(self):
        decl = self.child.declare()
        if decl is not "":
            return re.sub(lineStartDetector, self.indent, decl)
        else:
            return ""
    def define(self):
        defn = self.child.define()
        if defn is not "" and not self.declareOnly:
            return re.sub(lineStartDetector, self.indent, defn)
        else:
            return defn

class CGWrapper(CGThing):
    """
    Generic CGThing that wraps other CGThings with pre and post text.
    """
    def __init__(self, child, pre="", post="", declarePre=None,
                 declarePost=None, definePre=None, definePost=None,
                 declareOnly=False, defineOnly=False, reindent=False):
        CGThing.__init__(self)
        self.child = child
        self.declarePre = declarePre or pre
        self.declarePost = declarePost or post
        self.definePre = definePre or pre
        self.definePost = definePost or post
        self.declareOnly = declareOnly
        self.defineOnly = defineOnly
        self.reindent = reindent
    def declare(self):
        if self.defineOnly:
            return ''
        decl = self.child.declare()
        if self.reindent:
            
            
            decl = stripTrailingWhitespace(
                decl.replace("\n", "\n" + (" " * len(self.declarePre))))
        return self.declarePre + decl + self.declarePost
    def define(self):
        if self.declareOnly:
            return ''
        defn = self.child.define()
        if self.reindent:
            
            
            defn = stripTrailingWhitespace(
                defn.replace("\n", "\n" + (" " * len(self.definePre))))
        return self.definePre + defn + self.definePost

    def deps(self):
        return self.child.deps()

class CGIfWrapper(CGWrapper):
    def __init__(self, child, condition):
        pre = CGWrapper(CGGeneric(condition), pre="if (", post=") {\n",
                        reindent=True)
        CGWrapper.__init__(self, CGIndenter(child), pre=pre.define(),
                           post="\n}")

class CGIfElseWrapper(CGList):
    def __init__(self, condition, ifTrue, ifFalse):
        kids = [ CGIfWrapper(ifTrue, condition),
                 CGWrapper(CGIndenter(ifFalse), pre=" else {\n", post="\n}") ]
        CGList.__init__(self, kids)

class CGTemplatedType(CGWrapper):
    def __init__(self, templateName, child, isConst=False, isReference=False):
        const = "const " if isConst else ""
        pre = "%s%s<" % (const, templateName)
        ref = "&" if isReference else ""
        post = " >%s" % ref
        CGWrapper.__init__(self, child, pre=pre, post=post)

class CGNamespace(CGWrapper):
    def __init__(self, namespace, child, declareOnly=False):
        pre = "namespace %s {\n" % namespace
        post = "} // namespace %s\n" % namespace
        CGWrapper.__init__(self, child, pre=pre, post=post,
                           declareOnly=declareOnly)
    @staticmethod
    def build(namespaces, child, declareOnly=False):
        """
        Static helper method to build multiple wrapped namespaces.
        """
        if not namespaces:
            return CGWrapper(child, declareOnly=declareOnly)
        inner = CGNamespace.build(namespaces[1:], child, declareOnly=declareOnly)
        return CGNamespace(namespaces[0], inner, declareOnly=declareOnly)

class CGIncludeGuard(CGWrapper):
    """
    Generates include guards for a header.
    """
    def __init__(self, prefix, child):
        """|prefix| is the filename without the extension."""
        define = 'mozilla_dom_%s_h__' % prefix
        CGWrapper.__init__(self, child,
                           declarePre='#ifndef %s\n#define %s\n\n' % (define, define),
                           declarePost='\n#endif // %s\n' % define)

def getRelevantProviders(descriptor, dictionary, config):
    assert not descriptor or not dictionary
    if descriptor is not None:
        return [descriptor]
    if dictionary is not None:
        
        return [
            config.getDescriptorProvider(False),
            config.getDescriptorProvider(True)
            ]
    
    return [ config.getDescriptorProvider(False) ]


def getAllTypes(descriptors, dictionaries, callbacks):
    """
    Generate all the types we're dealing with.  For each type, a tuple
    containing type, descriptor, dictionary is yielded.  The
    descriptor and dictionary can be None if the type does not come
    from a descriptor or dictionary; they will never both be non-None.
    """
    for d in descriptors:
        if d.interface.isExternal():
            continue
        for t in getTypesFromDescriptor(d):
            yield (t, d, None)
    for dictionary in dictionaries:
        for t in getTypesFromDictionary(dictionary):
            yield (t, None, dictionary)
    for callback in callbacks:
        for t in getTypesFromCallback(callback):
            yield (t, None, None)

class CGHeaders(CGWrapper):
    """
    Generates the appropriate include statements.
    """
    def __init__(self, descriptors, dictionaries, callbacks,
                 callbackDescriptors,
                 declareIncludes, defineIncludes, prefix, child,
                 config=None, jsImplementedDescriptors=[]):
        """
        Builds a set of includes to cover |descriptors|.

        Also includes the files in |declareIncludes| in the header
        file and the files in |defineIncludes| in the .cpp.

        |prefix| contains the basename of the file that we generate include
        statements for.
        """

        
        interfaceDeps = [d.interface for d in descriptors]
        ancestors = []
        for iface in interfaceDeps:
            if iface.parent:
                
                
                ancestors.append(iface.parent)
                
                
                
                if iface.hasInterfaceObject():
                    parent = iface.parent
                    while parent and not parent.hasInterfaceObject():
                        parent = parent.parent
                    if parent:
                        ancestors.append(parent)
        interfaceDeps.extend(ancestors)
        bindingIncludes = set(self.getDeclarationFilename(d) for d in interfaceDeps)

        
        implementationIncludes = set(d.headerFile for d in descriptors if d.needsHeaderInclude())

        
        interfacesImplementingSelf = set()
        for d in descriptors:
            interfacesImplementingSelf |= d.interface.interfacesImplementingSelf
        implementationIncludes |= set(self.getDeclarationFilename(i) for i in
                                      interfacesImplementingSelf)

         
        hasInstanceIncludes = set("nsIDOM" + d.interface.identifier.name + ".h" for d
                                  in descriptors if
                                  NeedsGeneratedHasInstance(d) and
                                  d.interface.hasInterfacePrototypeObject())

        
        
        bindingHeaders = set()
        declareIncludes = set(declareIncludes)
        def addHeadersForType((t, descriptor, dictionary)):
            """
            Add the relevant headers for this type.  We use descriptor and
            dictionary, if passed, to decide what to do with interface types.
            """
            assert not descriptor or not dictionary
            if t.nullable():
                if dictionary:
                    
                    
                    declareIncludes.add("mozilla/dom/Nullable.h")
                else:
                    bindingHeaders.add("mozilla/dom/Nullable.h")
            unrolled = t.unroll()
            if unrolled.isUnion():
                
                bindingHeaders.add("mozilla/dom/UnionConversions.h")
            elif unrolled.isDate():
                if dictionary or jsImplementedDescriptors:
                    headerSet = declareIncludes
                else:
                    headerSet = bindingHeaders
                headerSet.add("mozilla/dom/Date.h")
            elif unrolled.isInterface():
                if unrolled.isSpiderMonkeyInterface():
                    bindingHeaders.add("jsfriendapi.h")
                    if dictionary:
                        headerSet = declareIncludes
                    else:
                        headerSet = bindingHeaders
                    headerSet.add("mozilla/dom/TypedArray.h")
                else:
                    providers = getRelevantProviders(descriptor, dictionary,
                                                     config)
                    for p in providers:
                        try:
                            typeDesc = p.getDescriptor(unrolled.inner.identifier.name)
                        except NoSuchDescriptorError:
                            continue
                        if dictionary:
                            
                            
                            
                            
                            
                            
                            
                            
                            
                            declareIncludes.add(typeDesc.headerFile)
                        else:
                            implementationIncludes.add(typeDesc.headerFile)
            elif unrolled.isDictionary():
                bindingHeaders.add(self.getDeclarationFilename(unrolled.inner))
            elif unrolled.isCallback():
                
                bindingHeaders.add(self.getDeclarationFilename(t.unroll()))
            elif unrolled.isFloat() and not unrolled.isUnrestricted():
                
                bindingHeaders.add("mozilla/FloatingPoint.h")
                bindingHeaders.add("mozilla/dom/PrimitiveConversions.h")
            elif unrolled.isEnum():
                filename = self.getDeclarationFilename(unrolled.inner)
                
                
                if filename != prefix + ".h":
                    declareIncludes.add(filename)
            elif unrolled.isPrimitive():
                bindingHeaders.add("mozilla/dom/PrimitiveConversions.h")

        map(addHeadersForType,
            getAllTypes(descriptors + callbackDescriptors, dictionaries,
                        callbacks))

        
        
        for desc in descriptors:
            if desc.interface.isExternal():
                continue
            def addHeaderForFunc(func):
                
                
                if func is not None and "::" in func:
                    
                    bindingHeaders.add("/".join(func.split("::")[:-1]) + ".h")
            for m in desc.interface.members:
                addHeaderForFunc(PropertyDefiner.getStringAttr(m, "Func"))
            
            funcList = desc.interface.getExtendedAttribute("Func")
            if funcList is not None:
                addHeaderForFunc(funcList[0])

        for d in dictionaries:
            if d.parent:
                declareIncludes.add(self.getDeclarationFilename(d.parent))
            bindingHeaders.add(self.getDeclarationFilename(d))

        for c in callbacks:
            bindingHeaders.add(self.getDeclarationFilename(c))

        for c in callbackDescriptors:
            bindingHeaders.add(self.getDeclarationFilename(c.interface))

        if len(callbacks) != 0:
            
            declareIncludes.add("mozilla/dom/CallbackFunction.h")
            
            declareIncludes.add("mozilla/dom/BindingUtils.h")

        if len(callbackDescriptors) != 0 or len(jsImplementedDescriptors) != 0:
            
            declareIncludes.add("mozilla/dom/CallbackInterface.h")
            
            declareIncludes.add("mozilla/dom/BindingUtils.h")

        
        
        for jsImplemented in jsImplementedDescriptors:
            jsParent = jsImplemented.interface.parent
            if jsParent:
                parentDesc = jsImplemented.getDescriptor(jsParent.identifier.name)
                declareIncludes.add(parentDesc.jsImplParentHeader)

        if len(jsImplementedDescriptors) != 0:
            bindingHeaders.add("nsIDOMGlobalPropertyInitializer.h")

        
        def _includeString(includes):
            return ''.join(['#include "%s"\n' % i for i in includes]) + '\n'
        CGWrapper.__init__(self, child,
                           declarePre=_includeString(sorted(declareIncludes)),
                           definePre=_includeString(sorted(set(defineIncludes) |
                                                           bindingIncludes |
                                                           bindingHeaders |
                                                           hasInstanceIncludes |
                                                           implementationIncludes)))
    @staticmethod
    def getDeclarationFilename(decl):
        
        
        basename = os.path.basename(decl.filename())
        return basename.replace('.webidl', 'Binding.h')

def SortedTuples(l):
    """
    Sort a list of tuples based on the first item in the tuple
    """
    return sorted(l, key=operator.itemgetter(0))

def SortedDictValues(d):
    """
    Returns a list of values from the dict sorted by key.
    """
    
    d = SortedTuples(d.items())
    
    return (i[1] for i in d)

def UnionTypes(descriptors, dictionaries, callbacks, config):
    """
    Returns a tuple containing a set of header filenames to include in
    UnionTypes.h, a set of header filenames to include in UnionTypes.cpp, a set
    of tuples containing a type declaration and a boolean if the type is a
    struct for member types of the unions and a CGList containing CGUnionStructs
    for every union.
    """

    
    
    headers = set()
    implheaders = set(["UnionTypes.h"])
    declarations = set()
    unionStructs = dict()
    unionReturnValues = dict()

    def addInfoForType((t, descriptor, dictionary)):
        """
        Add info for the given type.  descriptor and dictionary, if passed, are
        used to figure out what to do with interface types.
        """
        assert not descriptor or not dictionary
        t = t.unroll()
        if not t.isUnion():
            return
        name = str(t)
        if not name in unionStructs:
            providers = getRelevantProviders(descriptor, dictionary,
                                             config)
            
            unionStructs[name] = CGUnionStruct(t, providers[0])
            
            if not any(member.isObject() or member.isSpiderMonkeyInterface() for member in t.flatMemberTypes):
                unionReturnValues[name] = CGUnionStruct(t,
                                                        providers[0],
                                                        isReturnValue=True)

            for f in t.flatMemberTypes:
                f = f.unroll()
                if f.nullable():
                    headers.add("mozilla/dom/Nullable.h")
                if f.isInterface():
                    if f.isSpiderMonkeyInterface():
                        headers.add("jsfriendapi.h")
                        headers.add("mozilla/dom/TypedArray.h")
                    else:
                        for p in providers:
                            try:
                                typeDesc = p.getDescriptor(f.inner.identifier.name)
                            except NoSuchDescriptorError:
                                continue
                            declarations.add((typeDesc.nativeType, False))
                            implheaders.add(typeDesc.headerFile)
                elif f.isDictionary():
                    declarations.add((f.inner.identifier.name, True))
                    implheaders.add(CGHeaders.getDeclarationFilename(f.inner))
                elif t.isPrimitive():
                    implheaders.add("mozilla/dom/PrimitiveConversions.h")

    map(addInfoForType, getAllTypes(descriptors, dictionaries, callbacks))

    return (headers, implheaders, declarations,
            CGList(itertools.chain(SortedDictValues(unionStructs),
                                   SortedDictValues(unionReturnValues)), "\n"))

def UnionConversions(descriptors, dictionaries, callbacks, config):
    """
    Returns a CGThing to declare all union argument conversion helper structs.
    """
    
    
    headers = set()
    unionConversions = dict()

    def addInfoForType((t, descriptor, dictionary)):
        """
        Add info for the given type.  descriptor and dictionary, if passed, are
        used to figure out what to do with interface types.
        """
        assert not descriptor or not dictionary
        t = t.unroll()
        if not t.isUnion():
            return
        name = str(t)
        if not name in unionConversions:
            providers = getRelevantProviders(descriptor, dictionary,
                                             config)
            unionConversions[name] = CGUnionConversionStruct(t, providers[0])
            for f in t.flatMemberTypes:
                f = f.unroll()
                if f.isInterface():
                    if f.isSpiderMonkeyInterface():
                        headers.add("jsfriendapi.h")
                        headers.add("mozilla/dom/TypedArray.h")
                    elif not f.inner.isExternal():
                        headers.add(CGHeaders.getDeclarationFilename(f.inner))
                    
                    
                    
                    
                    if (f.isGeckoInterface() and
                        providers[0].getDescriptor(f.inner.identifier.name).hasXPConnectImpls):
                        headers.add("nsDOMQS.h")
                elif f.isDictionary():
                    headers.add(CGHeaders.getDeclarationFilename(f.inner))
                elif f.isPrimitive():
                    headers.add("mozilla/dom/PrimitiveConversions.h")

    map(addInfoForType, getAllTypes(descriptors, dictionaries, callbacks))

    return (headers,
            CGWrapper(CGList(SortedDictValues(unionConversions), "\n"),
                      post="\n\n"))

class Argument():
    """
    A class for outputting the type and name of an argument
    """
    def __init__(self, argType, name, default=None):
        self.argType = argType
        self.name = name
        self.default = default
    def declare(self):
        string = self.argType + ' ' + self.name
        if self.default is not None:
            string += " = " + self.default
        return string
    def define(self):
        return self.argType + ' ' + self.name

class CGAbstractMethod(CGThing):
    """
    An abstract class for generating code for a method.  Subclasses
    should override definition_body to create the actual code.

    descriptor is the descriptor for the interface the method is associated with

    name is the name of the method as a string

    returnType is the IDLType of the return value

    args is a list of Argument objects

    inline should be True to generate an inline method, whose body is
    part of the declaration.

    alwaysInline should be True to generate an inline method annotated with
    MOZ_ALWAYS_INLINE.

    static should be True to generate a static method, which only has
    a definition.

    If templateArgs is not None it should be a list of strings containing
    template arguments, and the function will be templatized using those
    arguments.
    """
    def __init__(self, descriptor, name, returnType, args, inline=False, alwaysInline=False, static=False, templateArgs=None):
        CGThing.__init__(self)
        self.descriptor = descriptor
        self.name = name
        self.returnType = returnType
        self.args = args
        self.inline = inline
        self.alwaysInline = alwaysInline
        self.static = static
        self.templateArgs = templateArgs
    def _argstring(self, declare):
        return ', '.join([a.declare() if declare else a.define() for a in self.args])
    def _template(self):
        if self.templateArgs is None:
            return ''
        return 'template <%s>\n' % ', '.join(self.templateArgs)
    def _decorators(self):
        decorators = []
        if self.alwaysInline:
            decorators.append('MOZ_ALWAYS_INLINE')
        elif self.inline:
            decorators.append('inline')
        if self.static:
            decorators.append('static')
        decorators.append(self.returnType)
        maybeNewline = " " if self.inline else "\n"
        return ' '.join(decorators) + maybeNewline
    def declare(self):
        if self.inline:
            return self._define(True)
        return "%s%s%s(%s);\n" % (self._template(), self._decorators(), self.name, self._argstring(True))
    def _define(self, fromDeclare=False):
        return self.definition_prologue(fromDeclare) + "\n" + self.definition_body() + self.definition_epilogue()
    def define(self):
        return "" if self.inline else self._define()
    def definition_prologue(self, fromDeclare):
        return "%s%s%s(%s)\n{" % (self._template(), self._decorators(),
                                  self.name, self._argstring(fromDeclare))
    def definition_epilogue(self):
        return "\n}\n"
    def definition_body(self):
        assert(False) 

class CGAbstractStaticMethod(CGAbstractMethod):
    """
    Abstract base class for codegen of implementation-only (no
    declaration) static methods.
    """
    def __init__(self, descriptor, name, returnType, args):
        CGAbstractMethod.__init__(self, descriptor, name, returnType, args,
                                  inline=False, static=True)
    def declare(self):
        
        return ""

class CGAbstractClassHook(CGAbstractStaticMethod):
    """
    Meant for implementing JSClass hooks, like Finalize or Trace. Does very raw
    'this' unwrapping as it assumes that the unwrapped type is always known.
    """
    def __init__(self, descriptor, name, returnType, args):
        CGAbstractStaticMethod.__init__(self, descriptor, name, returnType,
                                        args)

    def definition_body_prologue(self):
        return """
  %s* self = UnwrapDOMObject<%s>(obj);
""" % (self.descriptor.nativeType, self.descriptor.nativeType)

    def definition_body(self):
        return self.definition_body_prologue() + self.generate_code()

    def generate_code(self):
        
        assert(False)

class CGGetJSClassMethod(CGAbstractMethod):
    def __init__(self, descriptor):
        CGAbstractMethod.__init__(self, descriptor, 'GetJSClass', 'JSClass*',
                                  [])

    def definition_body(self):
        return "  return Class.ToJSClass();"

class CGAddPropertyHook(CGAbstractClassHook):
    """
    A hook for addProperty, used to preserve our wrapper from GC.
    """
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'), Argument('JS::Handle<JSObject*>', 'obj'),
                Argument('JS::Handle<jsid>', 'id'), Argument('JS::MutableHandle<JS::Value>', 'vp')]
        CGAbstractClassHook.__init__(self, descriptor, ADDPROPERTY_HOOK_NAME,
                                     'bool', args)

    def generate_code(self):
        assert not self.descriptor.workers and self.descriptor.wrapperCache
        return ("  // We don't want to preserve if we don't have a wrapper.\n"
                "  if (self->GetWrapperPreserveColor()) {\n"
                "    PreserveWrapper(self);\n"
                "  }\n"
                "  return true;")

def DeferredFinalizeSmartPtr(descriptor):
    if descriptor.nativeOwnership == 'owned':
        smartPtr = 'nsAutoPtr'
    else:
        smartPtr = 'nsRefPtr'
    return smartPtr

def finalizeHook(descriptor, hookName, context):
    if descriptor.customFinalize:
        finalize = "self->%s(%s);" % (hookName, context)
    else:
        finalize = "JSBindingFinalized<%s>::Finalized(self);\n" % descriptor.nativeType
        if descriptor.wrapperCache:
            finalize += "ClearWrapper(self, self);\n"
        if descriptor.interface.getExtendedAttribute('OverrideBuiltins'):
            finalize += "self->mExpandoAndGeneration.expando = JS::UndefinedValue();\n"
        if descriptor.workers:
            finalize += "self->Release();"
        else:
            finalize += ("AddForDeferredFinalization<%s, %s >(self);" %
                (descriptor.nativeType, DeferredFinalizeSmartPtr(descriptor)))
    return CGIfWrapper(CGGeneric(finalize), "self")

class CGClassFinalizeHook(CGAbstractClassHook):
    """
    A hook for finalize, used to release our native object.
    """
    def __init__(self, descriptor):
        args = [Argument('JSFreeOp*', 'fop'), Argument('JSObject*', 'obj')]
        CGAbstractClassHook.__init__(self, descriptor, FINALIZE_HOOK_NAME,
                                     'void', args)

    def generate_code(self):
        return CGIndenter(finalizeHook(self.descriptor, self.name, self.args[0].name)).define()

class CGClassTraceHook(CGAbstractClassHook):
    """
    A hook to trace through our native object; used for GC and CC
    """
    def __init__(self, descriptor):
        args = [Argument('JSTracer*', 'trc'), Argument('JSObject*', 'obj')]
        CGAbstractClassHook.__init__(self, descriptor, TRACE_HOOK_NAME, 'void',
                                     args)

    def generate_code(self):
        return """  if (self) {
    self->%s(%s);
  }""" % (self.name, self.args[0].name)

class CGClassConstructor(CGAbstractStaticMethod):
    """
    JS-visible constructor for our objects
    """
    def __init__(self, descriptor, ctor, name=CONSTRUCT_HOOK_NAME):
        args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'), Argument('JS::Value*', 'vp')]
        CGAbstractStaticMethod.__init__(self, descriptor, name, 'bool', args)
        self._ctor = ctor

    def define(self):
        if not self._ctor:
            return ""
        return CGAbstractStaticMethod.define(self)

    def definition_body(self):
        return self.generate_code()

    def generate_code(self):
        preamble = """
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
"""
        name = self._ctor.identifier.name
        nativeName = MakeNativeName(self.descriptor.binaryNames.get(name, name))
        callGenerator = CGMethodCall(nativeName, True, self.descriptor,
                                     self._ctor, isConstructor=True)
        return preamble + callGenerator.define();


class CGConstructNavigatorObjectHelper(CGAbstractStaticMethod):
    """
    Construct a new JS-implemented WebIDL DOM object, for use on navigator.
    """
    def __init__(self, descriptor):
        name = "ConstructNavigatorObjectHelper"
        args = [Argument('JSContext*', 'cx'),
                Argument('GlobalObject&', 'global'),
                Argument('ErrorResult&', 'aRv')]
        rtype = 'already_AddRefed<%s>' % descriptor.name
        CGAbstractStaticMethod.__init__(self, descriptor, name, rtype, args)

    def definition_body(self):
        return CGIndenter(CGGeneric(genConstructorBody(self.descriptor))).define()

class CGConstructNavigatorObject(CGAbstractMethod):
    """
    Wrap a JS-implemented WebIDL object into a JS value, for use on navigator.
    """
    def __init__(self, descriptor):
        name = 'ConstructNavigatorObject'
        args = [Argument('JSContext*', 'aCx'), Argument('JS::Handle<JSObject*>', 'aObj')]
        CGAbstractMethod.__init__(self, descriptor, name, 'JSObject*', args)

    def definition_body(self):
        if not self.descriptor.interface.isJSImplemented():
            raise TypeError("Only JS-implemented classes are currently supported "
                            "on navigator. See bug 856820.")
        return string.Template("""  GlobalObject global(aCx, aObj);
  if (global.Failed()) {
    return nullptr;
  }
  ErrorResult rv;
  nsRefPtr<mozilla::dom::${descriptorName}> result = ConstructNavigatorObjectHelper(aCx, global, rv);
  rv.WouldReportJSException();
  if (rv.Failed()) {
    ThrowMethodFailedWithDetails<${mainThread}>(aCx, rv, "${descriptorName}", "navigatorConstructor");
    return nullptr;
  }
  JS::Rooted<JS::Value> v(aCx);
  if (!WrapNewBindingObject(aCx, aObj, result, &v)) {
    MOZ_ASSERT(JS_IsExceptionPending(aCx));
    return nullptr;
  }
  return &v.toObject();""").substitute(
    {
        'descriptorName' : self.descriptor.name,
        'mainThread' : toStringBool(not self.descriptor.workers),
    })

class CGClassConstructHookHolder(CGGeneric):
    def __init__(self, descriptor):
        if descriptor.interface.ctor():
            constructHook = CONSTRUCT_HOOK_NAME
        else:
            constructHook = "ThrowingConstructor"
        CGGeneric.__init__(self,
                           "static const JSNativeHolder " + CONSTRUCT_HOOK_NAME + "_holder = {\n" +
                           "  " + constructHook + ",\n" +
                           "  " + NativePropertyHooks(descriptor) + "\n" +
                           "};\n")

def NamedConstructorName(m):
    return '_' + m.identifier.name

class CGNamedConstructors(CGThing):
    def __init__(self, descriptor):
        self.descriptor = descriptor
        CGThing.__init__(self)
    def declare(self):
        return ""
    def define(self):
        if len(self.descriptor.interface.namedConstructors) == 0:
            return ""

        constructorID = "constructors::id::"
        if self.descriptor.interface.hasInterfaceObject():
            constructorID += self.descriptor.name
        else:
            constructorID += "_ID_Count"
        nativePropertyHooks = """const NativePropertyHooks sNamedConstructorNativePropertyHooks = {
    nullptr,
    nullptr,
    { nullptr, nullptr },
    prototypes::id::%s,
    %s,
    nullptr
};

""" % (self.descriptor.name, constructorID)
        namedConstructors = CGList([], ",\n")
        for n in self.descriptor.interface.namedConstructors:
            namedConstructors.append(CGGeneric("{ \"%s\", { %s, &sNamedConstructorNativePropertyHooks }, %i }" % (n.identifier.name, NamedConstructorName(n), methodLength(n))))
        namedConstructors.append(CGGeneric("{ nullptr, { nullptr, nullptr }, 0 }"))
        namedConstructors = CGWrapper(CGIndenter(namedConstructors),
                                      pre="static const NamedConstructor namedConstructors[] = {\n",
                                      post="\n};\n")
        return nativePropertyHooks + namedConstructors.define()

class CGClassHasInstanceHook(CGAbstractStaticMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'), Argument('JS::Handle<JSObject*>', 'obj'),
                Argument('JS::MutableHandle<JS::Value>', 'vp'), Argument('bool*', 'bp')]
        CGAbstractStaticMethod.__init__(self, descriptor, HASINSTANCE_HOOK_NAME,
                                        'bool', args)

    def define(self):
        if not NeedsGeneratedHasInstance(self.descriptor):
            return ""
        return CGAbstractStaticMethod.define(self)

    def definition_body(self):
        return self.generate_code()

    def generate_code(self):
        header = """
  if (!vp.isObject()) {
    *bp = false;
    return true;
  }

  JS::Rooted<JSObject*> instance(cx, &vp.toObject());
  """
        if self.descriptor.interface.hasInterfacePrototypeObject():
            return header + """
  static_assert(IsBaseOf<nsISupports, %s>::value,
                "HasInstance only works for nsISupports-based classes.");

  bool ok = InterfaceHasInstance(cx, obj, instance, bp);
  if (!ok || *bp) {
    return ok;
  }

  // FIXME Limit this to chrome by checking xpc::AccessCheck::isChrome(obj).
  nsISupports* native =
    nsContentUtils::XPConnect()->GetNativeOfWrapper(cx,
                                                    js::UncheckedUnwrap(instance));
  nsCOMPtr<nsIDOM%s> qiResult = do_QueryInterface(native);
  *bp = !!qiResult;
  return true;
         """ % (self.descriptor.nativeType,
                self.descriptor.interface.identifier.name)

        hasInstanceCode = """
  const DOMClass* domClass = GetDOMClass(js::UncheckedUnwrap(instance));
  *bp = false;
  if (!domClass) {
    // Not a DOM object, so certainly not an instance of this interface
    return true;
  }
  """
        
        for iface in sorted(self.descriptor.interface.interfacesImplementingSelf,
                            key=lambda iface: iface.identifier.name):
            hasInstanceCode += """
  if (domClass->mInterfaceChain[PrototypeTraits<prototypes::id::%s>::Depth] == prototypes::id::%s) {
    *bp = true;
    return true;
  }
""" % (iface.identifier.name, iface.identifier.name)
        hasInstanceCode += "  return true;"
        return header + hasInstanceCode;

def isChromeOnly(m):
    return m.getExtendedAttribute("ChromeOnly")

class MemberCondition:
    """
    An object representing the condition for a member to actually be
    exposed.  Either pref or func or both can be None.  If not None,
    they should be strings that have the pref name or function name.
    """
    def __init__(self, pref, func):
        assert pref is None or isinstance(pref, str)
        assert func is None or isinstance(func, str)
        self.pref = pref
        if func is None:
            self.func = "nullptr"
        else:
            self.func = "&" + func

    def __eq__(self, other):
        return self.pref == other.pref and self.func == other.func

    def __ne__(self, other):
        return not self.__eq__(other)

class PropertyDefiner:
    """
    A common superclass for defining things on prototype objects.

    Subclasses should implement generateArray to generate the actual arrays of
    things we're defining.  They should also set self.chrome to the list of
    things only exposed to chrome and self.regular to the list of things exposed
    to both chrome and web pages.
    """
    def __init__(self, descriptor, name):
        self.descriptor = descriptor
        self.name = name
        
        
        
        self.prefCacheData = []
    def hasChromeOnly(self):
        return len(self.chrome) > 0
    def hasNonChromeOnly(self):
        return len(self.regular) > 0
    def variableName(self, chrome):
        if chrome:
            if self.hasChromeOnly():
                return "sChrome" + self.name
        else:
            if self.hasNonChromeOnly():
                return "s" + self.name
        return "nullptr"
    def usedForXrays(self):
        
        return not self.descriptor.workers

    def __str__(self):
        
        
        str = self.generateArray(self.regular, self.variableName(False),
                                 self.usedForXrays())
        if self.hasChromeOnly():
            str += self.generateArray(self.chrome, self.variableName(True),
                                      self.usedForXrays())
        return str

    @staticmethod
    def getStringAttr(member, name):
        attr = member.getExtendedAttribute(name)
        if attr is None:
            return None
        
        assert(len(attr) is 1)
        assert(attr[0] is not None)
        return attr[0]

    @staticmethod
    def getControllingCondition(interfaceMember):
        return MemberCondition(PropertyDefiner.getStringAttr(interfaceMember,
                                                             "Pref"),
                               PropertyDefiner.getStringAttr(interfaceMember,
                                                             "Func"))

    def generatePrefableArray(self, array, name, specTemplate, specTerminator,
                              specType, getCondition, getDataTuple, doIdArrays):
        """
        This method generates our various arrays.

        array is an array of interface members as passed to generateArray

        name is the name as passed to generateArray

        specTemplate is a template for each entry of the spec array

        specTerminator is a terminator for the spec array (inserted every time
          our controlling pref changes and at the end of the array)

        specType is the actual typename of our spec

        getCondition is a callback function that takes an array entry and
          returns the corresponding MemberCondition.

        getDataTuple is a callback function that takes an array entry and
          returns a tuple suitable for substitution into specTemplate.
        """

        
        
        
        
        
        
        assert(len(array) is not 0)
        lastCondition = getCondition(array[0]) 
                                               
        specs = []
        prefableSpecs = []

        prefableTemplate = '  { true, %s, &%s[%d] }'
        prefCacheTemplate = '&%s[%d].enabled'
        def switchToCondition(props, condition):
            
            
            if condition.pref is not None:
                props.prefCacheData.append(
                    (condition.pref,
                     prefCacheTemplate % (name, len(prefableSpecs)))
                    )
            
            prefableSpecs.append(prefableTemplate %
                                 (condition.func, name + "_specs", len(specs)))

        switchToCondition(self, lastCondition)

        for member in array:
            curCondition = getCondition(member)
            if lastCondition != curCondition:
                
                specs.append(specTerminator)
                
                switchToCondition(self, curCondition)
                lastCondition = curCondition
            
            specs.append(specTemplate % getDataTuple(member))
        specs.append(specTerminator)
        prefableSpecs.append("  { false, nullptr }");

        specType = "const " + specType
        arrays = (("static %s %s_specs[] = {\n" +
                   ',\n'.join(specs) + "\n" +
                   "};\n\n" +
                   "// Can't be const because the pref-enabled boolean needs to be writable\n"
                   "static Prefable<%s> %s[] = {\n" +
                   ',\n'.join(prefableSpecs) + "\n" +
                   "};\n\n") % (specType, name, specType, name))
        if doIdArrays:
            arrays += ("static jsid %s_ids[%i] = { JSID_VOID };\n\n" %
                       (name, len(specs)))
        return arrays




def overloadLength(arguments):
    i = len(arguments)
    while i > 0 and arguments[i - 1].optional:
        i -= 1
    return i
def methodLength(method):
    signatures = method.signatures()
    return min(overloadLength(arguments) for (retType, arguments) in signatures)

class MethodDefiner(PropertyDefiner):
    """
    A class for defining methods on a prototype object.
    """
    def __init__(self, descriptor, name, static):
        PropertyDefiner.__init__(self, descriptor, name)

        
        
        

        
        if descriptor.interface.hasInterfacePrototypeObject() or static:
            methods = [m for m in descriptor.interface.members if
                       m.isMethod() and m.isStatic() == static and
                       not m.isIdentifierLess()]
        else:
            methods = []
        self.chrome = []
        self.regular = []
        for m in methods:
            method = { "name": m.identifier.name,
                       "methodInfo": not m.isStatic(),
                       "length": methodLength(m),
                       "flags": "JSPROP_ENUMERATE",
                       "condition": PropertyDefiner.getControllingCondition(m) }
            if isChromeOnly(m):
                self.chrome.append(method)
            else:
                self.regular.append(method)

        
        if any(m.isGetter() and m.isIndexed() for m in methods):
            self.regular.append({"name": 'iterator',
                                 "methodInfo": False,
                                 "nativeName": "JS_ArrayIterator",
                                 "length": 0,
                                 "flags": "JSPROP_ENUMERATE",
                                 "condition": MemberCondition(None, None) })

        if not static and descriptor.wantsQI():
            condition = "WantsQueryInterface<%s>::Enabled" % descriptor.nativeType
            self.regular.append({"name": 'QueryInterface',
                                 "methodInfo": False,
                                 "length": 1,
                                 "flags": "0",
                                 "condition": MemberCondition(None, condition) })

        if not static:
            stringifier = descriptor.operations['Stringifier']
            if stringifier:
                toStringDesc = { "name": "toString",
                                 "nativeName": stringifier.identifier.name,
                                 "length": 0,
                                 "flags": "JSPROP_ENUMERATE",
                                 "condition": PropertyDefiner.getControllingCondition(stringifier) }
                if isChromeOnly(stringifier):
                    self.chrome.append(toStringDesc)
                else:
                    self.regular.append(toStringDesc)
            jsonifier = descriptor.operations['Jsonifier']
            if jsonifier:
                toJSONDesc = { "name": "toJSON",
                               "nativeName": jsonifier.identifier.name,
                               "length": 0,
                               "flags": "JSPROP_ENUMERATE",
                               "condition": PropertyDefiner.getControllingCondition(jsonifier) }
                if isChromeOnly(jsonifier):
                    self.chrome.append(toJSONDesc)
                else:
                    self.regular.append(toJSONDesc)
        elif (descriptor.interface.isJSImplemented() and
              descriptor.interface.hasInterfaceObject()):
            self.chrome.append({"name": '_create',
                                "nativeName": ("%s::_Create" %
                                               descriptor.name),
                                "methodInfo": False,
                                "length": 2,
                                "flags": "0",
                                "condition": MemberCondition(None, None) })

        if static:
            if not descriptor.interface.hasInterfaceObject():
                
                assert not self.hasChromeOnly() and not self.hasNonChromeOnly()
        else:
            if not descriptor.interface.hasInterfacePrototypeObject():
                
                assert not self.hasChromeOnly() and not self.hasNonChromeOnly()

    def generateArray(self, array, name, doIdArrays):
        if len(array) == 0:
            return ""

        def condition(m):
            return m["condition"]

        def specData(m):
            accessor = m.get("nativeName", m["name"])
            if m.get("methodInfo", True):
                jitinfo = ("&%s_methodinfo" % accessor)
                accessor = "genericMethod"
            else:
                jitinfo = "nullptr"
            return (m["name"], accessor, jitinfo, m["length"], m["flags"])

        return self.generatePrefableArray(
            array, name,
            '  JS_FNINFO("%s", %s, %s, %s, %s)',
            '  JS_FS_END',
            'JSFunctionSpec',
            condition, specData, doIdArrays)

class AttrDefiner(PropertyDefiner):
    def __init__(self, descriptor, name, static, unforgeable=False):
        assert not (static and unforgeable)
        PropertyDefiner.__init__(self, descriptor, name)
        self.name = name
        
        if descriptor.interface.hasInterfacePrototypeObject() or static:
            attributes = [m for m in descriptor.interface.members if
                          m.isAttr() and m.isStatic() == static and
                          m.isUnforgeable() == unforgeable]
        else:
            attributes = []
        self.chrome = [m for m in attributes if isChromeOnly(m)]
        self.regular = [m for m in attributes if not isChromeOnly(m)]
        self.static = static
        self.unforgeable = unforgeable

        if static:
            if not descriptor.interface.hasInterfaceObject():
                
                assert not self.hasChromeOnly() and not self.hasNonChromeOnly()
        else:
            if not descriptor.interface.hasInterfacePrototypeObject():
                
                assert not self.hasChromeOnly() and not self.hasNonChromeOnly()

    def generateArray(self, array, name, doIdArrays):
        if len(array) == 0:
            return ""

        def flags(attr):
            unforgeable = " | JSPROP_PERMANENT" if self.unforgeable else ""
            return ("JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS" +
                    unforgeable)

        def getter(attr):
            if self.static:
                accessor = 'get_' + attr.identifier.name
                jitinfo = "nullptr"
            else:
                accessor = ("genericLenientGetter" if attr.hasLenientThis()
                            else "genericGetter")
                jitinfo = "&%s_getterinfo" % attr.identifier.name
            return "{ JS_CAST_NATIVE_TO(%s, JSPropertyOp), %s }" % \
                   (accessor, jitinfo)

        def setter(attr):
            if attr.readonly and attr.getExtendedAttribute("PutForwards") is None:
                return "JSOP_NULLWRAPPER"
            if self.static:
                accessor = 'set_' + attr.identifier.name
                jitinfo = "nullptr"
            else:
                accessor = ("genericLenientSetter" if attr.hasLenientThis()
                            else "genericSetter")
                jitinfo = "&%s_setterinfo" % attr.identifier.name
            return "{ JS_CAST_NATIVE_TO(%s, JSStrictPropertyOp), %s }" % \
                   (accessor, jitinfo)

        def specData(attr):
            return (attr.identifier.name, flags(attr), getter(attr),
                    setter(attr))

        return self.generatePrefableArray(
            array, name,
            '  { "%s", 0, %s, %s, %s}',
            '  JS_PS_END',
            'JSPropertySpec',
            PropertyDefiner.getControllingCondition, specData, doIdArrays)

class ConstDefiner(PropertyDefiner):
    """
    A class for definining constants on the interface object
    """
    def __init__(self, descriptor, name):
        PropertyDefiner.__init__(self, descriptor, name)
        self.name = name
        constants = [m for m in descriptor.interface.members if m.isConst()]
        self.chrome = [m for m in constants if isChromeOnly(m)]
        self.regular = [m for m in constants if not isChromeOnly(m)]

    def generateArray(self, array, name, doIdArrays):
        if len(array) == 0:
            return ""

        def specData(const):
            return (const.identifier.name,
                    convertConstIDLValueToJSVal(const.value))

        return self.generatePrefableArray(
            array, name,
            '  { "%s", %s }',
            '  { 0, JS::UndefinedValue() }',
            'ConstantSpec',
            PropertyDefiner.getControllingCondition, specData, doIdArrays)

class PropertyArrays():
    def __init__(self, descriptor):
        self.staticMethods = MethodDefiner(descriptor, "StaticMethods",
                                           static=True)
        self.staticAttrs = AttrDefiner(descriptor, "StaticAttributes",
                                       static=True)
        self.methods = MethodDefiner(descriptor, "Methods", static=False)
        self.attrs = AttrDefiner(descriptor, "Attributes", static=False)
        self.unforgeableAttrs = AttrDefiner(descriptor, "UnforgeableAttributes",
                                            static=False, unforgeable=True)
        self.consts = ConstDefiner(descriptor, "Constants")

    @staticmethod
    def arrayNames():
        return [ "staticMethods", "staticAttrs", "methods", "attrs",
                 "unforgeableAttrs", "consts" ]

    def hasChromeOnly(self):
        return any(getattr(self, a).hasChromeOnly() for a in self.arrayNames())
    def hasNonChromeOnly(self):
        return any(getattr(self, a).hasNonChromeOnly() for a in self.arrayNames())
    def __str__(self):
        define = ""
        for array in self.arrayNames():
            define += str(getattr(self, array))
        return define

class CGNativeProperties(CGList):
    def __init__(self, descriptor, properties):
        def generateNativeProperties(name, chrome):
            def check(p):
                return p.hasChromeOnly() if chrome else p.hasNonChromeOnly()

            nativeProps = []
            for array in properties.arrayNames():
                propertyArray = getattr(properties, array)
                if check(propertyArray):
                    if propertyArray.usedForXrays():
                        ids = "%(name)s_ids"
                    else:
                        ids = "nullptr"
                    props = "%(name)s, " + ids + ", %(name)s_specs"
                    props = (props %
                             { 'name': propertyArray.variableName(chrome) })
                else:
                    props = "nullptr, nullptr, nullptr"
                nativeProps.append(CGGeneric(props))
            return CGWrapper(CGIndenter(CGList(nativeProps, ",\n")),
                             pre="static const NativeProperties %s = {\n" % name,
                             post="\n};")

        nativeProperties = []
        if properties.hasNonChromeOnly():
            nativeProperties.append(
                generateNativeProperties("sNativeProperties", False))
        if properties.hasChromeOnly():
            nativeProperties.append(
                generateNativeProperties("sChromeOnlyNativeProperties", True))
        CGList.__init__(self, nativeProperties, "\n\n")

    def declare(self):
        return ""

class CGCreateInterfaceObjectsMethod(CGAbstractMethod):
    """
    Generate the CreateInterfaceObjects method for an interface descriptor.

    properties should be a PropertyArrays instance.
    """
    def __init__(self, descriptor, properties):
        args = [Argument('JSContext*', 'aCx'),
                Argument('JS::Handle<JSObject*>', 'aGlobal'),
                Argument('JS::Heap<JSObject*>*', 'aProtoAndIfaceArray'),
                Argument('bool', 'aDefineOnGlobal')]
        CGAbstractMethod.__init__(self, descriptor, 'CreateInterfaceObjects', 'void', args)
        self.properties = properties
    def definition_body(self):
        protoChain = self.descriptor.prototypeChain
        if len(protoChain) == 1:
            parentProtoType = "Rooted"
            if self.descriptor.interface.getExtendedAttribute("ArrayClass"):
                getParentProto = "aCx, JS_GetArrayPrototype(aCx, aGlobal)"
            else:
                getParentProto = "aCx, JS_GetObjectPrototype(aCx, aGlobal)"
        else:
            parentProtoName = self.descriptor.prototypeChain[-2]
            getParentProto = ("%s::GetProtoObject(aCx, aGlobal)" %
                              toBindingNamespace(parentProtoName))
            parentProtoType = "Handle"

        parentWithInterfaceObject = self.descriptor.interface.parent
        while (parentWithInterfaceObject and
               not parentWithInterfaceObject.hasInterfaceObject()):
            parentWithInterfaceObject = parentWithInterfaceObject.parent
        if parentWithInterfaceObject:
            parentIfaceName = parentWithInterfaceObject.identifier.name
            if self.descriptor.workers:
                parentIfaceName += "_workers"
            getConstructorProto = ("%s::GetConstructorObject(aCx, aGlobal)" %
                                   toBindingNamespace(parentIfaceName))
            constructorProtoType = "Handle"
        else:
            getConstructorProto = "aCx, JS_GetFunctionPrototype(aCx, aGlobal)"
            constructorProtoType = "Rooted"

        needInterfaceObject = self.descriptor.interface.hasInterfaceObject()
        needInterfacePrototypeObject = self.descriptor.interface.hasInterfacePrototypeObject()

        
        assert needInterfaceObject or needInterfacePrototypeObject

        idsToInit = []
        
        
        if not self.descriptor.workers:
            for var in self.properties.arrayNames():
                props = getattr(self.properties, var)
                
                if props.hasChromeOnly():
                    idsToInit.append(props.variableName(True))
                if props.hasNonChromeOnly():
                    idsToInit.append(props.variableName(False))
        if len(idsToInit) > 0:
            initIds = CGList(
                [CGGeneric("!InitIds(aCx, %s, %s_ids)" % (varname, varname)) for
                 varname in idsToInit], ' ||\n')
            if len(idsToInit) > 1:
                initIds = CGWrapper(initIds, pre="(", post=")", reindent=True)
            initIds = CGList(
                [CGGeneric("%s_ids[0] == JSID_VOID &&" % idsToInit[0]),
                 CGGeneric("NS_IsMainThread() &&"),
                 initIds],
                "\n")
            initIds = CGWrapper(initIds, pre="if (", post=") {", reindent=True)
            initIds = CGList(
                [initIds,
                 CGGeneric(("  %s_ids[0] = JSID_VOID;\n"
                            "  return;") % idsToInit[0]),
                 CGGeneric("}")],
                "\n")
        else:
            initIds = None

        prefCacheData = []
        for var in self.properties.arrayNames():
            props = getattr(self.properties, var)
            prefCacheData.extend(props.prefCacheData)
        if len(prefCacheData) is not 0:
            prefCacheData = [
                CGGeneric('Preferences::AddBoolVarCache(%s, "%s");' % (ptr, pref)) for
                (pref, ptr) in prefCacheData]
            prefCache = CGWrapper(CGIndenter(CGList(prefCacheData, "\n")),
                                  pre=("static bool sPrefCachesInited = false;\n"
                                       "if (!sPrefCachesInited) {\n"
                                       "  sPrefCachesInited = true;\n"),
                                  post="\n}")
        else:
            prefCache = None
            
        if UseHolderForUnforgeable(self.descriptor):
            createUnforgeableHolder = CGGeneric("""JS::Rooted<JSObject*> unforgeableHolder(aCx,
  JS_NewObjectWithGivenProto(aCx, nullptr, nullptr, nullptr));
if (!unforgeableHolder) {
  return;
}""")
            defineUnforgeables = InitUnforgeablePropertiesOnObject(self.descriptor,
                                                                   "unforgeableHolder",
                                                                   self.properties)
            createUnforgeableHolder = CGList([createUnforgeableHolder,
                                              defineUnforgeables],
                                             "\n")
        else:
            createUnforgeableHolder = None

        getParentProto = ("JS::%s<JSObject*> parentProto(%s);\n" +
                          "if (!parentProto) {\n" +
                          "  return;\n" +
                          "}") % (parentProtoType, getParentProto)

        getConstructorProto = ("JS::%s<JSObject*> constructorProto(%s);\n"
                               "if (!constructorProto) {\n"
                               "  return;\n"
                               "}" % (constructorProtoType, getConstructorProto))

        if (needInterfaceObject and
            self.descriptor.needsConstructHookHolder()):
            constructHookHolder = "&" + CONSTRUCT_HOOK_NAME + "_holder"
        else:
            constructHookHolder = "nullptr"
        if self.descriptor.interface.ctor():
            constructArgs = methodLength(self.descriptor.interface.ctor())
        else:
            constructArgs = 0
        if len(self.descriptor.interface.namedConstructors) > 0:
            namedConstructors = "namedConstructors"
        else:
            namedConstructors = "nullptr"

        if needInterfacePrototypeObject:
            protoClass = "&PrototypeClass.mBase"
            protoCache = "&aProtoAndIfaceArray[prototypes::id::%s]" % self.descriptor.name
        else:
            protoClass = "nullptr"
            protoCache = "nullptr"
        if needInterfaceObject:
            interfaceClass = "&InterfaceObjectClass.mBase"
            interfaceCache = "&aProtoAndIfaceArray[constructors::id::%s]" % self.descriptor.name
        else:
            
            assert len(self.descriptor.interface.namedConstructors) == 0
            interfaceClass = "nullptr"
            interfaceCache = "nullptr"

        if self.descriptor.concrete:
            if self.descriptor.proxy:
                domClass = "&Class"
            else:
                domClass = "&Class.mClass"
        else:
            domClass = "nullptr"

        if self.properties.hasNonChromeOnly():
            properties = "&sNativeProperties"
        else:
            properties = "nullptr"
        if self.properties.hasChromeOnly():
            accessCheck = GetAccessCheck(self.descriptor, "aGlobal")
            chromeProperties = accessCheck + " ? &sChromeOnlyNativeProperties : nullptr"
        else:
            chromeProperties = "nullptr"
        call = ("dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,\n"
                "                            %s, %s,\n"
                "                            constructorProto, %s, %s, %d, %s,\n"
                "                            %s,\n"
                "                            %s,\n"
                "                            %s,\n"
                "                            %s,\n"
                "                            %s, aDefineOnGlobal);" % (
            protoClass, protoCache,
            interfaceClass, constructHookHolder, constructArgs,
            namedConstructors,
            interfaceCache,
            domClass,
            properties,
            chromeProperties,
            '"' + self.descriptor.interface.identifier.name + '"' if needInterfaceObject else "nullptr"))
        if UseHolderForUnforgeable(self.descriptor):
            assert needInterfacePrototypeObject
            setUnforgeableHolder = CGGeneric(
                "JSObject* proto = aProtoAndIfaceArray[prototypes::id::%s];\n"
                "if (proto) {\n"
                "  js::SetReservedSlot(proto, DOM_INTERFACE_PROTO_SLOTS_BASE,\n"
                "                      JS::ObjectValue(*unforgeableHolder));\n"
                "}" % self.descriptor.name)
        else:
            setUnforgeableHolder = None
        functionBody = CGList(
            [CGGeneric(getParentProto), CGGeneric(getConstructorProto), initIds,
             prefCache, createUnforgeableHolder, CGGeneric(call), setUnforgeableHolder],
            "\n\n")
        return CGIndenter(functionBody).define()

class CGGetPerInterfaceObject(CGAbstractMethod):
    """
    A method for getting a per-interface object (a prototype object or interface
    constructor object).
    """
    def __init__(self, descriptor, name, idPrefix="", extraArgs=[]):
        args = [Argument('JSContext*', 'aCx'),
                Argument('JS::Handle<JSObject*>', 'aGlobal')] + extraArgs
        CGAbstractMethod.__init__(self, descriptor, name,
                                  'JS::Handle<JSObject*>', args)
        self.id = idPrefix + "id::" + self.descriptor.name
    def definition_body(self):
        return ("""

  /* Make sure our global is sane.  Hopefully we can remove this sometime */
  if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
    return JS::NullPtr();
  }
  /* Check to see whether the interface objects are already installed */
  JS::Heap<JSObject*>* protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
  if (!protoAndIfaceArray[%s]) {
    CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray, aDefineOnGlobal);
  }

  /* 
   * The object might _still_ be null, but that's OK.
   *
   * Calling fromMarkedLocation() is safe because protoAndIfaceArray is
   * traced by TraceProtoAndIfaceCache() and its contents are never
   * changed after they have been set.
   */
  return JS::Handle<JSObject*>::fromMarkedLocation(protoAndIfaceArray[%s].address());""" %
                (self.id, self.id))

class CGGetProtoObjectMethod(CGGetPerInterfaceObject):
    """
    A method for getting the interface prototype object.
    """
    def __init__(self, descriptor):
        CGGetPerInterfaceObject.__init__(self, descriptor, "GetProtoObject",
                                         "prototypes::")
    def definition_body(self):
        return """
  /* Get the interface prototype object for this class.  This will create the
     object as needed. */
  bool aDefineOnGlobal = true;""" + CGGetPerInterfaceObject.definition_body(self)

class CGGetConstructorObjectMethod(CGGetPerInterfaceObject):
    """
    A method for getting the interface constructor object.
    """
    def __init__(self, descriptor):
        CGGetPerInterfaceObject.__init__(
            self, descriptor, "GetConstructorObject",
            "constructors::",
            extraArgs=[Argument("bool", "aDefineOnGlobal", "true")])
    def definition_body(self):
        return """
  /* Get the interface object for this class.  This will create the object as
     needed. */""" + CGGetPerInterfaceObject.definition_body(self)

class CGDefineDOMInterfaceMethod(CGAbstractMethod):
    """
    A method for resolve hooks to try to lazily define the interface object for
    a given interface.
    """
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'aCx'),
                Argument('JS::Handle<JSObject*>', 'aGlobal'),
                Argument('JS::Handle<jsid>', 'id'),
                Argument('bool', 'aDefineOnGlobal')]
        CGAbstractMethod.__init__(self, descriptor, 'DefineDOMInterface', 'JSObject*', args)

    def declare(self):
        if self.descriptor.workers:
            return ''
        return CGAbstractMethod.declare(self)

    def define(self):
        if self.descriptor.workers:
            return ''
        return CGAbstractMethod.define(self)

    def definition_body(self):
        if len(self.descriptor.interface.namedConstructors) > 0:
            getConstructor = """  JSObject* interfaceObject = GetConstructorObject(aCx, aGlobal, aDefineOnGlobal);
  if (!interfaceObject) {
    return nullptr;
  }
  for (unsigned slot = DOM_INTERFACE_SLOTS_BASE; slot < JSCLASS_RESERVED_SLOTS(&InterfaceObjectClass.mBase); ++slot) {
    JSObject* constructor = &js::GetReservedSlot(interfaceObject, slot).toObject();
    if (JS_GetFunctionId(JS_GetObjectFunction(constructor)) == JSID_TO_STRING(id)) {
      return constructor;
    }
  }
  return interfaceObject;"""
        else:
            getConstructor = "  return GetConstructorObject(aCx, aGlobal, aDefineOnGlobal);"
        return getConstructor

class CGConstructorEnabledViaPrefEnabled(CGAbstractMethod):
    """
    A method for testing whether the preference controlling this
    interface is enabled. This delegates to PrefEnabled() on the
    wrapped class. The interface should only be visible on the global
    if the method returns true.
    """
    def __init__(self, descriptor):
        CGAbstractMethod.__init__(self, descriptor,
                                  'ConstructorEnabled', 'bool',
                                  [Argument("JSContext*", "/* unused */"),
                                   Argument("JS::Handle<JSObject*>",
                                            "/* unused */")])

    def definition_body(self):
        return "  return %s::PrefEnabled();" % self.descriptor.nativeType

class CGConstructorEnabledViaPref(CGAbstractMethod):
    """
    A method for testing whether the preference controlling this
    interface is enabled. This generates code in the binding to
    check the given preference. The interface should only be visible
    on the global if the pref is true.
    """
    def __init__(self, descriptor):
        CGAbstractMethod.__init__(self, descriptor,
                                  'ConstructorEnabled', 'bool',
                                  [Argument("JSContext*", "/* unused */"),
                                   Argument("JS::Handle<JSObject*>",
                                            "/* unused */")])

    def definition_body(self):
        pref = self.descriptor.interface.getExtendedAttribute("Pref")
        assert isinstance(pref, list) and len(pref) == 1
        return "  return Preferences::GetBool(\"%s\");" % pref[0]

class CGConstructorEnabledChromeOnly(CGAbstractMethod):
    """
    A method for testing whether the object we're going to be defined
    on is chrome so we can decide whether our constructor should be
    enabled.
    """
    def __init__(self, descriptor):
        assert descriptor.interface.getExtendedAttribute("ChromeOnly")
        CGAbstractMethod.__init__(self, descriptor,
                                  'ConstructorEnabled', 'bool',
                                  [Argument("JSContext*", "aCx"),
                                   Argument("JS::Handle<JSObject*>", "aObj")])

    def definition_body(self):
        return "  return %s;" % GetAccessCheck(self.descriptor, "aObj")

class CGConstructorEnabledViaFunc(CGAbstractMethod):
    """
    A method for testing whether the interface object should be exposed on a
    given global based on whatever the callee wants to consider.
    """
    def __init__(self, descriptor):
        CGAbstractMethod.__init__(self, descriptor,
                                  'ConstructorEnabled', 'bool',
                                  [Argument("JSContext*", "cx"),
                                   Argument("JS::Handle<JSObject*>", "obj")])

    def definition_body(self):
        func = self.descriptor.interface.getExtendedAttribute("Func")
        assert isinstance(func, list) and len(func) == 1
        return "  return %s(cx, obj);" % func[0]

def CreateBindingJSObject(descriptor, properties, parent):
    
    
    
    needRoot = (properties.unforgeableAttrs.hasNonChromeOnly() or
                properties.unforgeableAttrs.hasChromeOnly())
    if needRoot:
        objDecl = "  JS::Rooted<JSObject*> obj(aCx);\n"
    else:
        objDecl = "  JSObject *obj;\n"
    if descriptor.proxy:
        create = """  JS::Rooted<JS::Value> proxyPrivateVal(aCx, JS::PrivateValue(aObject));
  obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
                       proxyPrivateVal, proto, %s);
  if (!obj) {
    return nullptr;
  }

"""
        if descriptor.interface.getExtendedAttribute('OverrideBuiltins'):
            create += """  js::SetProxyExtra(obj, JSPROXYSLOT_EXPANDO,
                    JS::PrivateValue(&aObject->mExpandoAndGeneration));

"""
    else:
        create = """  obj = JS_NewObject(aCx, &Class.mBase, proto, %s);
  if (!obj) {
    return nullptr;
  }

  js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
"""
    create = objDecl + create

    if descriptor.nativeOwnership == 'refcounted':
        create += """  NS_ADDREF(aObject);
"""
    else:
        create += """  // Make sure the native objects inherit from NonRefcountedDOMObject so that we
  // log their ctor and dtor.
  MustInheritFromNonRefcountedDOMObject(aObject);
  *aTookOwnership = true;
"""
    return create % parent

def GetAccessCheck(descriptor, object):
    """
    object is the name of a JSObject*

    returns a string
    """
    accessCheck = "xpc::AccessCheck::isChrome(%s)" % object
    if descriptor.workers:
        
        
        
        accessCheck = "(NS_IsMainThread() ? %s : mozilla::dom::workers::GetWorkerPrivateFromContext(aCx)->IsChromeWorker())" % accessCheck
    return accessCheck

def InitUnforgeablePropertiesOnObject(descriptor, obj, properties, failureReturnValue=""):
    """
    properties is a PropertyArrays instance
    """
    failureReturn = "return"
    if len(failureReturnValue) > 0:
        failureReturn += " " + failureReturnValue
    failureReturn += ";"

    defineUnforgeables = ("if (!DefineUnforgeableAttributes(aCx, " + obj + ", %s)) {\n"
                          "  " + failureReturn + "\n"
                          "}")

    unforgeableAttrs = properties.unforgeableAttrs
    unforgeables = []
    if unforgeableAttrs.hasNonChromeOnly():
        unforgeables.append(CGGeneric(defineUnforgeables %
                                      unforgeableAttrs.variableName(False)))
    if unforgeableAttrs.hasChromeOnly():
        unforgeables.append(
            CGIfWrapper(CGGeneric(defineUnforgeables %
                                  unforgeableAttrs.variableName(True)),
                        GetAccessCheck(descriptor, obj)))
    return CGList(unforgeables, "\n")

def InitUnforgeableProperties(descriptor, properties):
    """
    properties is a PropertyArrays instance
    """
    unforgeableAttrs = properties.unforgeableAttrs
    if not unforgeableAttrs.hasNonChromeOnly() and not unforgeableAttrs.hasChromeOnly():
        return ""

    if descriptor.proxy:
        unforgeableProperties = CGGeneric(
            "// Unforgeable properties on proxy-based bindings are stored in an object held\n"
            "// by the interface prototype object.\n")
    else:
        unforgeableProperties = CGWrapper(
            InitUnforgeablePropertiesOnObject(descriptor, "obj", properties, "nullptr"),
            pre=(
            "// Important: do unforgeable property setup after we have handed\n"
            "// over ownership of the C++ object to obj as needed, so that if\n"
            "// we fail and it ends up GCed it won't have problems in the\n"
            "// finalizer trying to drop its ownership of the C++ object.\n"))
    return CGIndenter(CGWrapper(unforgeableProperties, pre="\n", post="\n")).define()

def AssertInheritanceChain(descriptor):
    asserts = ""
    iface = descriptor.interface
    while iface:
        desc = descriptor.getDescriptor(iface.identifier.name)
        asserts += (
            "  MOZ_ASSERT(static_cast<%s*>(aObject) == \n"
            "             reinterpret_cast<%s*>(aObject));\n" %
            (desc.nativeType, desc.nativeType))
        iface = iface.parent
    asserts += (
        "  MOZ_ASSERT(ToSupportsIsCorrect(aObject));\n")
    return asserts

class CGWrapWithCacheMethod(CGAbstractMethod):
    """
    Create a wrapper JSObject for a given native that implements nsWrapperCache.

    properties should be a PropertyArrays instance.
    """
    def __init__(self, descriptor, properties):
        assert descriptor.interface.hasInterfacePrototypeObject()
        args = [Argument('JSContext*', 'aCx'),
                Argument('JS::Handle<JSObject*>', 'aScope'),
                Argument(descriptor.nativeType + '*', 'aObject'),
                Argument('nsWrapperCache*', 'aCache')]
        CGAbstractMethod.__init__(self, descriptor, 'Wrap', 'JSObject*', args)
        self.properties = properties

    def definition_body(self):
        if self.descriptor.nativeOwnership == 'worker':
            return """  return aObject->GetJSObject();"""

        assertISupportsInheritance = (
            '  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),\n'
            '             "nsISupports must be on our primary inheritance chain");\n')
        return """%s
%s
  JS::Rooted<JSObject*> parent(aCx,
    GetRealParentObject(aObject,
                        WrapNativeParent(aCx, aScope, aObject->GetParentObject())));
  if (!parent) {
    return nullptr;
  }

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.  Scope so we don't
  // collide with the "obj" we declare in CreateBindingJSObject.
  {
    JSObject* obj = aCache->GetWrapper();
    if (obj) {
      return obj;
    }
  }

  JSAutoCompartment ac(aCx, parent);
  JS::Rooted<JSObject*> global(aCx, JS_GetGlobalForObject(aCx, parent));
  JS::Handle<JSObject*> proto = GetProtoObject(aCx, global);
  if (!proto) {
    return nullptr;
  }

%s
%s
  aCache->SetWrapper(obj);

  return obj;""" % (AssertInheritanceChain(self.descriptor),
                    assertISupportsInheritance,
                    CreateBindingJSObject(self.descriptor, self.properties,
                                          "parent"),
                    InitUnforgeableProperties(self.descriptor, self.properties))

class CGWrapMethod(CGAbstractMethod):
    def __init__(self, descriptor):
        
        assert descriptor.interface.hasInterfacePrototypeObject()
        args = [Argument('JSContext*', 'aCx'),
                Argument('JS::Handle<JSObject*>', 'aScope'),
                Argument('T*', 'aObject')]
        CGAbstractMethod.__init__(self, descriptor, 'Wrap', 'JSObject*', args, inline=True, templateArgs=["class T"])

    def definition_body(self):
        return "  return Wrap(aCx, aScope, aObject, aObject);"

class CGWrapNonWrapperCacheMethod(CGAbstractMethod):
    """
    Create a wrapper JSObject for a given native that does not implement
    nsWrapperCache.

    properties should be a PropertyArrays instance.
    """
    def __init__(self, descriptor, properties):
        
        assert descriptor.interface.hasInterfacePrototypeObject()
        args = [Argument('JSContext*', 'aCx'),
                Argument('JS::Handle<JSObject*>', 'aScope'),
                Argument(descriptor.nativeType + '*', 'aObject')]
        if descriptor.nativeOwnership == 'owned':
            args.append(Argument('bool*', 'aTookOwnership'))
        CGAbstractMethod.__init__(self, descriptor, 'Wrap', 'JSObject*', args)
        self.properties = properties

    def definition_body(self):
        return """%s
  JS::Rooted<JSObject*> global(aCx, JS_GetGlobalForObject(aCx, aScope));
  JS::Handle<JSObject*> proto = GetProtoObject(aCx, global);
  if (!proto) {
    return nullptr;
  }

%s
%s
  return obj;""" % (AssertInheritanceChain(self.descriptor),
                    CreateBindingJSObject(self.descriptor, self.properties,
                                          "global"),
                    InitUnforgeableProperties(self.descriptor, self.properties))

builtinNames = {
    IDLType.Tags.bool: 'bool',
    IDLType.Tags.int8: 'int8_t',
    IDLType.Tags.int16: 'int16_t',
    IDLType.Tags.int32: 'int32_t',
    IDLType.Tags.int64: 'int64_t',
    IDLType.Tags.uint8: 'uint8_t',
    IDLType.Tags.uint16: 'uint16_t',
    IDLType.Tags.uint32: 'uint32_t',
    IDLType.Tags.uint64: 'uint64_t',
    IDLType.Tags.unrestricted_float: 'float',
    IDLType.Tags.float: 'float',
    IDLType.Tags.unrestricted_double: 'double',
    IDLType.Tags.double: 'double'
}

numericSuffixes = {
    IDLType.Tags.int8: '',
    IDLType.Tags.uint8: '',
    IDLType.Tags.int16: '',
    IDLType.Tags.uint16: '',
    IDLType.Tags.int32: '',
    IDLType.Tags.uint32: 'U',
    IDLType.Tags.int64: 'LL',
    IDLType.Tags.uint64: 'ULL',
    IDLType.Tags.unrestricted_float: 'F',
    IDLType.Tags.float: 'F',
    IDLType.Tags.unrestricted_double: 'D',
    IDLType.Tags.double: 'D'
}

def numericValue(t, v):
    if (t == IDLType.Tags.unrestricted_double or
        t == IDLType.Tags.unrestricted_float):
        if v == float("inf"):
            return "mozilla::PositiveInfinity()"
        if v == float("-inf"):
            return "mozilla::NegativeInfinity()"
        if math.isnan(v):
            return "mozilla::UnspecifiedNaN()"
    return "%s%s" % (v, numericSuffixes[t])

class CastableObjectUnwrapper():
    """
    A class for unwrapping an object named by the "source" argument
    based on the passed-in descriptor and storing it in a variable
    called by the name in the "target" argument.

    codeOnFailure is the code to run if unwrapping fails.

    If isCallbackReturnValue is "JSImpl" and our descriptor is also
    JS-implemented, fall back to just creating the right object if what we
    have isn't one already.
    """
    def __init__(self, descriptor, source, target, codeOnFailure,
                 exceptionCode=None, isCallbackReturnValue=False):
        if not exceptionCode:
            exceptionCode = codeOnFailure
        self.substitution = { "type" : descriptor.nativeType,
                              "protoID" : "prototypes::id::" + descriptor.name,
                              "source" : source,
                              "target" : target,
                              "codeOnFailure" : CGIndenter(CGGeneric(codeOnFailure)).define(),
                              "exceptionCode" : CGIndenter(CGGeneric(exceptionCode), 4).define() }
        if descriptor.hasXPConnectImpls:
            
            
            
            self.substitution["codeOnFailure"] = CGIndenter(CGGeneric(string.Template(
                "${type} *objPtr;\n"
                "SelfRef objRef;\n"
                "JS::Rooted<JS::Value> val(cx, JS::ObjectValue(*${source}));\n"
                "nsresult rv = UnwrapArg<${type}>(cx, val, &objPtr, &objRef.ptr, val.address());\n"
                "if (NS_FAILED(rv)) {\n"
                "${codeOnFailure}\n"
                "}\n"
                "// We should be castable!\n"
                "MOZ_ASSERT(!objRef.ptr);\n"
                "// We should have an object, too!\n"
                "MOZ_ASSERT(objPtr);\n"
                "${target} = objPtr;").substitute(self.substitution)), 4).define()
        elif (isCallbackReturnValue == "JSImpl" and
              descriptor.interface.isJSImplemented()):
            self.substitution["codeOnFailure"] = CGIndenter(CGGeneric(string.Template(
                "// Be careful to not wrap random DOM objects here, even if\n"
                "// they're wrapped in opaque security wrappers for some reason.\n"
                "// XXXbz Wish we could check for a JS-implemented object\n"
                "// that already has a content reflection...\n"
                "if (!IsDOMObject(js::UncheckedUnwrap(${source}))) {\n"
                "  nsCOMPtr<nsPIDOMWindow> ourWindow;\n"
                "  if (!GetWindowForJSImplementedObject(cx, Callback(), getter_AddRefs(ourWindow))) {\n"
                "${exceptionCode}\n"
                "  }\n"
                "  JS::Rooted<JSObject*> jsImplSourceObj(cx, ${source});\n"
                "  ${target} = new ${type}(jsImplSourceObj, ourWindow);\n"
                "} else {\n"
                "${codeOnFailure}\n"
                "}").substitute(self.substitution)), 4).define()
        else:
            self.substitution["codeOnFailure"] = CGIndenter(
                CGGeneric(self.substitution["codeOnFailure"])).define()

    def __str__(self):
        return string.Template(
"""{
  nsresult rv = UnwrapObject<${protoID}, ${type}>(cx, ${source}, ${target});
  if (NS_FAILED(rv)) {
${codeOnFailure}
  }
}""").substitute(self.substitution)

class FailureFatalCastableObjectUnwrapper(CastableObjectUnwrapper):
    """
    As CastableObjectUnwrapper, but defaulting to throwing if unwrapping fails
    """
    def __init__(self, descriptor, source, target, exceptionCode,
                 isCallbackReturnValue, sourceDescription):
        CastableObjectUnwrapper.__init__(
            self, descriptor, source, target,
            'ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "%s", "%s");\n'
            '%s' % (sourceDescription, descriptor.interface.identifier.name,
                    exceptionCode),
            exceptionCode,
            isCallbackReturnValue)

class CallbackObjectUnwrapper:
    """
    A class for unwrapping objects implemented in JS.

    |source| is the JSObject we want to use in native code.
    |target| is an nsCOMPtr of the appropriate type in which we store the result.
    """
    def __init__(self, descriptor, source, target, exceptionCode,
                 sourceDescription, codeOnFailure=None):
        if codeOnFailure is None:
            codeOnFailure = (
                'ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "%s", "%s");\n'
                '%s' % (sourceDescription, descriptor.interface.identifier.name,
                        exceptionCode))
        self.descriptor = descriptor
        self.substitution = { "nativeType" : descriptor.nativeType,
                              "source" : source,
                              "target" : target,
                              "codeOnFailure" : CGIndenter(CGGeneric(codeOnFailure)).define() }

    def __str__(self):
        checkObjectType = CGIfWrapper(
            CGGeneric(self.substitution["codeOnFailure"]),
            "!IsConvertibleToCallbackInterface(cx, %(source)s)" %
            self.substitution).define() + "\n\n"
        if self.descriptor.workers:
            return checkObjectType + string.Template(
                "${target} = ${source};"
                ).substitute(self.substitution)

        return checkObjectType + string.Template(
            """nsISupports* supp = nullptr;
if (XPCConvert::GetISupportsFromJSObject(${source}, &supp)) {
  nsCOMPtr<nsIXPConnectWrappedNative> xpcwn = do_QueryInterface(supp);
  if (xpcwn) {
    supp = xpcwn->Native();
  }
}

const nsIID& iid = NS_GET_IID(${nativeType});
nsRefPtr<nsXPCWrappedJS> wrappedJS;
nsresult rv = nsXPCWrappedJS::GetNewOrUsed(${source}, iid,
                                           supp, getter_AddRefs(wrappedJS));
if (NS_FAILED(rv) || !wrappedJS) {
${codeOnFailure}
}

// Use a temp nsCOMPtr for the null-check, because ${target} might be
// OwningNonNull, not an nsCOMPtr.
nsCOMPtr<${nativeType}> tmp = do_QueryObject(wrappedJS.get());
if (!tmp) {
${codeOnFailure}
}
${target} = tmp.forget();""").substitute(self.substitution)

class JSToNativeConversionInfo():
    """
    An object representing information about a JS-to-native conversion.
    """
    def __init__(self, template, declType=None, holderType=None,
                 dealWithOptional=False, declArgs=None,
                 holderArgs=None):
        """
        template: A string representing the conversion code.  This will have
                  template substitution performed on it as follows:

          ${val} is a handle to the JS::Value in question
          ${mutableVal} is a mutable handle to the JS::Value in question
          ${holderName} replaced by the holder's name, if any
          ${declName} replaced by the declaration's name
          ${haveValue} replaced by an expression that evaluates to a boolean
                       for whether we have a JS::Value.  Only used when
                       defaultValue is not None or when True is passed for
                       checkForValue to instantiateJSToNativeConversion.

        declType: A CGThing representing the native C++ type we're converting
                  to.  This is allowed to be None if the conversion code is
                  supposed to be used as-is.

        holderType: A CGThing representing the type of a "holder" which will
                    hold a possible reference to the C++ thing whose type we
                    returned in declType, or  None if no such holder is needed.

        dealWithOptional: A boolean indicating whether the caller has to do
                          optional-argument handling.  This should only be set
                          to true if the JS-to-native conversion is being done
                          for an optional argument or dictionary member with no
                          default value and if the returned template expects
                          both declType and holderType to be wrapped in
                          Optional<>, with ${declName} and ${holderName}
                          adjusted to point to the Value() of the Optional, and
                          Construct() calls to be made on the Optional<>s as
                          needed.

        declArgs: If not None, the arguments to pass to the ${declName}
                  constructor.  These will have template substitution performed
                  on them so you can use things like ${val}.  This is a
                  single string, not a list of strings.

        holderArgs: If not None, the arguments to pass to the ${holderName}
                    constructor.  These will have template substitution
                    performed on them so you can use things like ${val}.
                    This is a single string, not a list of strings.

        ${declName} must be in scope before the code from 'template' is entered.

        If holderType is not None then ${holderName} must be in scope before
        the code from 'template' is entered.
        """
        assert isinstance(template, str)
        assert declType is None or isinstance(declType, CGThing)
        assert holderType is None or isinstance(holderType, CGThing)
        self.template = template
        self.declType = declType
        self.holderType = holderType
        self.dealWithOptional = dealWithOptional
        self.declArgs = declArgs
        self.holderArgs = holderArgs





def getJSToNativeConversionInfo(type, descriptorProvider, failureCode=None,
                                isDefinitelyObject=False,
                                isMember=False,
                                isOptional=False,
                                invalidEnumValueFatal=True,
                                defaultValue=None,
                                treatNullAs="Default",
                                treatUndefinedAs="Default",
                                isEnforceRange=False,
                                isClamp=False,
                                isNullOrUndefined=False,
                                exceptionCode=None,
                                lenientFloatCode=None,
                                allowTreatNonCallableAsNull=False,
                                isCallbackReturnValue=False,
                                isInUnionReturnValue=False,
                                sourceDescription="value"):
    """
    Get a template for converting a JS value to a native object based on the
    given type and descriptor.  If failureCode is given, then we're actually
    testing whether we can convert the argument to the desired type.  That
    means that failures to convert due to the JS value being the wrong type of
    value need to use failureCode instead of throwing exceptions.  Failures to
    convert that are due to JS exceptions (from toString or valueOf methods) or
    out of memory conditions need to throw exceptions no matter what
    failureCode is.  However what actually happens when throwing an exception
    can be controlled by exceptionCode.  The only requirement on that is that
    exceptionCode must end up doing a return, and every return from this
    function must happen via exceptionCode if exceptionCode is not None.

    If isDefinitelyObject is True, that means we know the value
    isObject() and we have no need to recheck that.

    if isMember is not False, we're being converted from a property of some JS
    object, not from an actual method argument, so we can't rely on our jsval
    being rooted or outliving us in any way.  Callers can pass "Dictionary",
    "Variadic", or "Sequence" to indicate that the conversion is for something
    that is a dictionary member, a variadic argument, or a sequence
    respectively.

    If isOptional is true, then we are doing conversion of an optional
    argument with no default value.

    invalidEnumValueFatal controls whether an invalid enum value conversion
    attempt will throw (if true) or simply return without doing anything (if
    false).

    If defaultValue is not None, it's the IDL default value for this conversion

    If isEnforceRange is true, we're converting an integer and throwing if the
    value is out of range.

    If isClamp is true, we're converting an integer and clamping if the
    value is out of range.

    If lenientFloatCode is not None, it should be used in cases when
    we're a non-finite float that's not unrestricted.

    If allowTreatNonCallableAsNull is true, then [TreatNonCallableAsNull]
    extended attributes on nullable callback functions will be honored.

    If isCallbackReturnValue is "JSImpl" or "Callback", then the declType may be
    adjusted to make it easier to return from a callback.  Since that type is
    never directly observable by any consumers of the callback code, this is OK.
    Furthermore, if isCallbackReturnValue is "JSImpl", that affects the behavior
    of the FailureFatalCastableObjectUnwrapper conversion; this is used for
    implementing auto-wrapping of JS-implemented return values from a
    JS-implemented interface.

    sourceDescription is a description of what this JS value represents, to be
    used in error reporting.  Callers should assume that it might get placed in
    the middle of a sentence.  If it ends up at the beginning of a sentence, its
    first character will be automatically uppercased.

    The return value from this function is a JSToNativeConversionInfo.
    """
    
    
    assert(defaultValue is None or not isOptional)

    
    assert(not isDefinitelyObject or defaultValue is None)

    
    assert not isDefinitelyObject or not isNullOrUndefined

    
    
    
    
    if exceptionCode is None:
        exceptionCode = "return false;"
    
    
    exceptionCodeIndented = CGIndenter(CGGeneric(exceptionCode))

    
    
    def firstCap(string):
        return string[0].upper() + string[1:]

    
    
    def onFailureNotAnObject(failureCode):
        return CGWrapper(
            CGGeneric(
                failureCode or
                ('ThrowErrorMessage(cx, MSG_NOT_OBJECT, "%s");\n'
                 '%s' % (firstCap(sourceDescription), exceptionCode))),
            post="\n")
    def onFailureBadType(failureCode, typeName):
        return CGWrapper(
            CGGeneric(
                failureCode or
                ('ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "%s", "%s");\n'
                 '%s' % (firstCap(sourceDescription), typeName,
                         exceptionCode))),
            post="\n")
    def onFailureNotCallable(failureCode):
        return CGWrapper(
            CGGeneric(
                failureCode or
                ('ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "%s");\n'
                 '%s' % (firstCap(sourceDescription), exceptionCode))),
            post="\n")

    
    
    
    def handleDefault(template, setDefault):
        if defaultValue is None:
            return template
        return CGWrapper(
            CGIndenter(CGGeneric(template)),
            pre="if (${haveValue}) {\n",
            post=("\n"
                  "} else {\n"
                  "%s;\n"
                  "}" %
                  CGIndenter(CGGeneric(setDefault)).define())).define()

    
    
    def handleDefaultNull(template, codeToSetNull):
        if (defaultValue is not None and
            not isinstance(defaultValue, IDLNullValue)):
            raise TypeError("Can't handle non-null default value here")
        return handleDefault(template, codeToSetNull)

    
    
    def wrapObjectTemplate(templateBody, type, codeToSetNull, failureCode=None):
        if isNullOrUndefined:
            assert type.nullable()
            
            
            
            return "%s;" % codeToSetNull

        if not isDefinitelyObject:
            
            
            templateBody = (
                "if (${val}.isObject()) {\n" +
                CGIndenter(CGGeneric(templateBody)).define() + "\n")
            if type.nullable():
                templateBody += (
                    "} else if (${val}.isNullOrUndefined()) {\n"
                    "%s;\n" % CGIndenter(CGGeneric(codeToSetNull)).define())
            templateBody += (
                "} else {\n" +
                CGIndenter(onFailureNotAnObject(failureCode)).define() +
                "}")
            if type.nullable():
                templateBody = handleDefaultNull(templateBody, codeToSetNull)
            else:
                assert(defaultValue is None)

        return templateBody

    
    def handleJSObjectType(type, isMember, failureCode):
        if not isMember:
            if isOptional:
                
                
                declType = CGGeneric("JS::Handle<JSObject*>")
            else:
                declType = CGGeneric("JS::Rooted<JSObject*>")
        else:
            assert (isMember == "Sequence" or isMember == "Variadic" or
                    isMember == "Dictionary")
            
            declType = CGGeneric("JSObject*")
        templateBody = "${declName} = &${val}.toObject();"
        setToNullCode = "${declName} = nullptr;"
        template = wrapObjectTemplate(templateBody, type, setToNullCode,
                                      failureCode)
        return JSToNativeConversionInfo(template, declType=declType,
                                        dealWithOptional=isOptional,
                                        declArgs="cx")

    assert not (isEnforceRange and isClamp) 

    if type.isArray():
        raise TypeError("Can't handle array arguments yet")

    if type.isSequence():
        assert not isEnforceRange and not isClamp

        if failureCode is None:
            notSequence = ('ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "%s");\n'
                           "%s" % (firstCap(sourceDescription), exceptionCode))
        else:
            notSequence = failureCode

        nullable = type.nullable();
        
        if nullable:
            elementType = type.inner.inner
        else:
            elementType = type.inner

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        if isMember or isOptional or nullable or isCallbackReturnValue:
            sequenceClass = "Sequence"
        else:
            sequenceClass = "AutoSequence"

        
        
        elementInfo = getJSToNativeConversionInfo(
            elementType, descriptorProvider, isMember="Sequence",
            exceptionCode=exceptionCode, lenientFloatCode=lenientFloatCode,
            isCallbackReturnValue=isCallbackReturnValue,
            sourceDescription="element of %s" % sourceDescription)
        if elementInfo.dealWithOptional:
            raise TypeError("Shouldn't have optional things in sequences")
        if elementInfo.holderType is not None:
            raise TypeError("Shouldn't need holders for sequences")

        typeName = CGTemplatedType(sequenceClass, elementInfo.declType)
        sequenceType = typeName.define()
        if nullable:
            typeName = CGTemplatedType("Nullable", typeName)
            arrayRef = "${declName}.SetValue()"
        else:
            arrayRef = "${declName}"

        
        templateBody = ("""JS::Rooted<JSObject*> seq(cx, &${val}.toObject());\n
if (!IsArrayLike(cx, seq)) {
%s
}
uint32_t length;
// JS_GetArrayLength actually works on all objects
if (!JS_GetArrayLength(cx, seq, &length)) {
%s
}
%s &arr = %s;
if (!arr.SetCapacity(length)) {
  JS_ReportOutOfMemory(cx);
%s
}
for (uint32_t i = 0; i < length; ++i) {
  JS::Rooted<JS::Value> temp(cx);
  if (!JS_GetElement(cx, seq, i, &temp)) {
%s
  }
  %s& slot = *arr.AppendElement();
""" % (CGIndenter(CGGeneric(notSequence)).define(),
       exceptionCodeIndented.define(),
       sequenceType,
       arrayRef,
       exceptionCodeIndented.define(),
       CGIndenter(exceptionCodeIndented).define(),
       elementInfo.declType.define()))

        templateBody += CGIndenter(CGGeneric(
                string.Template(elementInfo.template).substitute(
                    {
                        "val": "temp",
                        "mutableVal": "&temp",
                        "declName" : "slot",
                        
                        
                        
                        "holderName": "tempHolder",
                        }
                    ))).define()

        templateBody += "\n}"
        templateBody = wrapObjectTemplate(templateBody, type,
                                          "${declName}.SetNull()", notSequence)
        
        
        if not isMember and typeNeedsRooting(elementType, descriptorProvider):
            holderType = CGTemplatedType("SequenceRooter", elementInfo.declType)
            
            
            
            holderArgs = "cx, &%s" % arrayRef
        else:
            holderType = None
            holderArgs = None

        return JSToNativeConversionInfo(templateBody, declType=typeName,
                                        holderType=holderType,
                                        dealWithOptional=isOptional,
                                        holderArgs=holderArgs)

    if type.isUnion():
        if isMember:
            raise TypeError("Can't handle unions as members, we have a "
                            "holderType")
        nullable = type.nullable();
        if nullable:
            type = type.inner

        assert(defaultValue is None or
               (isinstance(defaultValue, IDLNullValue) and nullable))

        unionArgumentObj = "${holderName}"
        if nullable:
            unionArgumentObj += ".ref()"

        memberTypes = type.flatMemberTypes
        names = []

        interfaceMemberTypes = filter(lambda t: t.isNonCallbackInterface(), memberTypes)
        if len(interfaceMemberTypes) > 0:
            interfaceObject = []
            for memberType in interfaceMemberTypes:
                if type.isGeckoInterface():
                    name = memberType.inner.identifier.name
                else:
                    name = memberType.name
                interfaceObject.append(CGGeneric("(failed = !%s.TrySetTo%s(cx, ${val}, ${mutableVal}, tryNext)) || !tryNext" % (unionArgumentObj, name)))
                names.append(name)
            interfaceObject = CGWrapper(CGList(interfaceObject, " ||\n"), pre="done = ", post=";\n", reindent=True)
        else:
            interfaceObject = None

        arrayObjectMemberTypes = filter(lambda t: t.isArray() or t.isSequence(), memberTypes)
        if len(arrayObjectMemberTypes) > 0:
            assert len(arrayObjectMemberTypes) == 1
            memberType = arrayObjectMemberTypes[0]
            name = memberType.name
            arrayObject = CGGeneric("done = (failed = !%s.TrySetTo%s(cx, ${val}, ${mutableVal}, tryNext)) || !tryNext;" % (unionArgumentObj, name))
            arrayObject = CGIfWrapper(arrayObject, "IsArrayLike(cx, argObj)")
            names.append(name)
        else:
            arrayObject = None

        dateObjectMemberTypes = filter(lambda t: t.isDate(), memberTypes)
        if len(dateObjectMemberTypes) > 0:
            assert len(dateObjectMemberTypes) == 1
            memberType = dateObjectMemberTypes[0]
            name = memberType.name
            dateObject = CGGeneric("%s.SetTo%s(cx, ${val}, ${mutableVal});\n"
                                   "done = true;" % (unionArgumentObj, name))
            dateObject = CGIfWrapper(dateObject, "JS_ObjectIsDate(cx, argObj)");
            names.append(name)
        else:
            dateObject = None

        callbackMemberTypes = filter(lambda t: t.isCallback() or t.isCallbackInterface(), memberTypes)
        if len(callbackMemberTypes) > 0:
            assert len(callbackMemberTypes) == 1
            memberType = callbackMemberTypes[0]
            name = memberType.name
            callbackObject = CGGeneric("done = (failed = !%s.TrySetTo%s(cx, ${val}, ${mutableVal}, tryNext)) || !tryNext;" % (unionArgumentObj, name))
            names.append(name)
        else:
            callbackObject = None

        dictionaryMemberTypes = filter(lambda t: t.isDictionary(), memberTypes)
        if len(dictionaryMemberTypes) > 0:
            raise TypeError("No support for unwrapping dictionaries as member "
                            "of a union")
        else:
            dictionaryObject = None

        objectMemberTypes = filter(lambda t: t.isObject(), memberTypes)
        if len(objectMemberTypes) > 0:
            object = CGGeneric("%s.SetToObject(cx, argObj);\n"
                               "done = true;" % unionArgumentObj)
        else:
            object = None

        hasObjectTypes = interfaceObject or arrayObject or dateObject or callbackObject or dictionaryObject or object
        if hasObjectTypes:
            
            assert not object or not (interfaceObject or arrayObject or dateObject or callbackObject or dictionaryObject)
            if arrayObject or dateObject or callbackObject or dictionaryObject:
                
                
                
                assert not (arrayObject and callbackObject)
                assert not (arrayObject and dictionaryObject)
                assert not (dictionaryObject and callbackObject)
                templateBody = CGList([arrayObject, dateObject, callbackObject,
                                       dictionaryObject], " else ")
            else:
                templateBody = None
            if interfaceObject:
                assert not object
                if templateBody:
                    templateBody = CGIfWrapper(templateBody, "!done")
                templateBody = CGList([interfaceObject, templateBody], "\n")
            else:
                templateBody = CGList([templateBody, object], "\n")

            if any([arrayObject, dateObject, callbackObject, dictionaryObject,
                    object]):
                templateBody.prepend(CGGeneric("JS::Rooted<JSObject*> argObj(cx, &${val}.toObject());"))
            templateBody = CGIfWrapper(templateBody, "${val}.isObject()")
        else:
            templateBody = CGGeneric()

        stringTypes = [t for t in memberTypes if t.isString() or t.isEnum()]
        numericTypes = [t for t in memberTypes if t.isNumeric()]
        booleanTypes = [t for t in memberTypes if t.isBoolean()]
        if stringTypes or numericTypes or booleanTypes:
            assert len(stringTypes) <= 1
            assert len(numericTypes) <= 1
            assert len(booleanTypes) <= 1
            
            
            def getStringOrPrimitiveConversion(memberType):
                if memberType.isEnum():
                    name = memberType.inner.identifier.name
                else:
                    name = memberType.name
                return CGGeneric("done = (failed = !%s.TrySetTo%s(cx, ${val}, ${mutableVal}, tryNext)) || !tryNext;\n"
                                 "break;" % (unionArgumentObj, name))
            other = CGList([], "\n")
            stringConversion = map(getStringOrPrimitiveConversion, stringTypes)
            numericConversion = map(getStringOrPrimitiveConversion, numericTypes)
            booleanConversion = map(getStringOrPrimitiveConversion, booleanTypes)
            if stringConversion:
                if booleanConversion:
                    other.append(CGIfWrapper(booleanConversion[0],
                                             "${val}.isBoolean()"))
                if numericConversion:
                    other.append(CGIfWrapper(numericConversion[0],
                                             "${val}.isNumber()"))
                other.append(stringConversion[0])
            elif numericConversion:
                if booleanConversion:
                    other.append(CGIfWrapper(booleanConversion[0],
                                             "${val}.isBoolean()"))
                other.append(numericConversion[0])
            else:
                assert booleanConversion
                other.append(booleanConversion[0])

            other = CGWrapper(CGIndenter(other), pre="do {\n", post="\n} while (0);")
            if hasObjectTypes:
                other = CGWrapper(CGIndenter(other), "{\n", post="\n}")
                if object:
                    join = " else "
                else:
                    other = CGWrapper(other, pre="if (!done) ")
                    join = "\n"
                templateBody = CGList([templateBody, other], join)
            else:
                assert templateBody.define() == ""
                templateBody = other
        else:
            other = None

        templateBody = CGWrapper(templateBody, pre="bool done = false, failed = false, tryNext;\n")
        throw = CGGeneric("if (failed) {\n"
                          "%s\n"
                          "}\n"
                          "if (!done) {\n"
                          '  ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "%s", "%s");\n'
                          "%s\n"
                          "}" % (exceptionCodeIndented.define(),
                                 firstCap(sourceDescription),
                                 ", ".join(names),
                                 exceptionCodeIndented.define()))
        templateBody = CGWrapper(CGIndenter(CGList([templateBody, throw], "\n")), pre="{\n", post="\n}")

        typeName = type.name
        argumentTypeName = typeName + "Argument"
        if nullable:
            typeName = "Nullable<" + typeName + " >"

        def handleNull(templateBody, setToNullVar, extraConditionForNull=""):
            null = CGGeneric("if (%s${val}.isNullOrUndefined()) {\n"
                             "  %s.SetNull();\n"
                             "}" % (extraConditionForNull, setToNullVar))
            templateBody = CGWrapper(CGIndenter(templateBody), pre="{\n", post="\n}")
            return CGList([null, templateBody], " else ")

        if type.hasNullableType:
            templateBody = handleNull(templateBody, unionArgumentObj)

        declType = CGGeneric(typeName)
        holderType = CGGeneric(argumentTypeName)

        
        
        
        
        declLoc = "${declName}"
        constructDecl = None
        if nullable:
            if isOptional:
                holderArgs = "${declName}.Value().SetValue()"
                declType = CGTemplatedType("Optional", declType)
                constructDecl = CGGeneric("${declName}.Construct();")
                declLoc = "${declName}.Value()"
            else:
                holderArgs = "${declName}.SetValue()"
            holderType = CGTemplatedType("Maybe", holderType)
            constructHolder = CGGeneric("${holderName}.construct(%s);" % holderArgs)
            
            holderArgs = None
        else:
            holderArgs = "${declName}"
            constructHolder = None

        templateBody = CGList([constructHolder, templateBody], "\n")
        if nullable:
            if defaultValue:
                assert(isinstance(defaultValue, IDLNullValue))
                valueMissing = "!(${haveValue}) || "
            else:
                valueMissing = ""
            templateBody = handleNull(templateBody, declLoc,
                                      extraConditionForNull=valueMissing)
        templateBody = CGList([constructDecl, templateBody], "\n")

        return JSToNativeConversionInfo(templateBody.define(),
                                        declType=declType,
                                        holderType=holderType,
                                        holderArgs=holderArgs,
                                        dealWithOptional=isOptional and not nullable)

    if type.isGeckoInterface():
        assert not isEnforceRange and not isClamp

        descriptor = descriptorProvider.getDescriptor(
            type.unroll().inner.identifier.name)

        if descriptor.nativeType == 'JSObject':
            
            assert descriptor.workers
            return handleJSObjectType(type, isMember, failureCode)

        if (descriptor.interface.isCallback() and
            descriptor.interface.identifier.name != "EventListener"):
            if descriptor.workers:
                return handleJSObjectType(type, isMember, failureCode)

            name = descriptor.interface.identifier.name
            if type.nullable() or isCallbackReturnValue:
                declType = CGGeneric("nsRefPtr<%s>" % name);
            else:
                declType = CGGeneric("OwningNonNull<%s>" % name)
            conversion = (
                "  ${declName} = new %s(&${val}.toObject());\n" % name)

            template = wrapObjectTemplate(conversion, type,
                                          "${declName} = nullptr",
                                          failureCode)
            return JSToNativeConversionInfo(template, declType=declType,
                                            dealWithOptional=isOptional)

        
        

        
        
        
        argIsPointer = (type.nullable() or type.unroll().inner.isExternal() or
                        isCallbackReturnValue)

        
        
        
        
        
        
        
        forceOwningType = ((descriptor.interface.isCallback() and
                            not descriptor.workers) or
                           isMember or
                           isInUnionReturnValue or
                           isCallbackReturnValue)

        typeName = descriptor.nativeType
        typePtr = typeName + "*"

        
        
        
        
        

        
        holderType = None
        if argIsPointer:
            if forceOwningType:
                declType = "nsRefPtr<" + typeName + ">"
            else:
                declType = typePtr
        else:
            if forceOwningType:
                declType = "OwningNonNull<" + typeName + ">"
            else:
                declType = "NonNull<" + typeName + ">"

        templateBody = ""
        if descriptor.interface.isCallback():
            
            callbackConversion = str(CallbackObjectUnwrapper(
                    descriptor,
                    "callbackObj",
                    "${declName}",
                    exceptionCode,
                    firstCap(sourceDescription),
                    codeOnFailure=failureCode))
            templateBody += (
                "{ // Scope for callbackObj\n"
                "  JS::Rooted<JSObject*> callbackObj(cx, &${val}.toObject());\n" +
                CGIndenter(CGGeneric(callbackConversion)).define() +
                "\n}")
        elif not descriptor.skipGen and not descriptor.interface.isConsequential() and not descriptor.interface.isExternal():
            if failureCode is not None:
                templateBody += str(CastableObjectUnwrapper(
                        descriptor,
                        "&${val}.toObject()",
                        "${declName}",
                        failureCode))
            else:
                templateBody += str(FailureFatalCastableObjectUnwrapper(
                        descriptor,
                        "&${val}.toObject()",
                        "${declName}",
                        exceptionCode,
                        isCallbackReturnValue,
                        firstCap(sourceDescription)))
        elif descriptor.workers:
            return handleJSObjectType(type, isMember, failureCode)
        else:
            
            
            
            
            
            if forceOwningType:
                
                
                templateBody += "nsRefPtr<" + typeName + "> ${holderName};\n"
            else:
                holderType = "nsRefPtr<" + typeName + ">"
            templateBody += (
                "JS::Rooted<JS::Value> tmpVal(cx, ${val});\n" +
                typePtr + " tmp;\n"
                "if (NS_FAILED(UnwrapArg<" + typeName + ">(cx, ${val}, &tmp, static_cast<" + typeName + "**>(getter_AddRefs(${holderName})), tmpVal.address()))) {\n")
            templateBody += CGIndenter(onFailureBadType(failureCode,
                                                        descriptor.interface.identifier.name)).define()
            templateBody += ("}\n"
                "MOZ_ASSERT(tmp);\n")

            if not isDefinitelyObject and not forceOwningType:
                
                
                templateBody += (
                    "if (tmpVal != ${val} && !${holderName}) {\n"
                    "  // We have to have a strong ref, because we got this off\n"
                    "  // some random object that might get GCed\n"
                    "  ${holderName} = tmp;\n"
                    "}\n")

            
            templateBody += "${declName} = tmp;"

        
        
        
        templateBody = wrapObjectTemplate(templateBody, type,
                                          "${declName} = nullptr", failureCode)

        declType = CGGeneric(declType)
        if holderType is not None:
            holderType = CGGeneric(holderType)
        return JSToNativeConversionInfo(templateBody,
                                        declType=declType,
                                        holderType=holderType,
                                        dealWithOptional=isOptional)

    if type.isSpiderMonkeyInterface():
        assert not isEnforceRange and not isClamp
        name = type.name
        arrayType = CGGeneric(name)
        declType = arrayType
        if type.nullable():
            declType = CGTemplatedType("Nullable", declType)
            objRef = "${declName}.SetValue()"
        else:
            objRef = "${declName}"

        template = (
            "if (!%s.Init(&${val}.toObject())) {\n"
            "%s" 
            "}\n" %
            (objRef,
             CGIndenter(onFailureBadType(failureCode, type.name)).define()))
        template = wrapObjectTemplate(template, type, "${declName}.SetNull()",
                                      failureCode)
        if not isMember:
            
            
            
            
            
            if isOptional:
                holderType = CGTemplatedType("TypedArrayRooter", arrayType)
                
                
                
                
                
                
                holderArgs = "cx, &%s" % objRef
                declArgs = None
            else:
                holderType = None
                holderArgs = None
                declType = CGTemplatedType("RootedTypedArray", declType)
                declArgs = "cx"
        else:
            holderType = None
            holderArgs = None
            declArgs = None
        return JSToNativeConversionInfo(template,
                                        declType=declType,
                                        holderType=holderType,
                                        dealWithOptional=isOptional,
                                        declArgs=declArgs,
                                        holderArgs=holderArgs)

    if type.isDOMString():
        assert not isEnforceRange and not isClamp

        treatAs = {
            "Default": "eStringify",
            "EmptyString": "eEmpty",
            "Null": "eNull",
            
            
            "Missing": "eStringify"
        }
        if type.nullable():
            
            treatNullAs = "Null"
            
            
            if treatUndefinedAs == "Default":
                treatUndefinedAs = "Null"
        nullBehavior = treatAs[treatNullAs]
        undefinedBehavior = treatAs[treatUndefinedAs]

        def getConversionCode(varName):
            conversionCode = (
                "if (!ConvertJSValueToString(cx, ${val}, ${mutableVal}, %s, %s, %s)) {\n"
                "%s\n"
                "}" % (nullBehavior, undefinedBehavior, varName,
                       exceptionCodeIndented.define()))
            if defaultValue is None:
                return conversionCode

            if isinstance(defaultValue, IDLNullValue):
                assert(type.nullable())
                return handleDefault(conversionCode,
                                     "%s.SetNull()" % varName)
            return handleDefault(
                conversionCode,
                ("static const PRUnichar data[] = { %s };\n"
                 "%s.SetData(data, ArrayLength(data) - 1)" %
                 (", ".join(["'" + char + "'" for char in defaultValue.value] + ["0"]),
                  varName)))

        if isMember:
            
            
            declType = CGGeneric("nsString")
            return JSToNativeConversionInfo(
                "{\n"
                "  FakeDependentString str;\n"
                "%s\n"
                "  ${declName} = str;\n"
                "}\n" % CGIndenter(CGGeneric(getConversionCode("str"))).define(),
                declType=declType, dealWithOptional=isOptional)

        if isOptional:
            declType = "Optional<nsAString>"
        elif isInUnionReturnValue:
            declType = "nsString"
        else:
            declType = "NonNull<nsAString>"

        
        return JSToNativeConversionInfo(
            "%s\n"
            "${declName} = &${holderName};" %
            getConversionCode("${holderName}"),
            declType=CGGeneric(declType),
            holderType=CGGeneric("FakeDependentString"))

    if type.isByteString():
        assert not isEnforceRange and not isClamp

        nullable = toStringBool(type.nullable())

        conversionCode = (
            "if (!ConvertJSValueToByteString(cx, ${val}, ${mutableVal},"
            " %s, ${declName})) {\n"
            "%s\n"
            "}" % (nullable, exceptionCodeIndented.define()))
        
        assert defaultValue is None

        return JSToNativeConversionInfo(
            conversionCode,
            declType=CGGeneric("nsCString"),
            dealWithOptional=isOptional)

    if type.isEnum():
        assert not isEnforceRange and not isClamp

        enumName = type.unroll().inner.identifier.name
        declType = CGGeneric(enumName)
        if type.nullable():
            declType = CGTemplatedType("Nullable", declType)
            declType = declType.define()
            enumLoc = "${declName}.SetValue()"
        else:
            enumLoc = "${declName}"
            declType = declType.define()

        if invalidEnumValueFatal:
            handleInvalidEnumValueCode = "  MOZ_ASSERT(index >= 0);\n"
        else:
            
            
            
            
            assert exceptionCode == "return false;"
            handleInvalidEnumValueCode = (
                "  if (index < 0) {\n"
                "    return true;\n"
                "  }\n")
            
        template = (
            "{\n"
            "  bool ok;\n"
            '  int index = FindEnumStringIndex<%(invalidEnumValueFatal)s>(cx, ${val}, %(values)s, "%(enumtype)s", "%(sourceDescription)s", &ok);\n'
            "  if (!ok) {\n"
            "%(exceptionCode)s\n"
            "  }\n"
            "%(handleInvalidEnumValueCode)s"
            "  %(enumLoc)s = static_cast<%(enumtype)s>(index);\n"
            "}" % { "enumtype" : enumName,
                      "values" : enumName + "Values::" + ENUM_ENTRY_VARIABLE_NAME,
       "invalidEnumValueFatal" : toStringBool(invalidEnumValueFatal),
  "handleInvalidEnumValueCode" : handleInvalidEnumValueCode,
               "exceptionCode" : CGIndenter(exceptionCodeIndented).define(),
                     "enumLoc" : enumLoc,
           "sourceDescription" : firstCap(sourceDescription)
                    })

        setNull = "${declName}.SetNull();"

        if type.nullable():
            template = CGIfElseWrapper("${val}.isNullOrUndefined()",
                                       CGGeneric(setNull),
                                       CGGeneric(template)).define()

        if defaultValue is not None:
            if isinstance(defaultValue, IDLNullValue):
                assert type.nullable()
                template = handleDefault(template, setNull)
            else:
                assert(defaultValue.type.tag() == IDLType.Tags.domstring)
                template = handleDefault(template,
                                         ("%s = %s::%s" %
                                          (enumLoc, enumName,
                                           getEnumValueName(defaultValue.value))))
        return JSToNativeConversionInfo(template, declType=CGGeneric(declType),
                                        dealWithOptional=isOptional)

    if type.isCallback():
        assert not isEnforceRange and not isClamp
        assert not type.treatNonCallableAsNull() or type.nullable()

        if descriptorProvider.workers:
            if isMember:
                raise NoSuchDescriptorError("Can't handle member callbacks in "
                                            "workers; need to sort out rooting"
                                            "issues")
            declType = CGGeneric("JS::Rooted<JSObject*>")
            conversion = "  ${declName} = &${val}.toObject();\n"
            declArgs = "cx"
        else:
            name = type.unroll().identifier.name
            if type.nullable():
                declType = CGGeneric("nsRefPtr<%s>" % name);
            else:
                declType = CGGeneric("OwningNonNull<%s>" % name)
            conversion = (
                "  ${declName} = new %s(&${val}.toObject());\n" % name)
            declArgs = None

        if allowTreatNonCallableAsNull and type.treatNonCallableAsNull():
            haveCallable = "JS_ObjectIsCallable(cx, &${val}.toObject())"
            if not isDefinitelyObject:
                haveCallable = "${val}.isObject() && " + haveCallable
            if defaultValue is not None:
                assert(isinstance(defaultValue, IDLNullValue))
                haveCallable = "${haveValue} && " + haveCallable
            template = (
                ("if (%s) {\n" % haveCallable) +
                conversion +
                "} else {\n"
                "  ${declName} = nullptr;\n"
                "}")
        else:
            template = wrapObjectTemplate(
                "if (JS_ObjectIsCallable(cx, &${val}.toObject())) {\n" +
                conversion +
                "} else {\n"
                "%s"
                "}" % CGIndenter(onFailureNotCallable(failureCode)).define(),
                type,
                "${declName} = nullptr",
                failureCode)
        return JSToNativeConversionInfo(template, declType=declType,
                                        dealWithOptional=isOptional,
                                        declArgs=declArgs)

    if type.isAny():
        assert not isEnforceRange and not isClamp

        declArgs = None
        if (isMember == "Variadic" or isMember == "Sequence" or
            isMember == "Dictionary"):
            
            declType = "JS::Value"
        else:
            assert not isMember
            if isOptional:
                
                
                declType = "JS::Handle<JS::Value>"
            else:
                declType = "JS::Rooted<JS::Value>"
            declArgs = "cx"

        templateBody = "${declName} = ${val};"
        nullHandling = "${declName} = JS::NullValue()"

        templateBody = handleDefaultNull(templateBody, nullHandling)
        return JSToNativeConversionInfo(templateBody,
                                        declType=CGGeneric(declType),
                                        dealWithOptional=isOptional,
                                        declArgs=declArgs)

    if type.isObject():
        assert not isEnforceRange and not isClamp
        return handleJSObjectType(type, isMember, failureCode)

    if type.isDictionary():
        if failureCode is not None and not isDefinitelyObject:
            raise TypeError("Can't handle dictionaries when failureCode is "
                            "not None and we don't know we're an object")

        
        assert not type.nullable()
        
        
        assert not isOptional

        typeName = CGDictionary.makeDictionaryName(type.inner)
        actualTypeName = typeName

        declType = CGGeneric(actualTypeName)

        
        
        
        
        
        if (not isNullOrUndefined and not isDefinitelyObject and
            defaultValue is not None):
            assert(isinstance(defaultValue, IDLNullValue))
            val = "(${haveValue}) ? ${val} : JS::NullHandleValue"
        else:
            val = "${val}"

        if failureCode is not None:
            assert isDefinitelyObject
            
            
            template = CGIfWrapper(
                CGGeneric(failureCode),
                "!IsObjectValueConvertibleToDictionary(cx, ${val})").define() + "\n\n"
        else:
            template = ""

        template += ('if (!${declName}.Init(cx, %s, "%s")) {\n'
                     "%s\n"
                     "}" % (val, firstCap(sourceDescription),
                            exceptionCodeIndented.define()))

        
        
        if not isMember and typeNeedsRooting(type, descriptorProvider):
            declType = CGTemplatedType("RootedDictionary", declType);
            declArgs = "cx"
        else:
            declArgs = None

        return JSToNativeConversionInfo(template, declType=declType,
                                        declArgs=declArgs)

    if type.isVoid():
        assert not isOptional
        
        
        return JSToNativeConversionInfo("")

    if type.isDate():
        assert not isEnforceRange and not isClamp

        declType = CGGeneric("Date")
        if type.nullable():
            declType = CGTemplatedType("Nullable", declType)
            dateVal = "${declName}.SetValue()"
        else:
            dateVal = "${declName}"

        if failureCode is None:
            notDate = ('ThrowErrorMessage(cx, MSG_NOT_DATE, "%s");\n'
                       "%s" % (firstCap(sourceDescription), exceptionCode))
        else:
            notDate = failureCode

        conversion = (
            "if (!JS_ObjectIsDate(cx, &${val}.toObject()) ||\n"
            "    !%s.SetTimeStamp(cx, &${val}.toObject())) {\n"
            "%s\n"
            "}" %
            (dateVal, CGIndenter(CGGeneric(notDate)).define()))

        conversion = wrapObjectTemplate(conversion, type,
                                        "${declName}.SetNull()", notDate)
        return JSToNativeConversionInfo(conversion,
                                        declType=declType,
                                        dealWithOptional=isOptional)

    if not type.isPrimitive():
        raise TypeError("Need conversion for argument type '%s'" % str(type))

    typeName = builtinNames[type.tag()]

    conversionBehavior = "eDefault"
    if isEnforceRange:
        assert type.isInteger()
        conversionBehavior = "eEnforceRange"
    elif isClamp:
        assert type.isInteger()
        conversionBehavior = "eClamp"

    if type.nullable():
        declType = CGGeneric("Nullable<" + typeName + ">")
        writeLoc = "${declName}.SetValue()"
        readLoc = "${declName}.Value()"
        nullCondition = "${val}.isNullOrUndefined()"
        if defaultValue is not None and isinstance(defaultValue, IDLNullValue):
            nullCondition = "!(${haveValue}) || " + nullCondition
        template = (
            "if (%s) {\n"
            "  ${declName}.SetNull();\n"
            "} else if (!ValueToPrimitive<%s, %s>(cx, ${val}, &%s)) {\n"
            "%s\n"
            "}" % (nullCondition, typeName, conversionBehavior,
                   writeLoc, exceptionCodeIndented.define()))
    else:
        assert(defaultValue is None or
               not isinstance(defaultValue, IDLNullValue))
        writeLoc = "${declName}"
        readLoc = writeLoc
        template = (
            "if (!ValueToPrimitive<%s, %s>(cx, ${val}, &%s)) {\n"
            "%s\n"
            "}" % (typeName, conversionBehavior, writeLoc,
                   exceptionCodeIndented.define()))
        declType = CGGeneric(typeName)

    if type.isFloat() and not type.isUnrestricted():
        if lenientFloatCode is not None:
            nonFiniteCode = CGIndenter(CGGeneric(lenientFloatCode)).define()
        else:
            nonFiniteCode = ('  ThrowErrorMessage(cx, MSG_NOT_FINITE, "%s");\n'
                             "%s" % (firstCap(sourceDescription),
                                     exceptionCodeIndented.define()))
        template += (" else if (!mozilla::IsFinite(%s)) {\n"
                     "  // Note: mozilla::IsFinite will do the right thing\n"
                     "  //       when passed a non-finite float too.\n"
                     "%s\n"
                     "}" % (readLoc, nonFiniteCode))

    if (defaultValue is not None and
        
        not isinstance(defaultValue, IDLNullValue)):
        tag = defaultValue.type.tag()
        if tag in numericSuffixes:
            
            defaultStr = numericValue(tag, defaultValue.value)
        else:
            assert(tag == IDLType.Tags.bool)
            defaultStr = toStringBool(defaultValue.value)
        template = CGWrapper(CGIndenter(CGGeneric(template)),
                             pre="if (${haveValue}) {\n",
                             post=("\n"
                                   "} else {\n"
                                   "  %s = %s;\n"
                                   "}" % (writeLoc, defaultStr))).define()

    return JSToNativeConversionInfo(template, declType=declType,
                                    dealWithOptional=isOptional)

def instantiateJSToNativeConversion(info, replacements, checkForValue=False):
    """
    Take a JSToNativeConversionInfo as returned by getJSToNativeConversionInfo
    and a set of replacements as required by the strings in such an object, and
    generate code to convert into stack C++ types.

    If checkForValue is True, then the conversion will get wrapped in
    a check for ${haveValue}.
    """
    (templateBody, declType, holderType, dealWithOptional) = (
        info.template, info.declType, info.holderType, info.dealWithOptional)

    if dealWithOptional and not checkForValue:
        raise TypeError("Have to deal with optional things, but don't know how")
    if checkForValue and declType is None:
        raise TypeError("Need to predeclare optional things, so they will be "
                        "outside the check for big enough arg count!");

    
    
    
    def getArgsCGThing(args):
        return CGGeneric(string.Template(args).substitute(replacements))

    result = CGList([], "\n")
    
    replacements = dict(replacements)
    originalDeclName = replacements["declName"]
    if declType is not None:
        if dealWithOptional:
            replacements["declName"] = "%s.Value()" % originalDeclName
            declType = CGTemplatedType("Optional", declType)
            declCtorArgs = None
        elif info.declArgs is not None:
            declCtorArgs = CGWrapper(getArgsCGThing(info.declArgs),
                                     pre="(", post=")")
        else:
            declCtorArgs = None
        result.append(
            CGList([declType, CGGeneric(" "),
                    CGGeneric(originalDeclName),
                    declCtorArgs, CGGeneric(";")]))

    originalHolderName = replacements["holderName"]
    if holderType is not None:
        if dealWithOptional:
            replacements["holderName"] = "%s.ref()" % originalHolderName
            holderType = CGTemplatedType("Maybe", holderType)
            holderCtorArgs = None
        elif info.holderArgs is not None:
            holderCtorArgs = CGWrapper(getArgsCGThing(info.holderArgs),
                                       pre="(", post=")")
        else:
            holderCtorArgs = None
        result.append(
            CGList([holderType, CGGeneric(" "),
                    CGGeneric(originalHolderName),
                    holderCtorArgs, CGGeneric(";")]))

    conversion = CGGeneric(
            string.Template(templateBody).substitute(replacements)
            )

    if checkForValue:
        if dealWithOptional:
            declConstruct = CGIndenter(
                CGGeneric("%s.Construct(%s);" %
                          (originalDeclName,
                           getArgsCGThing(info.declArgs).define() if
                           info.declArgs else "")))
            if holderType is not None:
                holderConstruct = CGIndenter(
                    CGGeneric("%s.construct(%s);" %
                              (originalHolderName,
                               getArgsCGThing(info.holderArgs).define() if
                               info.holderArgs else "")))
            else:
                holderConstruct = None
        else:
            declConstruct = None
            holderConstruct = None

        conversion = CGList(
            [CGGeneric(
                    string.Template("if (${haveValue}) {").substitute(
                        replacements
                        )),
             declConstruct,
             holderConstruct,
             CGIndenter(conversion),
             CGGeneric("}")],
            "\n")

    result.append(conversion)
    
    
    result.append(CGGeneric(""))
    return result

def convertConstIDLValueToJSVal(value):
    if isinstance(value, IDLNullValue):
        return "JSVAL_NULL"
    tag = value.type.tag()
    if tag in [IDLType.Tags.int8, IDLType.Tags.uint8, IDLType.Tags.int16,
               IDLType.Tags.uint16, IDLType.Tags.int32]:
        return "INT_TO_JSVAL(%s)" % (value.value)
    if tag == IDLType.Tags.uint32:
        return "UINT_TO_JSVAL(%sU)" % (value.value)
    if tag in [IDLType.Tags.int64, IDLType.Tags.uint64]:
        return "DOUBLE_TO_JSVAL(%s)" % numericValue(tag, value.value)
    if tag == IDLType.Tags.bool:
        return "JSVAL_TRUE" if value.value else "JSVAL_FALSE"
    if tag in [IDLType.Tags.float, IDLType.Tags.double]:
        return "DOUBLE_TO_JSVAL(%s)" % (value.value)
    raise TypeError("Const value of unhandled type: %s" % value.type)

class CGArgumentConverter(CGThing):
    """
    A class that takes an IDL argument object and its index in the
    argument list and generates code to unwrap the argument to the
    right native type.

    argDescription is a description of the argument for error-reporting
    purposes.  Callers should assume that it might get placed in the middle of a
    sentence.  If it ends up at the beginning of a sentence, its first character
    will be automatically uppercased.
    """
    def __init__(self, argument, index, descriptorProvider,
                 argDescription,
                 invalidEnumValueFatal=True, lenientFloatCode=None,
                 allowTreatNonCallableAsNull=False):
        CGThing.__init__(self)
        self.argument = argument
        self.argDescription = argDescription
        assert(not argument.defaultValue or argument.optional)

        replacer = {
            "index" : index,
            "argc" : "args.length()"
            }
        self.replacementVariables = {
            "declName" : "arg%d" % index,
            "holderName" : ("arg%d" % index) + "_holder",
            "obj" : "obj"
            }
        self.replacementVariables["val"] = string.Template(
            "args[${index}]"
            ).substitute(replacer)
        self.replacementVariables["mutableVal"] = self.replacementVariables["val"]
        if argument.treatUndefinedAs == "Missing":
            haveValueCheck = "args.hasDefined(${index})"
        else:
            haveValueCheck = "${index} < args.length()"
        haveValueCheck = string.Template(haveValueCheck).substitute(replacer)
        self.replacementVariables["haveValue"] = haveValueCheck
        self.descriptorProvider = descriptorProvider
        if self.argument.optional and not self.argument.defaultValue:
            self.argcAndIndex = replacer
        else:
            self.argcAndIndex = None
        self.invalidEnumValueFatal = invalidEnumValueFatal
        self.lenientFloatCode = lenientFloatCode
        self.allowTreatNonCallableAsNull = allowTreatNonCallableAsNull

    def define(self):
        typeConversion = getJSToNativeConversionInfo(
            self.argument.type,
            self.descriptorProvider,
            isOptional=(self.argcAndIndex is not None and
                        not self.argument.variadic),
            invalidEnumValueFatal=self.invalidEnumValueFatal,
            defaultValue=self.argument.defaultValue,
            treatNullAs=self.argument.treatNullAs,
            treatUndefinedAs=self.argument.treatUndefinedAs,
            isEnforceRange=self.argument.enforceRange,
            isClamp=self.argument.clamp,
            lenientFloatCode=self.lenientFloatCode,
            isMember="Variadic" if self.argument.variadic else False,
            allowTreatNonCallableAsNull=self.allowTreatNonCallableAsNull,
            sourceDescription=self.argDescription)

        if not self.argument.variadic:
            return instantiateJSToNativeConversion(
                typeConversion,
                self.replacementVariables,
                self.argcAndIndex is not None).define()

        
        if typeConversion.dealWithOptional:
            raise TypeError("Shouldn't have optional things in variadics")
        if typeConversion.holderType is not None:
            raise TypeError("Shouldn't need holders for variadics")

        replacer = dict(self.argcAndIndex, **self.replacementVariables)
        replacer["seqType"] = CGTemplatedType("AutoSequence",
                                              typeConversion.declType).define()
        if typeNeedsRooting(self.argument.type, self.descriptorProvider):
            rooterDecl = ("SequenceRooter<%s> ${holderName}(cx, &${declName});\n" %
                          typeConversion.declType.define())
        else:
            rooterDecl = ""
        replacer["elemType"] = typeConversion.declType.define()

        
        variadicConversion = string.Template("${seqType} ${declName};\n" +
                                             rooterDecl +
                                             """if (${argc} > ${index}) {
  if (!${declName}.SetCapacity(${argc} - ${index})) {
    JS_ReportOutOfMemory(cx);
    return false;
  }
  for (uint32_t variadicArg = ${index}; variadicArg < ${argc}; ++variadicArg) {
    ${elemType}& slot = *${declName}.AppendElement();
""").substitute(replacer)

        val = string.Template("args[variadicArg]").substitute(replacer)
        variadicConversion += CGIndenter(CGGeneric(
                string.Template(typeConversion.template).substitute(
                    {
                        "val" : val,
                        "mutableVal" : val,
                        "declName" : "slot",
                        
                        
                        
                        "holderName": "tempHolder",
                        
                        "obj": replacer["obj"]
                        }
                    )), 4).define()

        variadicConversion += ("\n"
                               "  }\n"
                               "}")
        return variadicConversion

sequenceWrapLevel = 0

def getWrapTemplateForType(type, descriptorProvider, result, successCode,
                           isCreator, exceptionCode, typedArraysAreStructs):
    """
    Reflect a C++ value stored in "result", of IDL type "type" into JS.  The
    "successCode" is the code to run once we have successfully done the
    conversion and must guarantee that execution of the conversion template
    stops once the successCode has executed (e.g. by doing a 'return', or by
    doing a 'break' if the entire conversion template is inside a block that
    the 'break' will exit).

    If typedArraysAreStructs is true, then if the type is a typed array,
    "result" is one of the dom::TypedArray subclasses, not a JSObject*.

    The resulting string should be used with string.Template.  It
    needs the following keys when substituting:

      jsvalHandle: something that can be passed to methods taking a
                   JS::MutableHandle<JS::Value>.  This can be a
                   JS::MutableHandle<JS::Value> or a JS::Rooted<JS::Value>*.
      jsvalRef: something that can have .address() called on it to get a
                JS::Value* and .set() called on it to set it to a JS::Value.
                This can be a JS::MutableHandle<JS::Value> or a
                JS::Rooted<JS::Value>.
      obj: a JS::Handle<JSObject*>.

    Returns (templateString, infallibility of conversion template)
    """
    if successCode is None:
        successCode = "return true;"

    
    
    exceptionCodeIndented = CGIndenter(CGGeneric(exceptionCode))

    def setValue(value, callWrapValue=None):
        """
        Returns the code to set the jsval to value.

        "callWrapValue" can be set to the following values:
          * None: no wrapping will be done.
          * "object": will wrap using MaybeWrapObjectValue.
          * "objectOrNull": will wrap using MaybeWrapObjectOrNullValue.
          * "nonDOMObject": will wrap using MaybeWrapNonDOMObjectValue.
          * "nonDOMObjectOrNull": will wrap using MaybeWrapNonDOMObjectOrNullValue
          * "value": will wrap using MaybeWrapValue.
        """
        if not callWrapValue:
            tail = successCode
        else:
            methodMap = {
                "object": "MaybeWrapObjectValue",
                "objectOrNull": "MaybeWrapObjectOrNullValue",
                "nonDOMObject": "MaybeWrapNonDOMObjectValue",
                "nonDOMObjectOrNull": "MaybeWrapNonDOMObjectOrNullValue",
                "value": "MaybeWrapValue"
                }
            tail = (("if (!%s(cx, ${jsvalHandle})) {\n"
                     "%s\n" % (methodMap[callWrapValue],
                               exceptionCodeIndented.define())) +
                    "}\n" +
                    successCode)
        return ("${jsvalRef}.set(%s);\n" +
                tail) % (value)

    def wrapAndSetPtr(wrapCall, failureCode=None):
        """
        Returns the code to set the jsval by calling "wrapCall". "failureCode"
        is the code to run if calling "wrapCall" fails 
        """
        if failureCode is None:
            failureCode = exceptionCode
        str = ("if (!%s) {\n" +
               CGIndenter(CGGeneric(failureCode)).define() + "\n" +
               "}\n" +
               successCode) % (wrapCall)
        return str

    if type is None or type.isVoid():
        return (setValue("JSVAL_VOID"), True)

    if type.isArray():
        raise TypeError("Can't handle array return values yet")

    if type.isSequence():
        if type.nullable():
            
            (recTemplate, recInfall) = getWrapTemplateForType(type.inner, descriptorProvider,
                                                              "%s.Value()" % result, successCode,
                                                              isCreator, exceptionCode,
                                                              typedArraysAreStructs)
            return ("""
if (%s.IsNull()) {
%s
}
%s""" % (result, CGIndenter(CGGeneric(setValue("JSVAL_NULL"))).define(), recTemplate), recInfall)

        
        
        
        
        global sequenceWrapLevel
        index = "sequenceIdx%d" % sequenceWrapLevel
        sequenceWrapLevel += 1
        innerTemplate = wrapForType(
            type.inner, descriptorProvider,
            {
                'result' :  "%s[%s]" % (result, index),
                'successCode': "break;",
                'jsvalRef': "tmp",
                'jsvalHandle': "&tmp",
                'isCreator': isCreator,
                'exceptionCode': exceptionCode,
                'obj': "returnArray"
                }
            )
        sequenceWrapLevel -= 1
        innerTemplate = CGIndenter(CGGeneric(innerTemplate), 6).define()
        return (("""
uint32_t length = %s.Length();
JS::Rooted<JSObject*> returnArray(cx, JS_NewArrayObject(cx, length, nullptr));
if (!returnArray) {
%s
}
// Scope for 'tmp'
{
  JS::Rooted<JS::Value> tmp(cx);
  for (uint32_t %s = 0; %s < length; ++%s) {
    // Control block to let us common up the JS_DefineElement calls when there
    // are different ways to succeed at wrapping the object.
    do {
%s
    } while (0);
    if (!JS_DefineElement(cx, returnArray, %s, tmp,
                          nullptr, nullptr, JSPROP_ENUMERATE)) {
%s
    }
  }
}\n""" % (result, exceptionCodeIndented.define(),
          index, index, index,
          innerTemplate, index,
          CGIndenter(exceptionCodeIndented, 4).define())) +
                setValue("JS::ObjectValue(*returnArray)"), False)

    if (type.isGeckoInterface() and
        (not type.isCallbackInterface() or
         type.unroll().inner.identifier.name == "EventListener")):
        descriptor = descriptorProvider.getDescriptor(type.unroll().inner.identifier.name)
        if type.nullable():
            wrappingCode = ("if (!%s) {\n" % (result) +
                            CGIndenter(CGGeneric(setValue("JSVAL_NULL"))).define() + "\n" +
                            "}\n")
        else:
            wrappingCode = ""

        if not descriptor.interface.isExternal() and not descriptor.skipGen:
            if descriptor.wrapperCache:
                assert descriptor.nativeOwnership != 'owned'
                wrapMethod = "WrapNewBindingObject"
            else:
                if not isCreator:
                    raise MethodNotCreatorError(descriptor.interface.identifier.name)
                if descriptor.nativeOwnership == 'owned':
                    wrapMethod = "WrapNewBindingNonWrapperCachedOwnedObject"
                else:
                    wrapMethod = "WrapNewBindingNonWrapperCachedObject"
            wrap = "%s(cx, ${obj}, %s, ${jsvalHandle})" % (wrapMethod, result)
            if not descriptor.hasXPConnectImpls:
                
                
                failed = ("MOZ_ASSERT(JS_IsExceptionPending(cx));\n" +
                          "%s" % exceptionCode)
            else:
                if descriptor.notflattened:
                    raise TypeError("%s has XPConnect impls but not flattened; "
                                    "fallback won't work correctly" %
                                    descriptor.interface.identifier.name)
                
                failed = wrapAndSetPtr("HandleNewBindingWrappingFailure(cx, ${obj}, %s, ${jsvalHandle})" % result)
        else:
            if descriptor.notflattened:
                getIID = "&NS_GET_IID(%s), " % descriptor.nativeType
            else:
                getIID = ""
            wrap = "WrapObject(cx, ${obj}, %s, %s${jsvalHandle})" % (result, getIID)
            failed = None

        wrappingCode += wrapAndSetPtr(wrap, failed)
        return (wrappingCode, False)

    if type.isDOMString():
        if type.nullable():
            return (wrapAndSetPtr("xpc::StringToJsval(cx, %s, ${jsvalRef}.address())" % result), False)
        else:
            return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalRef}.address())" % result), False)

    if type.isByteString():
        if type.nullable():
            return (wrapAndSetPtr("ByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
        else:
            return (wrapAndSetPtr("NonVoidByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)

    if type.isEnum():
        if type.nullable():
            resultLoc = "%s.Value()" % result
        else:
            resultLoc = result
        conversion = ("""{
  // Scope for resultStr
  MOZ_ASSERT(uint32_t(%(result)s) < ArrayLength(%(strings)s));
  JSString* resultStr = JS_NewStringCopyN(cx, %(strings)s[uint32_t(%(result)s)].value, %(strings)s[uint32_t(%(result)s)].length);
  if (!resultStr) {
%(exceptionCode)s
  }
""" % { "result" : resultLoc,
        "strings" : type.unroll().inner.identifier.name + "Values::" + ENUM_ENTRY_VARIABLE_NAME,
        "exceptionCode" : CGIndenter(exceptionCodeIndented).define() } +
        CGIndenter(CGGeneric(setValue("JS::StringValue(resultStr)"))).define() +
                      "\n}")

        if type.nullable():
            conversion = CGIfElseWrapper(
                "%s.IsNull()" % result,
                CGGeneric(setValue("JS::NullValue()", False)),
                CGGeneric(conversion)).define()
        return conversion, False

    if type.isCallback() or type.isCallbackInterface():
        
        
        
        if descriptorProvider.workers:
            return (setValue("JS::ObjectOrNullValue(%s)" % result,
                             "objectOrNull"),
                    False)

        wrapCode = setValue(
            "JS::ObjectValue(*GetCallbackFromCallbackObject(%(result)s))",
            "object")
        if type.nullable():
            wrapCode = (
                "if (%(result)s) {\n" +
                CGIndenter(CGGeneric(wrapCode)).define() + "\n"
                "} else {\n" +
                CGIndenter(CGGeneric(setValue("JS::NullValue()"))).define() + "\n"
                "}")
        wrapCode = wrapCode % { "result": result }
        return wrapCode, False

    if type.isAny():
        
        
        
        return (setValue(result, "value"), False)

    if (type.isObject() or (type.isSpiderMonkeyInterface() and
                            not typedArraysAreStructs)):
        
        
        if type.nullable():
            toValue = "JS::ObjectOrNullValue(%s)"
            if type.isSpiderMonkeyInterface():
                wrapType = "nonDOMObjectOrNull"
            else:
                wrapType = "objectOrNull"
        else:
            toValue = "JS::ObjectValue(*%s)"
            if type.isSpiderMonkeyInterface():
                wrapType = "nonDOMObject"
            else:
                wrapType = "object"
        
        return (setValue(toValue % result, wrapType), False)

    if not (type.isUnion() or type.isPrimitive() or type.isDictionary() or
            type.isDate() or
            (type.isSpiderMonkeyInterface() and typedArraysAreStructs)):
        raise TypeError("Need to learn to wrap %s" % type)

    if type.nullable():
        (recTemplate, recInfal) = getWrapTemplateForType(type.inner, descriptorProvider,
                                                         "%s.Value()" % result, successCode,
                                                         isCreator, exceptionCode,
                                                         typedArraysAreStructs)
        return ("if (%s.IsNull()) {\n" % result +
                CGIndenter(CGGeneric(setValue("JSVAL_NULL"))).define() + "\n" +
                "}\n" + recTemplate, recInfal)

    if type.isSpiderMonkeyInterface():
        assert typedArraysAreStructs
        
        
        
        return (setValue("JS::ObjectValue(*%s.Obj())" % result,
                         "nonDOMObject"), False)

    if type.isUnion():
        return (wrapAndSetPtr("%s.ToJSVal(cx, ${obj}, ${jsvalHandle})" % result),
                False)

    if type.isDictionary():
        return (wrapAndSetPtr("%s.ToObject(cx, ${obj}, ${jsvalHandle})" % result),
                False)

    if type.isDate():
        return (wrapAndSetPtr("%s.ToDateObject(cx, ${jsvalHandle})" % result),
                False)

    tag = type.tag()

    if tag in [IDLType.Tags.int8, IDLType.Tags.uint8, IDLType.Tags.int16,
               IDLType.Tags.uint16, IDLType.Tags.int32]:
        return (setValue("INT_TO_JSVAL(int32_t(%s))" % result), True)

    elif tag in [IDLType.Tags.int64, IDLType.Tags.uint64,
                 IDLType.Tags.unrestricted_float, IDLType.Tags.float,
                 IDLType.Tags.unrestricted_double, IDLType.Tags.double]:
        
        
        return (setValue("JS_NumberValue(double(%s))" % result), True)

    elif tag == IDLType.Tags.uint32:
        return (setValue("UINT_TO_JSVAL(%s)" % result), True)

    elif tag == IDLType.Tags.bool:
        return (setValue("BOOLEAN_TO_JSVAL(%s)" % result), True)

    else:
        raise TypeError("Need to learn to wrap primitive: %s" % type)

def wrapForType(type, descriptorProvider, templateValues):
    """
    Reflect a C++ value of IDL type "type" into JS.  TemplateValues is a dict
    that should contain:

      * 'jsvalRef': something that can have .address() called on it to get a
                    JS::Value* and .set() called on it to set it to a JS::Value.
                    This can be a JS::MutableHandle<JS::Value> or a
                    JS::Rooted<JS::Value>.
      * 'jsvalHandle': something that can be passed to methods taking a
                       JS::MutableHandle<JS::Value>.  This can be a
                       JS::MutableHandle<JS::Value> or a JS::Rooted<JS::Value>*.
      * 'obj' (optional): the name of the variable that contains the JSObject to
                          use as a scope when wrapping, if not supplied 'obj'
                          will be used as the name
      * 'result' (optional): the name of the variable in which the C++ value is
                             stored, if not supplied 'result' will be used as
                             the name
      * 'successCode' (optional): the code to run once we have successfully
                                  done the conversion, if not supplied 'return
                                  true;' will be used as the code.  The
                                  successCode must ensure that once it runs no
                                  more of the conversion template will be
                                  executed (e.g. by doing a 'return' or 'break'
                                  as appropriate).
      * 'isCreator' (optional): If true, we're wrapping for the return value of
                                a [Creator] method.  Assumed false if not set.
      * 'exceptionCode' (optional): Code to run when a JS exception is thrown.
                                    The default is "return false;".  The code
                                    passed here must return.
    """
    wrap = getWrapTemplateForType(type, descriptorProvider,
                                  templateValues.get('result', 'result'),
                                  templateValues.get('successCode', None),
                                  templateValues.get('isCreator', False),
                                  templateValues.get('exceptionCode',
                                                     "return false;"),
                                  templateValues.get('typedArraysAreStructs',
                                                     False))[0]

    defaultValues = {'obj': 'obj'}
    return string.Template(wrap).substitute(defaultValues, **templateValues)

def infallibleForMember(member, type, descriptorProvider):
    """
    Determine the fallibility of changing a C++ value of IDL type "type" into
    JS for the given attribute. Apart from isCreator, all the defaults are used,
    since the fallbility does not change based on the boolean values,
    and the template will be discarded.

    CURRENT ASSUMPTIONS:
        We assume that successCode for wrapping up return values cannot contain
        failure conditions.
    """
    return getWrapTemplateForType(type, descriptorProvider, 'result', None,\
                                  memberIsCreator(member), "return false;",
                                  False)[1]

def leafTypeNeedsCx(type, descriptorProvider, retVal):
    return (type.isAny() or type.isObject() or
            (retVal and type.isSpiderMonkeyInterface()) or
            (descriptorProvider.workers and type.isCallback()))

def leafTypeNeedsScopeObject(type, descriptorProvider, retVal):
    return (retVal and type.isSpiderMonkeyInterface())

def leafTypeNeedsRooting(type, descriptorProvider):
    return (leafTypeNeedsCx(type, descriptorProvider, False) or
            type.isSpiderMonkeyInterface())

def typeNeedsRooting(type, descriptorProvider):
    return typeMatchesLambda(type,
                             lambda t: leafTypeNeedsRooting(t, descriptorProvider))

def typeNeedsCx(type, descriptorProvider, retVal=False):
    return typeMatchesLambda(type,
                             lambda t: leafTypeNeedsCx(t, descriptorProvider, retVal))

def typeNeedsScopeObject(type, descriptorProvider, retVal=False):
    return typeMatchesLambda(type,
                             lambda t: leafTypeNeedsScopeObject(t, descriptorProvider, retVal))

def typeMatchesLambda(type, func):
    if type is None:
        return False
    if type.nullable():
        return typeMatchesLambda(type.inner, func)
    if type.isSequence() or type.isArray():
        return typeMatchesLambda(type.inner, func)
    if type.isUnion():
        return any(typeMatchesLambda(t, func) for t in
                   type.unroll().flatMemberTypes)
    if type.isDictionary():
        return dictionaryMatchesLambda(type.inner, func)
    return func(type)

def dictionaryMatchesLambda(dictionary, func):
    return (any(typeMatchesLambda(m.type, func) for m in dictionary.members) or
        (dictionary.parent and dictionaryMatchesLambda(dictionary.parent, func)))



def getRetvalDeclarationForType(returnType, descriptorProvider,
                                resultAlreadyAddRefed,
                                isMember=False):
    """
    Returns a tuple containing four things:

    1) A CGThing for the type of the return value, or None if there is no need
       for a return value.

    2) A boolean indicating whether the return value is passed as an out
       parameter.

    3) A CGThing for a tracer for the return value, or None if no tracing is
       needed.

    4) An argument string to pass to the retval declaration
       constructor or None if there are no arguments.
    """
    if returnType is None or returnType.isVoid():
        
        return None, False, None, None
    if returnType.isPrimitive() and returnType.tag() in builtinNames:
        result = CGGeneric(builtinNames[returnType.tag()])
        if returnType.nullable():
            result = CGTemplatedType("Nullable", result)
        return result, False, None, None
    if returnType.isDOMString():
        if isMember:
            return CGGeneric("nsString"), True, None, None
        return CGGeneric("DOMString"), True, None, None
    if returnType.isByteString():
        return CGGeneric("nsCString"), True, None, None
    if returnType.isEnum():
        result = CGGeneric(returnType.unroll().inner.identifier.name)
        if returnType.nullable():
            result = CGTemplatedType("Nullable", result)
        return result, False, None, None
    if returnType.isGeckoInterface():
        result = CGGeneric(descriptorProvider.getDescriptor(
            returnType.unroll().inner.identifier.name).nativeType)
        if descriptorProvider.getDescriptor(
            returnType.unroll().inner.identifier.name).nativeOwnership == 'owned':
            result = CGTemplatedType("nsAutoPtr", result)
        elif resultAlreadyAddRefed:
            result = CGTemplatedType("nsRefPtr", result)
        else:
            result = CGWrapper(result, post="*")
        return result, False, None, None
    if returnType.isCallback():
        name = returnType.unroll().identifier.name
        if descriptorProvider.workers:
            return CGGeneric("JSObject*"), False, None, None
        return CGGeneric("nsRefPtr<%s>" % name), False, None, None
    if returnType.isAny():
        return CGGeneric("JS::Value"), False, None, None
    if returnType.isObject() or returnType.isSpiderMonkeyInterface():
        return CGGeneric("JSObject*"), False, None, None
    if returnType.isSequence():
        nullable = returnType.nullable()
        if nullable:
            returnType = returnType.inner
        
        
        (result, _, _, _) = getRetvalDeclarationForType(returnType.inner,
                                                        descriptorProvider,
                                                        resultAlreadyAddRefed,
                                                        isMember="Sequence")
        
        if not isMember and typeNeedsRooting(returnType, descriptorProvider):
            rooter = CGGeneric("SequenceRooter<%s > resultRooter(cx, &result);" %
                               result.define())
        else:
            rooter = None
        result = CGTemplatedType("nsTArray", result)
        if nullable:
            result = CGTemplatedType("Nullable", result)
        return result, True, rooter, None
    if returnType.isDictionary():
        nullable = returnType.nullable()
        dictName = (CGDictionary.makeDictionaryName(returnType.unroll().inner) +
                    "Initializer")
        result = CGGeneric(dictName)
        if not isMember and typeNeedsRooting(returnType, descriptorProvider):
            if nullable:
                result = CGTemplatedType("NullableRootedDictionary", result)
            else:
                result = CGTemplatedType("RootedDictionary", result)
            resultArgs = "cx"
        elif nullable:
            result = CGTemplatedType("Nullable", result)
            resultArgs = None
        return result, True, None, resultArgs
    if returnType.isUnion():
        result = CGGeneric(returnType.unroll().name + "ReturnValue")
        if returnType.nullable():
            result = CGTemplatedType("Nullable", result)
        return result, True, None, None
    if returnType.isDate():
        result = CGGeneric("Date")
        if returnType.nullable():
            result = CGTemplatedType("Nullable", result)
        return result, False, None, None
    raise TypeError("Don't know how to declare return value for %s" %
                    returnType)

def isResultAlreadyAddRefed(descriptor, extendedAttributes):
    
    return not descriptor.workers and not 'resultNotAddRefed' in extendedAttributes

def needCx(returnType, arguments, extendedAttributes, descriptorProvider,
           considerTypes):
    return (considerTypes and
            (typeNeedsCx(returnType, descriptorProvider, True) or
             any(typeNeedsCx(a.type, descriptorProvider) for a in arguments)) or
            'implicitJSContext' in extendedAttributes)

def needScopeObject(returnType, arguments, extendedAttributes,
                    descriptorProvider, isWrapperCached, considerTypes):
    return (considerTypes and not isWrapperCached and
            (typeNeedsScopeObject(returnType, descriptorProvider, True) or
             any(typeNeedsScopeObject(a.type, descriptorProvider) for a in arguments)))

class CGCallGenerator(CGThing):
    """
    A class to generate an actual call to a C++ object.  Assumes that the C++
    object is stored in a variable whose name is given by the |object| argument.

    errorReport should be a CGThing for an error report or None if no
    error reporting is needed.
    """
    def __init__(self, errorReport, arguments, argsPre, returnType,
                 extendedAttributes, descriptorProvider, nativeMethodName,
                 static, object="self"):
        CGThing.__init__(self)

        assert errorReport is None or isinstance(errorReport, CGThing)

        isFallible = errorReport is not None

        resultAlreadyAddRefed = isResultAlreadyAddRefed(descriptorProvider,
                                                        extendedAttributes)
        (result, resultOutParam,
         resultRooter, resultArgs) = getRetvalDeclarationForType(
            returnType, descriptorProvider, resultAlreadyAddRefed)

        args = CGList([CGGeneric(arg) for arg in argsPre], ", ")
        for (a, name) in arguments:
            arg = CGGeneric(name)
            
            def needsConst(a):
                if a.type.isDictionary():
                    return True
                if a.type.isSequence():
                    return True
                
                
                
                
                
                if a.type.nullable() and not a.type.isObject():
                    return True
                if a.type.isString():
                    return True
                if a.optional and not a.defaultValue:
                    
                    
                    
                    return True
                if a.type.isUnion():
                    return True
                if a.type.isSpiderMonkeyInterface():
                    return True
                return False
            if needsConst(a):
                arg = CGWrapper(arg, pre="Constify(", post=")")
            
            if (((a.type.isGeckoInterface() or a.type.isCallback()) and
                 not a.type.nullable()) or
                a.type.isDOMString()):
                arg = CGWrapper(arg, pre="NonNullHelper(", post=")")
            args.append(arg)

        
        if resultOutParam:
            args.append(CGGeneric("result"))
        if isFallible:
            args.append(CGGeneric("rv"))

        
        self.cgRoot = CGList([], "\n")

        call = CGGeneric(nativeMethodName)
        if not static:
            call = CGWrapper(call, pre="%s->" % object)
        call = CGList([call, CGWrapper(args, pre="(", post=");")])
        if result is not None:
            if resultRooter is not None:
                self.cgRoot.prepend(resultRooter)
            if resultArgs is not None:
                resultArgs = "(%s)" % resultArgs
            else:
                resultArgs = ""
            result = CGWrapper(result, post=(" result%s;" % resultArgs))
            self.cgRoot.prepend(result)
            if not resultOutParam:
                call = CGWrapper(call, pre="result = ")

        call = CGWrapper(call)
        self.cgRoot.append(call)

        if isFallible:
            self.cgRoot.prepend(CGGeneric("ErrorResult rv;"))
            self.cgRoot.append(CGGeneric("rv.WouldReportJSException();"))
            self.cgRoot.append(CGGeneric("if (rv.Failed()) {"))
            self.cgRoot.append(CGIndenter(errorReport))
            self.cgRoot.append(CGGeneric("}"))

    def define(self):
        return self.cgRoot.define()

class MethodNotCreatorError(Exception):
    def __init__(self, typename):
        self.typename = typename




sequenceWrapLevel = 0

def wrapTypeIntoCurrentCompartment(type, value, isMember=True):
    """
    Take the thing named by "value" and if it contains "any",
    "object", or spidermonkey-interface types inside return a CGThing
    that will wrap them into the current compartment.
    """
    if type.isAny():
        assert not type.nullable()
        if isMember:
            value = "&" + value
        else:
            value = value + ".address()"
        return CGGeneric("if (!JS_WrapValue(cx, %s)) {\n"
                         "  return false;\n"
                         "}" % value)

    if type.isObject():
        if isMember:
            value = "&%s" % value
        else:
            value = value + ".address()"
        return CGGeneric("if (!JS_WrapObject(cx, %s)) {\n"
                         "  return false;\n"
                         "}" % value)

    if type.isSpiderMonkeyInterface():
        origValue = value
        if type.nullable():
            value = "%s.Value()" % value
        wrapCode = CGGeneric("if (!%s.WrapIntoNewCompartment(cx)) {\n"
                             "  return false;\n"
                             "}" % value)
        if type.nullable():
            wrapCode = CGIfWrapper(wrapCode, "!%s.IsNull()" % origValue)
        return wrapCode

    if type.isSequence():
        origValue = value
        origType = type
        if type.nullable():
            type = type.inner
            value = "%s.Value()" % value
        global sequenceWrapLevel
        index = "indexName%d" % sequenceWrapLevel
        sequenceWrapLevel += 1
        wrapElement = wrapTypeIntoCurrentCompartment(type.inner,
                                                     "%s[%s]" % (value, index))
        sequenceWrapLevel -= 1
        if not wrapElement:
            return None
        wrapCode = CGWrapper(CGIndenter(wrapElement),
                             pre=("for (uint32_t %s = 0; %s < %s.Length(); ++%s) {\n" %
                                  (index, index, value, index)),
                             post="\n}")
        if origType.nullable():
            wrapCode = CGIfWrapper(wrapCode, "!%s.IsNull()" % origValue)
        return wrapCode

    if type.isDictionary():
        assert not type.nullable()
        myDict = type.inner
        memberWraps = []
        while myDict:
            for member in myDict.members:
                memberWrap = wrapArgIntoCurrentCompartment(
                    member,
                    "%s.%s" % (value, CGDictionary.makeMemberName(member.identifier.name)))
                if memberWrap:
                    memberWraps.append(memberWrap)
            myDict = myDict.parent
        return CGList(memberWraps, "\n") if len(memberWraps) != 0 else None

    if type.isUnion():
        raise TypeError("Can't handle wrapping of unions in constructor "
                        "arguments yet")

    if (type.isString() or type.isPrimitive() or type.isEnum() or
        type.isGeckoInterface() or type.isCallback() or type.isDate()):
        
        return None

    raise TypeError("Unknown type; we don't know how to wrap it in constructor "
                    "arguments: %s" % type)

def wrapArgIntoCurrentCompartment(arg, value, isMember=True):
    """
    As wrapTypeIntoCurrentCompartment but handles things being optional
    """
    origValue = value
    isOptional = arg.optional and not arg.defaultValue
    if isOptional:
        value = value + ".Value()"
    wrap = wrapTypeIntoCurrentCompartment(arg.type, value, isMember)
    if wrap and isOptional:
        wrap = CGIfWrapper(wrap, "%s.WasPassed()" % origValue)
    return wrap

class CGPerSignatureCall(CGThing):
    """
    This class handles the guts of generating code for a particular
    call signature.  A call signature consists of four things:

    1) A return type, which can be None to indicate that there is no
       actual return value (e.g. this is an attribute setter) or an
       IDLType if there's an IDL type involved (including |void|).
    2) An argument list, which is allowed to be empty.
    3) A name of a native method to call.
    4) Whether or not this method is static.

    We also need to know whether this is a method or a getter/setter
    to do error reporting correctly.

    The idlNode parameter can be either a method or an attr. We can query
    |idlNode.identifier| in both cases, so we can be agnostic between the two.
    """
    
    
    
    

    def __init__(self, returnType, arguments, nativeMethodName, static,
                 descriptor, idlNode, argConversionStartsAt=0, getter=False,
                 setter=False, isConstructor=False):
        assert idlNode.isMethod() == (not getter and not setter)
        assert idlNode.isAttr() == (getter or setter)

        CGThing.__init__(self)
        self.returnType = returnType
        self.descriptor = descriptor
        self.idlNode = idlNode
        self.extendedAttributes = descriptor.getExtendedAttributes(idlNode,
                                                                   getter=getter,
                                                                   setter=setter)
        self.arguments = arguments
        self.argCount = len(arguments)
        cgThings = []
        lenientFloatCode = None
        if idlNode.getExtendedAttribute('LenientFloat') is not None:
            if setter:
                lenientFloatCode = "return true;"
            elif idlNode.isMethod():
                lenientFloatCode = ("args.rval().set(JSVAL_VOID);\n"
                                    "return true;")

        argsPre = []
        if static:
            nativeMethodName = "%s::%s" % (descriptor.nativeType,
                                           nativeMethodName)
            cgThings.append(CGGeneric("""GlobalObject global(cx, obj);
if (global.Failed()) {
  return false;
}
"""))
            argsPre.append("global")

        
        
        
        needsCx = needCx(returnType, arguments, self.extendedAttributes,
                         descriptor, not descriptor.interface.isJSImplemented())
        if needsCx and not (static and descriptor.workers):
            argsPre.append("cx")

        needsUnwrap = isConstructor
        if needScopeObject(returnType, arguments, self.extendedAttributes,
                           descriptor, descriptor.wrapperCache,
                           not descriptor.interface.isJSImplemented()):
            
            
            cgThings.append(CGGeneric("Maybe<JS::Rooted<JSObject*> > unwrappedObj;"))
            argsPre.append("unwrappedObj.empty() ? obj : unwrappedObj.ref()")
            needsUnwrap = True

        if idlNode.isMethod() and idlNode.isLegacycaller():
            
            
            
            assert idlNode.isIdentifierLess()
            
            argsPre.append("args.thisv()")

        ourName = "%s.%s" % (descriptor.interface.identifier.name,
                             idlNode.identifier.name)
        if idlNode.isMethod():
            argDescription = "argument %(index)d of " + ourName
        elif setter:
            argDescription = "value being assigned to %s" % ourName
        else:
            assert self.argCount == 0

        cgThings.extend([CGArgumentConverter(arguments[i], i, self.descriptor,
                                             argDescription % { "index": i + 1 },
                                             invalidEnumValueFatal=not setter,
                                             allowTreatNonCallableAsNull=setter,
                                             lenientFloatCode=lenientFloatCode) for
                         i in range(argConversionStartsAt, self.argCount)])

        if needsUnwrap:
            
            xraySteps = []
            if not isConstructor:
                xraySteps.append(
                    CGGeneric("unwrappedObj.construct(cx, obj);"))

            
            
            xraySteps.append(
                CGGeneric(string.Template("""${obj} = js::CheckedUnwrap(${obj});
if (!${obj}) {
  return false;
}""").substitute({ 'obj' : 'obj' if isConstructor else 'unwrappedObj.ref()' })))
            if isConstructor:
                
                
                
                
                
                
                
                
                
                cgThings.append(CGGeneric("Maybe<JSAutoCompartment> ac;"))
                xraySteps.append(CGGeneric("ac.construct(cx, obj);"))
                xraySteps.extend(
                    wrapArgIntoCurrentCompartment(arg, argname, isMember=False)
                    for (arg, argname) in self.getArguments())

            cgThings.append(
                CGIfWrapper(CGList(xraySteps, "\n"),
                            "xpc::WrapperFactory::IsXrayWrapper(obj)"))

        cgThings.append(CGCallGenerator(
                    self.getErrorReport() if self.isFallible() else None,
                    self.getArguments(), argsPre, returnType,
                    self.extendedAttributes, descriptor, nativeMethodName,
                    static))
        self.cgRoot = CGList(cgThings, "\n")

    def getArguments(self):
        return [(a, "arg" + str(i)) for (i, a) in enumerate(self.arguments)]

    def isFallible(self):
        return not 'infallible' in self.extendedAttributes

    def wrap_return_value(self):
        isCreator = memberIsCreator(self.idlNode)
        if isCreator:
            
            assert(isResultAlreadyAddRefed(self.descriptor,
                                           self.extendedAttributes) or
                   
                   (self.returnType.isGeckoInterface() and
                    self.descriptor.getDescriptor(self.returnType.unroll().inner.identifier.name).nativeOwnership == 'owned') or
                   
                   
                   self.descriptor.workers)

        resultTemplateValues = { 'jsvalRef': 'args.rval()',
                                 'jsvalHandle': 'args.rval()',
                                 'isCreator': isCreator}
        try:
            return wrapForType(self.returnType, self.descriptor,
                               resultTemplateValues)
        except MethodNotCreatorError, err:
            assert not isCreator
            raise TypeError("%s being returned from non-creator method or property %s.%s" %
                            (err.typename,
                             self.descriptor.interface.identifier.name,
                             self.idlNode.identifier.name))

    def getErrorReport(self):
        return CGGeneric('return ThrowMethodFailedWithDetails<%s>(cx, rv, "%s", "%s");'
                         % (toStringBool(not self.descriptor.workers),
                            self.descriptor.interface.identifier.name,
                            self.idlNode.identifier.name))

    def define(self):
        return (self.cgRoot.define() + "\n" + self.wrap_return_value())

class CGSwitch(CGList):
    """
    A class to generate code for a switch statement.

    Takes three constructor arguments: an expression, a list of cases,
    and an optional default.

    Each case is a CGCase.  The default is a CGThing for the body of
    the default case, if any.
    """
    def __init__(self, expression, cases, default=None):
        CGList.__init__(self, [CGIndenter(c) for c in cases], "\n")
        self.prepend(CGWrapper(CGGeneric(expression),
                               pre="switch (", post=") {"));
        if default is not None:
            self.append(
                CGIndenter(
                    CGWrapper(
                        CGIndenter(default),
                        pre="default: {\n",
                        post="\n  break;\n}"
                        )
                    )
                )
                        
        self.append(CGGeneric("}"))

class CGCase(CGList):
    """
    A class to generate code for a case statement.

    Takes three constructor arguments: an expression, a CGThing for
    the body (allowed to be None if there is no body), and an optional
    argument (defaulting to False) for whether to fall through.
    """
    def __init__(self, expression, body, fallThrough=False):
        CGList.__init__(self, [], "\n")
        self.append(CGWrapper(CGGeneric(expression), pre="case ", post=": {"))
        bodyList = CGList([body], "\n")
        if fallThrough:
            bodyList.append(CGGeneric("/* Fall through */"))
        else:
            bodyList.append(CGGeneric("break;"))
        self.append(CGIndenter(bodyList));
        self.append(CGGeneric("}"))

class CGMethodCall(CGThing):
    """
    A class to generate selection of a method signature from a set of
    signatures and generation of a call to that signature.
    """
    def __init__(self, nativeMethodName, static, descriptor, method,
                 isConstructor=False):
        CGThing.__init__(self)

        methodName = "%s.%s" % (descriptor.interface.identifier.name, method.identifier.name)
        argDesc = "argument %d of " + methodName

        def requiredArgCount(signature):
            arguments = signature[1]
            if len(arguments) == 0:
                return 0
            requiredArgs = len(arguments)
            while requiredArgs and arguments[requiredArgs-1].optional:
                requiredArgs -= 1
            return requiredArgs

        def getPerSignatureCall(signature, argConversionStartsAt=0):
            return CGPerSignatureCall(signature[0], signature[1],
                                      nativeMethodName, static, descriptor,
                                      method,
                                      argConversionStartsAt=argConversionStartsAt,
                                      isConstructor=isConstructor)
            

        signatures = method.signatures()
        if len(signatures) == 1:
            
            
            
            signature = signatures[0]
            self.cgRoot = CGList([ CGIndenter(getPerSignatureCall(signature)) ])
            requiredArgs = requiredArgCount(signature)


            if requiredArgs > 0:
                code = (
                    "if (args.length() < %d) {\n"
                    '  return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "%s");\n'
                    "}" % (requiredArgs, methodName))
                self.cgRoot.prepend(
                    CGWrapper(CGIndenter(CGGeneric(code)), pre="\n", post="\n"))
            return

        
        
        for (_, sigArgs) in signatures:
            for arg in sigArgs:
                if arg.treatUndefinedAs == "Missing":
                    raise TypeError("No support for [TreatUndefinedAs=Missing] "
                                    "handling in overload resolution yet: %s" %
                                    arg.location)

        
        maxArgCount = method.maxArgCount
        allowedArgCounts = method.allowedArgCounts

        argCountCases = []
        for argCount in allowedArgCounts:
            possibleSignatures = method.signaturesForArgCount(argCount)
            if len(possibleSignatures) == 1:
                
                signature = possibleSignatures[0]

                
                
                
                
                
                if (len(signature[1]) > argCount and
                    signature[1][argCount].optional and
                    (argCount+1) in allowedArgCounts and
                    len(method.signaturesForArgCount(argCount+1)) == 1):
                    argCountCases.append(
                        CGCase(str(argCount), None, True))
                else:
                    argCountCases.append(
                        CGCase(str(argCount), getPerSignatureCall(signature)))
                continue

            distinguishingIndex = method.distinguishingIndexForArgCount(argCount)

            def distinguishingArgument(signature):
                args = signature[1]
                if distinguishingIndex < len(args):
                    return args[distinguishingIndex]
                assert args[-1].variadic
                return args[-1]

            def distinguishingType(signature):
                return distinguishingArgument(signature).type

            for sig in possibleSignatures:
                
                
                
                assert not distinguishingType(sig).isAny()
                
                if distinguishingType(sig).isUnion():
                    raise TypeError("No support for unions as distinguishing "
                                    "arguments yet: %s" %
                                    distinguishingArgument(sig).location)
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                if distinguishingArgument(sig).variadic:
                    raise TypeError("No support for variadics as distinguishing "
                                    "arguments yet: %s" %
                                    distinguishingArgument(sig).location)

            
            
            
            
            caseBody = [ CGArgumentConverter(possibleSignatures[0][1][i],
                                             i, descriptor,
                                             argDesc % (i + 1)) for i in
                         range(0, distinguishingIndex) ]

            
            distinguishingArg = "args[%d]" % distinguishingIndex

            def tryCall(signature, indent, isDefinitelyObject=False,
                        isNullOrUndefined=False):
                assert not isDefinitelyObject or not isNullOrUndefined
                assert isDefinitelyObject or isNullOrUndefined
                if isDefinitelyObject:
                    failureCode = "break;"
                else:
                    failureCode = None
                type = distinguishingType(signature)
                
                
                
                testCode = instantiateJSToNativeConversion(
                    getJSToNativeConversionInfo(type, descriptor,
                                                failureCode=failureCode,
                                                isDefinitelyObject=isDefinitelyObject,
                                                isNullOrUndefined=isNullOrUndefined,
                                                sourceDescription=(argDesc % (distinguishingIndex + 1))),
                    {
                        "declName" : "arg%d" % distinguishingIndex,
                        "holderName" : ("arg%d" % distinguishingIndex) + "_holder",
                        "val" : distinguishingArg,
                        "mutableVal" : distinguishingArg,
                        "obj" : "obj"
                        })
                caseBody.append(CGIndenter(testCode, indent));
                
                
                
                
                caseBody.append(CGIndenter(
                        getPerSignatureCall(signature, distinguishingIndex + 1),
                        indent))

            
            
            
            
            
            
            
            
            
            
            
            
            nullOrUndefSigs = [s for s in possibleSignatures
                               if ((distinguishingType(s).nullable() and not
                                    distinguishingType(s).isString() and not
                                    distinguishingType(s).isEnum() and not
                                   distinguishingType(s).isPrimitive()) or
                                   distinguishingType(s).isDictionary())]
            
            assert len(nullOrUndefSigs) < 2
            if len(nullOrUndefSigs) > 0:
                caseBody.append(CGGeneric("if (%s.isNullOrUndefined()) {" %
                                          distinguishingArg))
                tryCall(nullOrUndefSigs[0], 2, isNullOrUndefined=True)
                caseBody.append(CGGeneric("}"))

            
            
            
            
            
            
            
            
            
            
            
            
            
            
            

            
            
            
            
            
            objectSigs = [
                s for s in possibleSignatures
                if (distinguishingType(s).isObject() or
                    distinguishingType(s).isNonCallbackInterface()) ]

            
            objectSigs.extend(s for s in possibleSignatures
                              if distinguishingType(s).isDate())

            
            objectSigs.extend(s for s in possibleSignatures
                              if distinguishingType(s).isCallback())

            
            
            objectSigs.extend(s for s in possibleSignatures
                              if (distinguishingType(s).isArray() or
                                  distinguishingType(s).isSequence() or
                                  distinguishingType(s).isDictionary() or
                                  distinguishingType(s).isCallbackInterface()))

            
            
            if len(objectSigs) > 0:
                
                
                
                
                
                
                
                
                
                
                caseBody.append(CGGeneric("if (%s.isObject()) {" %
                                          distinguishingArg))
                for sig in objectSigs:
                    caseBody.append(CGIndenter(CGGeneric("do {")));
                    
                    
                    tryCall(sig, 4, isDefinitelyObject=True)
                    caseBody.append(CGIndenter(CGGeneric("} while (0);")))

                caseBody.append(CGGeneric("}"))

            
            
            
            
            
            def findUniqueSignature(filterLambda):
                sigs = filter(filterLambda, possibleSignatures)
                assert len(sigs) < 2
                if len(sigs) > 0:
                    return sigs[0]
                return None

            stringSignature = findUniqueSignature(
                lambda s: (distinguishingType(s).isString() or
                           distinguishingType(s).isEnum()))
            numericSignature = findUniqueSignature(
                lambda s: distinguishingType(s).isNumeric())
            booleanSignature = findUniqueSignature(
                lambda s: distinguishingType(s).isBoolean())

            if stringSignature or numericSignature:
                booleanCondition = "%s.isBoolean()"
            else:
                booleanCondition = None

            if stringSignature:
                numericCondition = "%s.isNumber()"
            else:
                numericCondition = None

            def addCase(sig, condition):
                sigCode = getPerSignatureCall(sig, distinguishingIndex)
                if condition:
                    sigCode = CGIfWrapper(sigCode,
                                          condition % distinguishingArg)
                caseBody.append(sigCode)

            if booleanSignature:
                addCase(booleanSignature, booleanCondition)
            if numericSignature:
                addCase(numericSignature, numericCondition)
            if stringSignature:
                addCase(stringSignature, None)

            if (not booleanSignature and not numericSignature and
                not stringSignature):
                
                
                caseBody.append(CGGeneric(
                  'return ThrowErrorMessage(cx, MSG_OVERLOAD_RESOLUTION_FAILED, "%d", "%d", "%s");'
                  % (distinguishingIndex+1, argCount, methodName)))

            argCountCases.append(CGCase(str(argCount),
                                        CGList(caseBody, "\n")))

        overloadCGThings = []
        overloadCGThings.append(
            CGGeneric("unsigned argcount = std::min(args.length(), %du);" %
                      maxArgCount))
        overloadCGThings.append(
            CGSwitch("argcount",
                     argCountCases,
                     CGGeneric('return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "%s");\n' % methodName)))
        overloadCGThings.append(
            CGGeneric('MOZ_CRASH("We have an always-returning default case");\n'
                      'return false;'))
        self.cgRoot = CGWrapper(CGIndenter(CGList(overloadCGThings, "\n")),
                                pre="\n")

    def define(self):
        return self.cgRoot.define()

class CGGetterCall(CGPerSignatureCall):
    """
    A class to generate a native object getter call for a particular IDL
    getter.
    """
    def __init__(self, returnType, nativeMethodName, descriptor, attr):
        CGPerSignatureCall.__init__(self, returnType, [], nativeMethodName,
                                    attr.isStatic(), descriptor, attr,
                                    getter=True)

class FakeArgument():
    """
    A class that quacks like an IDLArgument.  This is used to make
    setters look like method calls or for special operations.
    """
    def __init__(self, type, interfaceMember, name="arg"):
        self.type = type
        self.optional = False
        self.variadic = False
        self.defaultValue = None
        self.treatNullAs = interfaceMember.treatNullAs
        self.treatUndefinedAs = interfaceMember.treatUndefinedAs
        self.enforceRange = False
        self.clamp = False
        class FakeIdentifier():
            def __init__(self):
                self.name = name
        self.identifier = FakeIdentifier()

class CGSetterCall(CGPerSignatureCall):
    """
    A class to generate a native object setter call for a particular IDL
    setter.
    """
    def __init__(self, argType, nativeMethodName, descriptor, attr):
        CGPerSignatureCall.__init__(self, None, [FakeArgument(argType, attr)],
                                    nativeMethodName, attr.isStatic(),
                                    descriptor, attr, setter=True)
    def wrap_return_value(self):
        
        return "\nreturn true;"

class CGAbstractBindingMethod(CGAbstractStaticMethod):
    """
    Common class to generate the JSNatives for all our methods, getters, and
    setters.  This will generate the function declaration and unwrap the
    |this| object.  Subclasses are expected to override the generate_code
    function to do the rest of the work.  This function should return a
    CGThing which is already properly indented.
    """
    def __init__(self, descriptor, name, args, unwrapFailureCode=None,
                 getThisObj="args.computeThis(cx).toObjectOrNull()",
                 callArgs="JS::CallArgs args = JS::CallArgsFromVp(argc, vp);"):
        CGAbstractStaticMethod.__init__(self, descriptor, name, "bool", args)

        if unwrapFailureCode is None:
            self.unwrapFailureCode = 'return ThrowErrorMessage(cx, MSG_THIS_DOES_NOT_IMPLEMENT_INTERFACE, "Value", "%s");' % descriptor.interface.identifier.name
        else:
            self.unwrapFailureCode = unwrapFailureCode
        self.getThisObj = getThisObj
        self.callArgs = callArgs

    def definition_body(self):
        
        
        
        
        getThis = CGList([
                CGGeneric(self.callArgs) if self.callArgs != "" else None,
                CGGeneric("JS::RootedObject obj(cx, %s);\n"
                          "if (!obj) {\n"
                          "  return false;\n"
                          "}" % self.getThisObj) if self.getThisObj else None,
                CGGeneric("%s* self;" % self.descriptor.nativeType)
                ], "\n")
        unwrapThis = CGGeneric(
            str(CastableObjectUnwrapper(
                        self.descriptor,
                        "obj", "self", self.unwrapFailureCode)))
        return CGList([ CGIndenter(getThis), CGIndenter(unwrapThis),
                        self.generate_code() ], "\n").define()

    def generate_code(self):
        assert(False) 

class CGAbstractStaticBindingMethod(CGAbstractStaticMethod):
    """
    Common class to generate the JSNatives for all our static methods, getters
    and setters.  This will generate the function declaration and unwrap the
    global object.  Subclasses are expected to override the generate_code
    function to do the rest of the work.  This function should return a
    CGThing which is already properly indented.
    """
    def __init__(self, descriptor, name):
        args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
                Argument('JS::Value*', 'vp')]
        CGAbstractStaticMethod.__init__(self, descriptor, name, "bool", args)

    def definition_body(self):
        unwrap = CGGeneric("""JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
JS::RootedObject obj(cx, args.computeThis(cx).toObjectOrNull());
if (!obj) {
  return false;
}""")
        return CGList([ CGIndenter(unwrap),
                        self.generate_code() ], "\n\n").define()

    def generate_code(self):
        assert(False) 

def MakeNativeName(name):
    return name[0].upper() + name[1:]

class CGGenericMethod(CGAbstractBindingMethod):
    """
    A class for generating the C++ code for an IDL method..
    """
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
                Argument('JS::Value*', 'vp')]
        unwrapFailureCode = (
            'return ThrowInvalidThis(cx, args, MSG_METHOD_THIS_DOES_NOT_IMPLEMENT_INTERFACE, \"%s\");' %
            descriptor.interface.identifier.name)
        CGAbstractBindingMethod.__init__(self, descriptor, 'genericMethod',
                                         args,
                                         unwrapFailureCode=unwrapFailureCode)

    def generate_code(self):
        return CGIndenter(CGGeneric(
            "const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));\n"
            "MOZ_ASSERT(info->type == JSJitInfo::Method);\n"
            "JSJitMethodOp method = info->method;\n"
            "return method(cx, obj, self, JSJitMethodCallArgs(args));"))

class CGSpecializedMethod(CGAbstractStaticMethod):
    """
    A class for generating the C++ code for a specialized method that the JIT
    can call with lower overhead.
    """
    def __init__(self, descriptor, method):
        self.method = method
        name = CppKeywords.checkMethodName(method.identifier.name)
        args = [Argument('JSContext*', 'cx'), Argument('JS::Handle<JSObject*>', 'obj'),
                Argument('%s*' % descriptor.nativeType, 'self'),
                Argument('const JSJitMethodCallArgs&', 'args')]
        CGAbstractStaticMethod.__init__(self, descriptor, name, 'bool', args)

    def definition_body(self):
        nativeName = CGSpecializedMethod.makeNativeName(self.descriptor,
                                                        self.method)
        return CGMethodCall(nativeName, self.method.isStatic(), self.descriptor,
                            self.method).define()

    @staticmethod
    def makeNativeName(descriptor, method):
        name = method.identifier.name
        return MakeNativeName(descriptor.binaryNames.get(name, name))

class CGJsonifierMethod(CGSpecializedMethod):
    def __init__(self, descriptor, method):
        assert method.isJsonifier()
        CGSpecializedMethod.__init__(self, descriptor, method)

    def definition_body(self):
        ret = ('JS::Rooted<JSObject*> result(cx, JS_NewObject(cx, nullptr, nullptr, nullptr));\n'
               'if (!result) {\n'
               '  return false;\n'
               '}\n')
        for m in self.descriptor.interface.members:
          if m.isAttr() and not m.isStatic() and m.type.isSerializable():
              ret += ('{ // scope for "temp"\n'
                      '  JS::Rooted<JS::Value> temp(cx);\n'
                      '  if (!get_%s(cx, obj, self, JSJitGetterCallArgs(&temp))) {\n'
                      '    return false;\n'
                      '  }\n'
                      '  if (!JS_DefineProperty(cx, result, "%s", temp, nullptr, nullptr, JSPROP_ENUMERATE)) {\n'
                      '    return false;\n'
                      '  }\n'
                      '}\n' % (m.identifier.name, m.identifier.name))

        ret += ('args.rval().setObject(*result);\n'
                'return true;')
        return CGIndenter(CGGeneric(ret)).define()

class CGLegacyCallHook(CGAbstractBindingMethod):
    """
    Call hook for our object
    """
    def __init__(self, descriptor):
        self._legacycaller = descriptor.operations["LegacyCaller"]
        args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
                Argument('JS::Value*', 'vp')]
        
        CGAbstractBindingMethod.__init__(
            self, descriptor, LEGACYCALLER_HOOK_NAME,
            args, getThisObj="&JS_CALLEE(cx, vp).toObject()")

    def define(self):
        if not self._legacycaller:
            return ""
        return CGAbstractBindingMethod.define(self)

    def generate_code(self):
        name = self._legacycaller.identifier.name
        nativeName = MakeNativeName(self.descriptor.binaryNames.get(name, name))
        return CGMethodCall(nativeName, False, self.descriptor,
                            self._legacycaller)

class CGNewResolveHook(CGAbstractBindingMethod):
    """
    NewResolve hook for our object
    """
    def __init__(self, descriptor):
        assert descriptor.interface.getExtendedAttribute("NeedNewResolve")
        args = [Argument('JSContext*', 'cx'), Argument('JS::Handle<JSObject*>', 'obj'),
                Argument('JS::Handle<jsid>', 'id'), Argument('unsigned', 'flags'),
                Argument('JS::MutableHandle<JSObject*>', 'objp')]
        
        CGAbstractBindingMethod.__init__(
            self, descriptor, NEWRESOLVE_HOOK_NAME,
            args, getThisObj="", callArgs="")

    def generate_code(self):
        return CGIndenter(CGGeneric(
                "JS::Rooted<JS::Value> value(cx);\n"
                "if (!self->DoNewResolve(cx, obj, id, &value)) {\n"
                "  return false;\n"
                "}\n"
                "if (value.isUndefined()) {\n"
                "  return true;\n"
                "}\n"
                "if (!JS_DefinePropertyById(cx, obj, id, value, nullptr, nullptr, JSPROP_ENUMERATE)) {\n"
                "  return false;\n"
                "}\n"
                "objp.set(obj);\n"
                "return true;"))

class CGEnumerateHook(CGAbstractBindingMethod):
    """
    Enumerate hook for our object
    """
    def __init__(self, descriptor):
        assert descriptor.interface.getExtendedAttribute("NeedNewResolve")
        args = [Argument('JSContext*', 'cx'),
                Argument('JS::Handle<JSObject*>', 'obj')]
        
        CGAbstractBindingMethod.__init__(
            self, descriptor, ENUMERATE_HOOK_NAME,
            args, getThisObj="", callArgs="")

    def generate_code(self):
        return CGIndenter(CGGeneric(
                "nsAutoTArray<nsString, 8> names;\n"
                "ErrorResult rv;\n"
                "self->GetOwnPropertyNames(cx, names, rv);\n"
                "rv.WouldReportJSException();\n"
                "if (rv.Failed()) {\n"
                '  return ThrowMethodFailedWithDetails<true>(cx, rv, "%s", "enumerate");\n'
                "}\n"
                "JS::Rooted<JS::Value> dummy(cx);\n"
                "for (uint32_t i = 0; i < names.Length(); ++i) {\n"
                "  if (!JS_LookupUCProperty(cx, obj, names[i].get(), names[i].Length(), &dummy)) {\n"
                "    return false;\n"
                "  }\n"
                "}\n"
                "return true;"))

class CppKeywords():
    """
    A class for checking if method names declared in webidl
    are not in conflict with C++ keywords.
    """
    keywords = frozenset(['alignas', 'alignof', 'and', 'and_eq', 'asm', 'auto', 'bitand', 'bitor', 'bool',
    'break', 'case', 'catch', 'char', 'char16_t', 'char32_t', 'class', 'compl', 'const', 'constexpr',
    'const_cast', 'continue', 'decltype', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
    'explicit', 'export', 'extern', 'false', 'final', 'float', 'for', 'friend', 'goto', 'if', 'inline',
    'int', 'long', 'mutable', 'namespace', 'new', 'noexcept', 'not', 'not_eq', 'nullptr', 'operator',
    'or', 'or_eq', 'override', 'private', 'protected', 'public', 'register', 'reinterpret_cast', 'return',
    'short', 'signed', 'sizeof', 'static', 'static_assert', 'static_cast', 'struct', 'switch', 'template',
    'this', 'thread_local', 'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union', 'unsigned',
    'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'xor', 'xor_eq'])

    @staticmethod
    def checkMethodName(name):
        if name in CppKeywords.keywords:
          name = '_' + name
        return name

class CGStaticMethod(CGAbstractStaticBindingMethod):
    """
    A class for generating the C++ code for an IDL static method.
    """
    def __init__(self, descriptor, method):
        self.method = method
        name = method.identifier.name
        CGAbstractStaticBindingMethod.__init__(self, descriptor, name)

    def generate_code(self):
        nativeName = CGSpecializedMethod.makeNativeName(self.descriptor,
                                                        self.method)
        return CGMethodCall(nativeName, True, self.descriptor, self.method)

class CGGenericGetter(CGAbstractBindingMethod):
    """
    A class for generating the C++ code for an IDL attribute getter.
    """
    def __init__(self, descriptor, lenientThis=False):
        args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
                Argument('JS::Value*', 'vp')]
        if lenientThis:
            name = "genericLenientGetter"
            unwrapFailureCode = (
                "MOZ_ASSERT(!JS_IsExceptionPending(cx));\n"
                "if (!ReportLenientThisUnwrappingFailure(cx, obj)) {\n"
                "  return false;\n"
                "}\n"
                "args.rval().set(JS::UndefinedValue());\n"
                "return true;")
        else:
            name = "genericGetter"
            unwrapFailureCode = (
                'return ThrowInvalidThis(cx, args, MSG_GETTER_THIS_DOES_NOT_IMPLEMENT_INTERFACE, "%s");' %
                descriptor.interface.identifier.name)
        CGAbstractBindingMethod.__init__(self, descriptor, name, args,
                                         unwrapFailureCode)

    def generate_code(self):
        return CGIndenter(CGGeneric(
            "const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));\n"
            "MOZ_ASSERT(info->type == JSJitInfo::Getter);\n"
            "JSJitGetterOp getter = info->getter;\n"
            "return getter(cx, obj, self, JSJitGetterCallArgs(args));"))

class CGSpecializedGetter(CGAbstractStaticMethod):
    """
    A class for generating the code for a specialized attribute getter
    that the JIT can call with lower overhead.
    """
    def __init__(self, descriptor, attr):
        self.attr = attr
        name = 'get_' + attr.identifier.name
        args = [ Argument('JSContext*', 'cx'),
                 Argument('JS::Handle<JSObject*>', 'obj'),
                 Argument('%s*' % descriptor.nativeType, 'self'),
                 Argument('JSJitGetterCallArgs', 'args') ]
        CGAbstractStaticMethod.__init__(self, descriptor, name, "bool", args)

    def definition_body(self):
        nativeName = CGSpecializedGetter.makeNativeName(self.descriptor,
                                                        self.attr)
        return CGIndenter(CGGetterCall(self.attr.type, nativeName,
                                       self.descriptor, self.attr)).define()

    @staticmethod
    def makeNativeName(descriptor, attr):
        name = attr.identifier.name
        nativeName = MakeNativeName(descriptor.binaryNames.get(name, name))
        
        (_, resultOutParam, _, _) = getRetvalDeclarationForType(attr.type,
                                                                descriptor,
                                                                False)
        infallible = ('infallible' in
                      descriptor.getExtendedAttributes(attr, getter=True))
        if resultOutParam or attr.type.nullable() or not infallible:
            nativeName = "Get" + nativeName
        return nativeName

class CGStaticGetter(CGAbstractStaticBindingMethod):
    """
    A class for generating the C++ code for an IDL static attribute getter.
    """
    def __init__(self, descriptor, attr):
        self.attr = attr
        name = 'get_' + attr.identifier.name
        CGAbstractStaticBindingMethod.__init__(self, descriptor, name)

    def generate_code(self):
        nativeName = CGSpecializedGetter.makeNativeName(self.descriptor,
                                                        self.attr)
        return CGIndenter(CGGetterCall(self.attr.type, nativeName,
                                       self.descriptor, self.attr))

class CGGenericSetter(CGAbstractBindingMethod):
    """
    A class for generating the C++ code for an IDL attribute setter.
    """
    def __init__(self, descriptor, lenientThis=False):
        args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
                Argument('JS::Value*', 'vp')]
        if lenientThis:
            name = "genericLenientSetter"
            unwrapFailureCode = (
                "MOZ_ASSERT(!JS_IsExceptionPending(cx));\n"
                "if (!ReportLenientThisUnwrappingFailure(cx, obj)) {\n"
                "  return false;\n"
                "}\n"
                "args.rval().set(JS::UndefinedValue());\n"
                "return true;")
        else:
            name = "genericSetter"
            unwrapFailureCode = (
                'return ThrowInvalidThis(cx, args, MSG_SETTER_THIS_DOES_NOT_IMPLEMENT_INTERFACE, "%s");' %
                descriptor.interface.identifier.name)

        CGAbstractBindingMethod.__init__(self, descriptor, name, args,
                                         unwrapFailureCode)

    def generate_code(self):
        return CGIndenter(CGGeneric(
                "if (args.length() == 0) {\n"
                '  return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "%s attribute setter");\n'
                "}\n"
                "const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));\n"
                "MOZ_ASSERT(info->type == JSJitInfo::Setter);\n"
                "JSJitSetterOp setter = info->setter;\n"
                "if (!setter(cx, obj, self, JSJitSetterCallArgs(args))) {\n"
                "  return false;\n"
                "}\n"
                "args.rval().set(JSVAL_VOID);\n"
                "return true;" % self.descriptor.interface.identifier.name))

class CGSpecializedSetter(CGAbstractStaticMethod):
    """
    A class for generating the code for a specialized attribute setter
    that the JIT can call with lower overhead.
    """
    def __init__(self, descriptor, attr):
        self.attr = attr
        name = 'set_' + attr.identifier.name
        args = [ Argument('JSContext*', 'cx'),
                 Argument('JS::Handle<JSObject*>', 'obj'),
                 Argument('%s*' % descriptor.nativeType, 'self'),
                 Argument('JSJitSetterCallArgs', 'args')]
        CGAbstractStaticMethod.__init__(self, descriptor, name, "bool", args)

    def definition_body(self):
        nativeName = CGSpecializedSetter.makeNativeName(self.descriptor,
                                                        self.attr)
        return CGIndenter(CGSetterCall(self.attr.type, nativeName,
                                       self.descriptor, self.attr)).define()

    @staticmethod
    def makeNativeName(descriptor, attr):
        name = attr.identifier.name
        return "Set" + MakeNativeName(descriptor.binaryNames.get(name, name))

class CGStaticSetter(CGAbstractStaticBindingMethod):
    """
    A class for generating the C++ code for an IDL static attribute setter.
    """
    def __init__(self, descriptor, attr):
        self.attr = attr
        name = 'set_' + attr.identifier.name
        CGAbstractStaticBindingMethod.__init__(self, descriptor, name)

    def generate_code(self):
        nativeName = CGSpecializedSetter.makeNativeName(self.descriptor,
                                                        self.attr)
        checkForArg = CGGeneric("""if (args.length() == 0) {
  return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "%s setter");
}""" % self.attr.identifier.name)
        call = CGSetterCall(self.attr.type, nativeName, self.descriptor,
                            self.attr)
        return CGIndenter(CGList([ checkForArg, call ], "\n"))

class CGSpecializedForwardingSetter(CGSpecializedSetter):
    """
    A class for generating the code for a specialized attribute setter with
    PutForwards that the JIT can call with lower overhead.
    """
    def __init__(self, descriptor, attr):
        CGSpecializedSetter.__init__(self, descriptor, attr)

    def definition_body(self):
        attrName = self.attr.identifier.name
        forwardToAttrName = self.attr.getExtendedAttribute("PutForwards")[0]
        
        assert all(ord(c) < 128 for c in attrName)
        assert all(ord(c) < 128 for c in forwardToAttrName)
        return CGIndenter(CGGeneric("""JS::RootedValue v(cx);
if (!JS_GetProperty(cx, obj, "%s", &v)) {
  return false;
}

if (!v.isObject()) {
  return ThrowErrorMessage(cx, MSG_NOT_OBJECT, "%s.%s");
}

return JS_SetProperty(cx, &v.toObject(), "%s", args[0]);""" % (attrName, self.descriptor.interface.identifier.name, attrName, forwardToAttrName))).define()

def memberIsCreator(member):
    return member.getExtendedAttribute("Creator") is not None

class CGMemberJITInfo(CGThing):
    """
    A class for generating the JITInfo for a property that points to
    our specialized getter and setter.
    """
    def __init__(self, descriptor, member):
        self.member = member
        self.descriptor = descriptor

    def declare(self):
        return ""

    def defineJitInfo(self, infoName, opName, opType, infallible, constant,
                      pure, returnTypes):
        assert(not constant or pure) 
        protoID = "prototypes::id::%s" % self.descriptor.name
        depth = "PrototypeTraits<%s>::Depth" % protoID
        failstr = toStringBool(infallible)
        conststr = toStringBool(constant)
        purestr = toStringBool(pure)
        returnType = reduce(CGMemberJITInfo.getSingleReturnType, returnTypes,
                            "")
        return ("\n"
                "static const JSJitInfo %s = {\n"
                "  { %s },\n"
                "  %s,\n"
                "  %s,\n"
                "  JSJitInfo::%s,\n"
                "  %s,  /* isInfallible. False in setters. */\n"
                "  %s,  /* isConstant. Only relevant for getters. */\n"
                "  %s,  /* isPure.  Only relevant for getters. */\n"
                "  %s   /* returnType.  Only relevant for getters/methods. */\n"
                "};\n" % (infoName, opName, protoID, depth, opType, failstr,
                          conststr, purestr, returnType))

    def define(self):
        if self.member.isAttr():
            getterinfo = ("%s_getterinfo" % self.member.identifier.name)
            
            
            getter = ("(JSJitGetterOp)get_%s" % self.member.identifier.name)
            getterinfal = "infallible" in self.descriptor.getExtendedAttributes(self.member, getter=True)
            getterconst = (self.member.getExtendedAttribute("SameObject") or
                           self.member.getExtendedAttribute("Constant"))
            getterpure = getterconst or self.member.getExtendedAttribute("Pure")
            assert (getterinfal or (not getterconst and not getterpure))

            getterinfal = getterinfal and infallibleForMember(self.member, self.member.type, self.descriptor)
            result = self.defineJitInfo(getterinfo, getter, "Getter",
                                        getterinfal, getterconst, getterpure,
                                        [self.member.type])
            if not self.member.readonly or self.member.getExtendedAttribute("PutForwards") is not None:
                setterinfo = ("%s_setterinfo" % self.member.identifier.name)
                
                
                setter = ("(JSJitGetterOp)set_%s" % self.member.identifier.name)
                
                result += self.defineJitInfo(setterinfo, setter, "Setter",
                                             False, False, False,
                                             [BuiltinTypes[IDLBuiltinType.Types.void]])
            return result
        if self.member.isMethod():
            methodinfo = ("%s_methodinfo" % self.member.identifier.name)
            name = CppKeywords.checkMethodName(self.member.identifier.name)
            
            method = ("(JSJitGetterOp)%s" % name)

            
            
            
            sigs = self.member.signatures()
            if len(sigs) != 1:
                
                
                methodInfal = False
            else:
                sig = sigs[0]
                if (len(sig[1]) != 0 or
                    not infallibleForMember(self.member, sig[0], self.descriptor)):
                    
                    methodInfal = False
                else:
                    methodInfal = "infallible" in self.descriptor.getExtendedAttributes(self.member)

            result = self.defineJitInfo(methodinfo, method, "Method",
                                        methodInfal, False, False,
                                        [s[0] for s in sigs])
            return result
        raise TypeError("Illegal member type to CGPropertyJITInfo")

    @staticmethod
    def getJSReturnTypeTag(t):
        if t.nullable():
            
            return "JSVAL_TYPE_UNKNOWN"
        if t.isVoid():
            
            return "JSVAL_TYPE_UNDEFINED"
        if t.isArray():
            
            assert False
        if t.isSequence():
            return "JSVAL_TYPE_OBJECT"
        if t.isGeckoInterface():
            return "JSVAL_TYPE_OBJECT"
        if t.isString():
            return "JSVAL_TYPE_STRING"
        if t.isEnum():
            return "JSVAL_TYPE_STRING"
        if t.isCallback():
            return "JSVAL_TYPE_OBJECT"
        if t.isAny():
            
            return "JSVAL_TYPE_UNKNOWN"
        if t.isObject():
            return "JSVAL_TYPE_OBJECT"
        if t.isSpiderMonkeyInterface():
            return "JSVAL_TYPE_OBJECT"
        if t.isUnion():
            u = t.unroll();
            if u.hasNullableType:
                
                return "JSVAL_TYPE_UNKNOWN"
            return reduce(CGMemberJITInfo.getSingleReturnType,
                          u.flatMemberTypes, "")
        if t.isDictionary():
            return "JSVAL_TYPE_OBJECT"
        if t.isDate():
            return "JSVAL_TYPE_OBJECT"
        if not t.isPrimitive():
            raise TypeError("No idea what type " + str(t) + " is.")
        tag = t.tag()
        if tag in [IDLType.Tags.int8, IDLType.Tags.uint8,
                   IDLType.Tags.int16, IDLType.Tags.uint16,
                   IDLType.Tags.int32, IDLType.Tags.bool]:
            return "JSVAL_TYPE_INT32"
        if tag in [IDLType.Tags.int64, IDLType.Tags.uint64,
                   IDLType.Tags.unrestricted_float, IDLType.Tags.float,
                   IDLType.Tags.unrestricted_double, IDLType.Tags.double]:
            
            
            
            return "JSVAL_TYPE_DOUBLE"
        if tag != IDLType.Tags.uint32:
            raise TypeError("No idea what type " + str(t) + " is.")
        
        return "JSVAL_TYPE_DOUBLE"

    @staticmethod
    def getSingleReturnType(existingType, t):
        type = CGMemberJITInfo.getJSReturnTypeTag(t)
        if existingType == "":
            
            return type

        if type == existingType:
            return existingType
        if ((type == "JSVAL_TYPE_DOUBLE" and
             existingType == "JSVAL_TYPE_INT32") or
            (existingType == "JSVAL_TYPE_DOUBLE" and
             type == "JSVAL_TYPE_INT32")):
            
            return "JSVAL_TYPE_DOUBLE"
        
        return "JSVAL_TYPE_UNKNOWN"

def getEnumValueName(value):
    
    
    
    
    
    
    if re.match("[^\x20-\x7E]", value):
        raise SyntaxError('Enum value "' + value + '" contains non-ASCII characters')
    if re.match("^[0-9]", value):
        return '_' + value
    value = re.sub(r'[^0-9A-Za-z_]', '_', value)
    if re.match("^_[A-Z]|__", value):
        raise SyntaxError('Enum value "' + value + '" is reserved by the C++ spec')
    if value == "_empty":
        raise SyntaxError('"_empty" is not an IDL enum value we support yet')
    if value == "":
        return "_empty"
    return MakeNativeName(value)

class CGEnum(CGThing):
    def __init__(self, enum):
        CGThing.__init__(self)
        self.enum = enum

    def stringsNamespace(self):
        return self.enum.identifier.name + "Values"

    def nEnumStrings(self):
        return len(self.enum.values()) + 1

    def declare(self):
        enumName = self.enum.identifier.name
        strings = CGNamespace(self.stringsNamespace(),
                              CGGeneric(declare="extern const EnumEntry %s[%d];\n"
                                        % (ENUM_ENTRY_VARIABLE_NAME, self.nEnumStrings())))

        return """
MOZ_BEGIN_ENUM_CLASS(%s, uint32_t)
  %s
MOZ_END_ENUM_CLASS(%s)

""" % (enumName, ",\n  ".join(map(getEnumValueName, self.enum.values())),
       enumName) + strings.declare()

    def define(self):
        strings = """
  extern const EnumEntry %s[%d] = {
    %s,
    { nullptr, 0 }
  };
""" % (ENUM_ENTRY_VARIABLE_NAME, self.nEnumStrings(),
       ",\n    ".join(['{"' + val + '", ' + str(len(val)) + '}' for val in self.enum.values()]))
        return CGNamespace(self.stringsNamespace(), CGGeneric(define=strings)).define()

    def deps(self):
        return self.enum.getDeps()

def getUnionAccessorSignatureType(type, descriptorProvider):
    """
    Returns the types that are used in the getter and setter signatures for
    union types
    """
    if type.isArray():
        raise TypeError("Can't handle array arguments yet")

    if type.isSequence():
        nullable = type.nullable();
        if nullable:
            type = type.inner.inner
        else:
            type = type.inner
        
        
        elementInfo = getJSToNativeConversionInfo(type, descriptorProvider,
                                                  isMember="Sequence")
        typeName = CGTemplatedType("Sequence", elementInfo.declType,
                                   isReference=True)
        if nullable:
            typeName = CGTemplatedType("Nullable", typeName, isReference=True)

        return typeName

    if type.isUnion():
        typeName = CGGeneric(type.name)
        if type.nullable():
            typeName = CGTemplatedType("Nullable", typeName, isReference=True)

        return typeName

    if type.isGeckoInterface():
        descriptor = descriptorProvider.getDescriptor(
            type.unroll().inner.identifier.name)
        typeName = CGGeneric(descriptor.nativeType)
        
        if type.nullable() or type.unroll().inner.isExternal():
            typeName = CGWrapper(typeName, post="*")
        else:
            typeName = CGWrapper(typeName, post="&")
        return typeName

    if type.isSpiderMonkeyInterface():
        typeName = CGGeneric(type.name)
        if type.nullable():
            typeName = CGTemplatedType("Nullable", typeName)
        return CGWrapper(typeName, post="&")

    if type.isDOMString():
        return CGGeneric("const nsAString&")

    if type.isByteString():
        return CGGeneric("const nsCString&")

    if type.isEnum():
        if type.nullable():
            raise TypeError("We don't support nullable enumerated arguments or "
                            "union members yet")
        return CGGeneric(type.inner.identifier.name)

    if type.isCallback():
        if descriptorProvider.workers:
            if type.nullable():
                return CGGeneric("JSObject*")
            return CGGeneric("JSObject&")
        if type.nullable():
            typeName = "%s*"
        else:
            typeName = "%s&"
        return CGGeneric(typeName % type.unroll().identifier.name)

    if type.isAny():
        return CGGeneric("JS::Value")

    if type.isObject():
        return CGGeneric("JSObject*")

    if not type.isPrimitive():
        raise TypeError("Need native type for argument type '%s'" % str(type))

    typeName = CGGeneric(builtinNames[type.tag()])
    if type.nullable():
        typeName = CGTemplatedType("Nullable", typeName, isReference=True)
    return typeName

def getUnionTypeTemplateVars(unionType, type, descriptorProvider, isReturnValue=False):
    
    
    
    
    if type.isDictionary() or type.isSequence():
        raise TypeError("Can't handle dictionaries or sequences in unions")

    if type.isGeckoInterface():
        name = type.inner.identifier.name
    elif type.isEnum():
        name = type.inner.identifier.name
    elif type.isArray() or type.isSequence():
        name = str(type)
    else:
        name = type.name

    ctorArgs = "cx" if type.isSpiderMonkeyInterface() else ""

    tryNextCode = ("tryNext = true;\n"
                   "return true;")
    if type.isGeckoInterface():
         tryNextCode = ("if (mUnion.mType != mUnion.eUninitialized) {"
                        "  mUnion.Destroy%s();"
                        "}" % name) + tryNextCode
    conversionInfo = getJSToNativeConversionInfo(
        type, descriptorProvider, failureCode=tryNextCode,
        isDefinitelyObject=True, isInUnionReturnValue=isReturnValue,
        sourceDescription="member of %s" % unionType)

    
    
    structType = conversionInfo.declType.define()
    if structType.startswith("const "):
        structType = structType[6:]
    externalType = getUnionAccessorSignatureType(type, descriptorProvider).define()

    if type.isObject():
        body = ("mUnion.mValue.mObject.SetValue(cx, obj);\n"
                "mUnion.mType = mUnion.eObject;")
        setter = ClassMethod("SetToObject", "void",
                             [Argument("JSContext*", "cx"),
                              Argument("JSObject*", "obj")],
                             inline=True, bodyInHeader=True,
                             body=body)

    else:
        jsConversion = string.Template(conversionInfo.template).substitute(
            {
                "val": "value",
                "mutableVal": "pvalue",
                "declName": "SetAs" + name + "(%s)" % ctorArgs,
                "holderName": "m" + name + "Holder",
                }
            )
        jsConversion = CGWrapper(CGGeneric(jsConversion),
                                 pre="tryNext = false;\n",
                                 post="\n"
                                      "return true;")
        setter = ClassMethod("TrySetTo" + name, "bool",
                             [Argument("JSContext*", "cx"),
                              Argument("JS::Handle<JS::Value>", "value"),
                              Argument("JS::MutableHandle<JS::Value>", "pvalue"),
                              Argument("bool&", "tryNext")],
                             inline=True, bodyInHeader=True,
                             body=jsConversion.define())

    return {
                "name": name,
                "structType": structType,
                "externalType": externalType,
                "setter": setter,
                "holderType": conversionInfo.holderType.define() if conversionInfo.holderType else None,
                "ctorArgs": ctorArgs,
                "ctorArgList": [Argument("JSContext*", "cx")] if type.isSpiderMonkeyInterface() else []
                }

def mapTemplate(template, templateVarArray):
    return map(lambda v: string.Template(template).substitute(v),
               templateVarArray)

class CGUnionStruct(CGThing):
    def __init__(self, type, descriptorProvider, isReturnValue=False):
        CGThing.__init__(self)
        self.type = type.unroll()
        self.descriptorProvider = descriptorProvider
        self.isReturnValue = isReturnValue
        self.struct = self.getStruct()

    def declare(self):
        return self.struct.declare()

    def define(self):
        return self.struct.define()

    def getStruct(self):

        members = [ClassMember("mType", "Type", body="eUninitialized"),
                   ClassMember("mValue", "Value")]
        ctor = ClassConstructor([], bodyInHeader=True, visibility="public",
                                explicit=True)

        methods = []
        enumValues = ["eUninitialized"]
        toJSValCases = [CGCase("eUninitialized", CGGeneric("return false;"))]
        destructorCases = [CGCase("eUninitialized", None)]
        unionValues = []
        if self.type.hasNullableType:
            enumValues.append("eNull")
            methods.append(ClassMethod("IsNull", "bool", [], const=True, inline=True,
                                       body="return mType == eNull;",
                                       bodyInHeader=True))
            methods.append(ClassMethod("SetNull", "void", [], inline=True,
                                       body="mType = eNull;",
                                       bodyInHeader=True))
            destructorCases.append(CGCase("eNull", None))
            toJSValCases.append(CGCase("eNull", CGGeneric("rval.setNull();\n"
                                                          "return true;")))

        for t in self.type.flatMemberTypes:
            vars = getUnionTypeTemplateVars(self.type,
                                            t, self.descriptorProvider,
                                            isReturnValue=self.isReturnValue)
            if vars["name"] != "Object":
                body=string.Template("mType = e${name};\n"
                                     "return mValue.m${name}.SetValue(${ctorArgs});").substitute(vars)
                
                
                
                methods.append(ClassMethod("SetAs" + vars["name"],
                                           vars["structType"] + "&",
                                           vars["ctorArgList"],
                                           bodyInHeader=not self.isReturnValue,
                                           body=body))
            body = string.Template('MOZ_ASSERT(Is${name}(), "Wrong type!");\n'
                                   'mValue.m${name}.Destroy();\n'
                                   'mType = eUninitialized;').substitute(vars)
            methods.append(ClassMethod("Destroy" + vars["name"],
                                       "void",
                                       [],
                                       visibility="private",
                                       bodyInHeader=not self.isReturnValue,
                                       body=body))
            body = string.Template("return mType == e${name};").substitute(vars)
            methods.append(ClassMethod("Is" + vars["name"],
                                       "bool",
                                       [],
                                       const=True,
                                       bodyInHeader=True,
                                       body=body))
            if not self.isReturnValue:
                body = string.Template('MOZ_ASSERT(Is${name}(), "Wrong type!");\n'
                                       'return const_cast<${structType}&>(mValue.m${name}.Value());').substitute(vars)
                methods.append(ClassMethod("GetAs" + vars["name"],
                                           vars["externalType"],
                                           [],
                                           const=True,
                                           bodyInHeader=True,
                                           body=body))
            unionValues.append(string.Template("UnionMember<${structType} > "
                                               "m${name}").substitute(vars))
            enumValues.append("e" + vars["name"])

            toJSValCases.append(CGCase("e" + vars["name"],
                                       self.getConversionToJS(vars, t)))
            destructorCases.append(CGCase("e" + vars["name"],
                                          CGGeneric("Destroy%s();"
                                                     % vars["name"])))

        dtor = CGSwitch("mType", destructorCases).define()

        methods.append(ClassMethod("ToJSVal", "bool", [
                                   Argument("JSContext*", "cx"),
                                   Argument("JS::Handle<JSObject*>", "scopeObj"),
                                   Argument("JS::MutableHandle<JS::Value>", "rval")
        ], body=CGSwitch("mType", toJSValCases,
                         default=CGGeneric("return false;")).define(), const=True))

        friend="  friend class %sArgument;\n" % str(self.type) if not self.isReturnValue else ""
        return CGClass(str(self.type) + ("ReturnValue" if self.isReturnValue else ""),
                       members=members,
                       constructors=[ctor],
                       methods=methods,
                       disallowCopyConstruction=True,
                       extradeclarations=friend,
                       destructor=ClassDestructor(visibility="public",
                                                  body=dtor,
                                                  bodyInHeader=not self.isReturnValue),
                       enums=[ClassEnum("Type", enumValues, visibility="private")],
                       unions=[ClassUnion("Value", unionValues, visibility="private")])

    def getConversionToJS(self, templateVars, type):
        assert not type.nullable() 
        val = "mValue.m%(name)s.Value()" % templateVars
        wrapCode = wrapForType(
            type, self.descriptorProvider,
            {
                "jsvalRef": "rval",
                "jsvalHandle": "rval",
                "obj": "scopeObj",
                "result": val,
                "typedArraysAreStructs": True
                })
        return CGGeneric(wrapCode)

class CGUnionConversionStruct(CGThing):
    def __init__(self, type, descriptorProvider):
        CGThing.__init__(self)
        self.type = type.unroll()
        self.descriptorProvider = descriptorProvider

    def declare(self):

        structName = str(self.type)
        members = [ClassMember("mUnion", structName + "&",
                               body="const_cast<%s&>(aUnion)" % structName)]
        
        ctor = ClassConstructor([Argument("const %s&" % structName, "aUnion")],
                                bodyInHeader=True,
                                visibility="public",
                                explicit=True)
        methods = []

        if self.type.hasNullableType:
            methods.append(ClassMethod("SetNull", "bool", [],
                                       body=("mUnion.mType = mUnion.eNull;\n"
                                             "return true;"),
                                       inline=True, bodyInHeader=True))

        for t in self.type.flatMemberTypes:
            vars = getUnionTypeTemplateVars(self.type,
                                            t, self.descriptorProvider)
            methods.append(vars["setter"])
            if vars["name"] != "Object":
                body=string.Template("mUnion.mType = mUnion.e${name};\n"
                                     "return mUnion.mValue.m${name}.SetValue(${ctorArgs});").substitute(vars)
                methods.append(ClassMethod("SetAs" + vars["name"],
                                           vars["structType"] + "&",
                                           vars["ctorArgList"],
                                           bodyInHeader=True,
                                           body=body,
                                           visibility="private"))
            if vars["holderType"] is not None:
                members.append(ClassMember("m%sHolder" % vars["name"],
                                           vars["holderType"]))

        return CGClass(structName + "Argument",
                       members=members,
                       constructors=[ctor],
                       methods=methods,
                       disallowCopyConstruction=True).declare()

    def define(self):
        return """
"""

class ClassItem:
    """ Use with CGClass """
    def __init__(self, name, visibility):
        self.name = name
        self.visibility = visibility
    def declare(self, cgClass):
        assert False
    def define(self, cgClass):
        assert False

class ClassBase(ClassItem):
    def __init__(self, name, visibility='public'):
        ClassItem.__init__(self, name, visibility)
    def declare(self, cgClass):
        return '%s %s' % (self.visibility, self.name)
    def define(self, cgClass):
        
        return ''

class ClassMethod(ClassItem):
    def __init__(self, name, returnType, args, inline=False, static=False,
                 virtual=False, const=False, bodyInHeader=False,
                 templateArgs=None, visibility='public', body=None,
                 breakAfterReturnDecl="\n",
                 breakAfterSelf="\n", override=False):
        """
        override indicates whether to flag the method as MOZ_OVERRIDE
        """
        assert not override or virtual
        self.returnType = returnType
        self.args = args
        self.inline = inline or bodyInHeader
        self.static = static
        self.virtual = virtual
        self.const = const
        self.bodyInHeader = bodyInHeader
        self.templateArgs = templateArgs
        self.body = body
        self.breakAfterReturnDecl = breakAfterReturnDecl
        self.breakAfterSelf = breakAfterSelf
        self.override = override
        ClassItem.__init__(self, name, visibility)

    def getDecorators(self, declaring):
        decorators = []
        if self.inline:
            decorators.append('inline')
        if declaring:
            if self.static:
                decorators.append('static')
            if self.virtual:
                decorators.append('virtual')
        if decorators:
            return ' '.join(decorators) + ' '
        return ''

    def getBody(self):
        
        assert self.body is not None
        return self.body

    def declare(self, cgClass):
        templateClause = 'template <%s>\n' % ', '.join(self.templateArgs) \
                         if self.bodyInHeader and self.templateArgs else ''
        args = ', '.join([a.declare() for a in self.args])
        if self.bodyInHeader:
            body = CGIndenter(CGGeneric(self.getBody())).define()
            body = '\n{\n' + body + '\n}'
        else:
           body = ';'

        return string.Template("${templateClause}${decorators}${returnType}%s"
                               "${name}(${args})${const}${override}${body}%s" %
                               (self.breakAfterReturnDecl, self.breakAfterSelf)
                               ).substitute({
                'templateClause': templateClause,
                'decorators': self.getDecorators(True),
                'returnType': self.returnType,
                'name': self.name,
                'const': ' const' if self.const else '',
                'override': ' MOZ_OVERRIDE' if self.override else '',
                'args': args,
                'body': body
                })

    def define(self, cgClass):
        if self.bodyInHeader:
            return ''

        templateArgs = cgClass.templateArgs
        if templateArgs:
            if cgClass.templateSpecialization:
                templateArgs = \
                    templateArgs[len(cgClass.templateSpecialization):]

        if templateArgs:
            templateClause = \
                'template <%s>\n' % ', '.join([str(a) for a in templateArgs])
        else:
            templateClause = ''

        args = ', '.join([a.define() for a in self.args])

        body = CGIndenter(CGGeneric(self.getBody())).define()

        return string.Template("""${templateClause}${decorators}${returnType}
${className}::${name}(${args})${const}
{
${body}
}
""").substitute({ 'templateClause': templateClause,
                  'decorators': self.getDecorators(False),
                  'returnType': self.returnType,
                  'className': cgClass.getNameString(),
                  'name': self.name,
                  'args': args,
                  'const': ' const' if self.const else '',
                  'body': body })

class ClassUsingDeclaration(ClassItem):
    """"
    Used for importing a name from a base class into a CGClass

    baseClass is the name of the base class to import the name from

    name is the name to import

    visibility determines the visibility of the name (public,
    protected, private), defaults to public.
    """
    def __init__(self, baseClass, name, visibility='public'):
        self.baseClass = baseClass
        ClassItem.__init__(self, name, visibility)

    def declare(self, cgClass):
        return string.Template("""using ${baseClass}::${name};
""").substitute({ 'baseClass': self.baseClass,
                  'name': self.name })

    def define(self, cgClass):
        return ''

class ClassConstructor(ClassItem):
    """
    Used for adding a constructor to a CGClass.
    
    args is a list of Argument objects that are the arguments taken by the
    constructor.
    
    inline should be True if the constructor should be marked inline.

    bodyInHeader should be True if the body should be placed in the class
    declaration in the header.

    visibility determines the visibility of the constructor (public,
    protected, private), defaults to private.

    explicit should be True if the constructor should be marked explicit.

    baseConstructors is a list of strings containing calls to base constructors,
    defaults to None.

    body contains a string with the code for the constructor, defaults to empty.
    """
    def __init__(self, args, inline=False, bodyInHeader=False,
                 visibility="private", explicit=False, baseConstructors=None,
                 body=""):
        self.args = args
        self.inline = inline or bodyInHeader
        self.bodyInHeader = bodyInHeader
        self.explicit = explicit
        self.baseConstructors = baseConstructors or []
        self.body = body
        ClassItem.__init__(self, None, visibility)

    def getDecorators(self, declaring):
        decorators = []
        if self.explicit:
            decorators.append('explicit')
        if self.inline and declaring:
            decorators.append('inline')
        if decorators:
            return ' '.join(decorators) + ' '
        return ''

    def getInitializationList(self, cgClass):
        items = [str(c) for c in self.baseConstructors]
        for m in cgClass.members:
            if not m.static:
                initialize = m.body
                if initialize:
                    items.append(m.name + "(" + initialize + ")")
            
        if len(items) > 0:
            return '\n  : ' + ',\n    '.join(items)
        return ''

    def getBody(self):
        return self.body

    def declare(self, cgClass):
        args = ', '.join([a.declare() for a in self.args])
        if self.bodyInHeader:
            body = '  ' + self.getBody();
            body = stripTrailingWhitespace(body.replace('\n', '\n  '))
            if len(body) > 0:
                body += '\n'
            body = self.getInitializationList(cgClass) + '\n{\n' + body + '}'
        else:
            body = ';'

        return string.Template("""${decorators}${className}(${args})${body}
""").substitute({ 'decorators': self.getDecorators(True),
                  'className': cgClass.getNameString(),
                  'args': args,
                  'body': body })

    def define(self, cgClass):
        if self.bodyInHeader:
            return ''

        args = ', '.join([a.define() for a in self.args])

        body = '  ' + self.getBody()
        body = '\n' + stripTrailingWhitespace(body.replace('\n', '\n  '))
        if len(body) > 0:
            body += '\n'

        return string.Template("""${decorators}
${className}::${className}(${args})${initializationList}
{${body}}
""").substitute({ 'decorators': self.getDecorators(False),
                  'className': cgClass.getNameString(),
                  'args': args,
                  'initializationList': self.getInitializationList(cgClass),
                  'body': body })

class ClassDestructor(ClassItem):
    """
    Used for adding a destructor to a CGClass.

    inline should be True if the destructor should be marked inline.

    bodyInHeader should be True if the body should be placed in the class
    declaration in the header.

    visibility determines the visibility of the destructor (public,
    protected, private), defaults to private.

    body contains a string with the code for the destructor, defaults to empty.

    virtual determines whether the destructor is virtual, defaults to False.
    """
    def __init__(self, inline=False, bodyInHeader=False,
                 visibility="private", body='', virtual=False):
        self.inline = inline or bodyInHeader
        self.bodyInHeader = bodyInHeader
        self.body = body
        self.virtual = virtual
        ClassItem.__init__(self, None, visibility)

    def getDecorators(self, declaring):
        decorators = []
        if self.virtual and declaring:
            decorators.append('virtual')
        if self.inline and declaring:
            decorators.append('inline')
        if decorators:
            return ' '.join(decorators) + ' '
        return ''

    def getBody(self):
        return self.body

    def declare(self, cgClass):
        if self.bodyInHeader:
            body = '  ' + self.getBody();
            body = stripTrailingWhitespace(body.replace('\n', '\n  '))
            if len(body) > 0:
                body += '\n'
            body = '\n{\n' + body + '}'
        else:
            body = ';'

        return string.Template("""${decorators}~${className}()${body}
""").substitute({ 'decorators': self.getDecorators(True),
                  'className': cgClass.getNameString(),
                  'body': body })

    def define(self, cgClass):
        if self.bodyInHeader:
            return ''

        body = '  ' + self.getBody()
        body = '\n' + stripTrailingWhitespace(body.replace('\n', '\n  '))
        if len(body) > 0:
            body += '\n'

        return string.Template("""${decorators}
${className}::~${className}()
{${body}}
""").substitute({ 'decorators': self.getDecorators(False),
                  'className': cgClass.getNameString(),
                  'body': body })

class ClassMember(ClassItem):
    def __init__(self, name, type, visibility="private", static=False,
                 body=None):
        self.type = type;
        self.static = static
        self.body = body
        ClassItem.__init__(self, name, visibility)

    def declare(self, cgClass):
        return '%s%s %s;\n' % ('static ' if self.static else '', self.type,
                               self.name)

    def define(self, cgClass):
        if not self.static:
            return ''
        if self.body:
            body = " = " + self.body
        else:
            body = ""
        return '%s %s::%s%s;\n' % (self.type, cgClass.getNameString(),
                                      self.name, body)

class ClassTypedef(ClassItem):
    def __init__(self, name, type, visibility="public"):
        self.type = type
        ClassItem.__init__(self, name, visibility)

    def declare(self, cgClass):
        return 'typedef %s %s;\n' % (self.type, self.name)

    def define(self, cgClass):
        
        return ''

class ClassEnum(ClassItem):
    def __init__(self, name, entries, values=None, visibility="public"):
        self.entries = entries
        self.values = values
        ClassItem.__init__(self, name, visibility)

    def declare(self, cgClass):
        entries = []
        for i in range(0, len(self.entries)):
            if not self.values or i >= len(self.values):
                entry = '%s' % self.entries[i]
            else:
                entry = '%s = %s' % (self.entries[i], self.values[i])
            entries.append(entry)
        name = '' if not self.name else ' ' + self.name
        return 'enum%s\n{\n  %s\n};\n' % (name, ',\n  '.join(entries))

    def define(self, cgClass):
        
        return ''

class ClassUnion(ClassItem):
    def __init__(self, name, entries, visibility="public"):
        self.entries = [entry + ";" for entry in entries]
        ClassItem.__init__(self, name, visibility)

    def declare(self, cgClass):
        return 'union %s\n{\n  %s\n};\n' % (self.name, '\n  '.join(self.entries))

    def define(self, cgClass):
        
        return ''

class CGClass(CGThing):
    def __init__(self, name, bases=[], members=[], constructors=[],
                 destructor=None, methods=[],
                 typedefs = [], enums=[], unions=[], templateArgs=[],
                 templateSpecialization=[], isStruct=False,
                 disallowCopyConstruction=False, indent='',
                 decorators='',
                 extradeclarations='',
                 extradefinitions=''):
        CGThing.__init__(self)
        self.name = name
        self.bases = bases
        self.members = members
        self.constructors = constructors
        
        
        self.destructors = [destructor] if destructor else []
        self.methods = methods
        self.typedefs = typedefs
        self.enums = enums
        self.unions = unions
        self.templateArgs = templateArgs
        self.templateSpecialization = templateSpecialization
        self.isStruct = isStruct
        self.disallowCopyConstruction = disallowCopyConstruction
        self.indent = indent
        self.defaultVisibility ='public' if isStruct else 'private'
        self.decorators = decorators
        self.extradeclarations = extradeclarations
        self.extradefinitions = extradefinitions

    def getNameString(self):
        className = self.name
        if self.templateSpecialization:
            className = className + \
                '<%s>' % ', '.join([str(a) for a
                                    in self.templateSpecialization])
        return className

    def declare(self):
        result = ''
        if self.templateArgs:
            templateArgs = [a.declare() for a in self.templateArgs]
            templateArgs = templateArgs[len(self.templateSpecialization):]
            result = result + self.indent + 'template <%s>\n' \
                     % ','.join([str(a) for a in templateArgs])

        type = 'struct' if self.isStruct else 'class'

        if self.templateSpecialization:
            specialization = \
                '<%s>' % ', '.join([str(a) for a in self.templateSpecialization])
        else:
            specialization = ''

        myself = '%s%s %s%s' % (self.indent, type, self.name, specialization)
        if self.decorators != '':
            myself += " " + self.decorators
        result += myself

        if self.bases:
            inherit = ' : '
            result += inherit
            
            baseItems = [CGGeneric(b.declare(self)) for b in self.bases]
            bases = baseItems[:1]
            
            bases.extend(CGIndenter(b, len(myself) + len(inherit)) for
                         b in baseItems[1:])
            result += ",\n".join(b.define() for b in bases)

        result = result + '\n%s{\n' % self.indent

        result += CGIndenter(CGGeneric(self.extradeclarations),
                             len(self.indent)).define()

        def declareMembers(cgClass, memberList, defaultVisibility, itemCount,
                           separator=''):
            members = { 'private': [], 'protected': [], 'public': [] }

            for member in memberList:
                members[member.visibility].append(member)


            if defaultVisibility == 'public':
                order = [ 'public', 'protected', 'private' ]
            else:
                order = [ 'private', 'protected', 'public' ]

            result = ''

            lastVisibility = defaultVisibility
            for visibility in order:
                list = members[visibility]
                if list:
                    if visibility != lastVisibility:
                        if itemCount:
                            result = result + '\n'
                        result = result + visibility + ':\n'
                        itemCount = 0
                    for member in list:
                        if itemCount != 0:
                            result = result + separator
                        declaration = member.declare(cgClass)
                        declaration = CGIndenter(CGGeneric(declaration)).define()
                        result = result + declaration
                        itemCount = itemCount + 1
                    lastVisibility = visibility
            return (result, lastVisibility, itemCount)

        if self.disallowCopyConstruction:
            class DisallowedCopyConstructor(object):
                def __init__(self):
                    self.visibility = "private"
                def declare(self, cgClass):
                    name = cgClass.getNameString()
                    return ("%s(const %s&) MOZ_DELETE;\n"
                            "void operator=(const %s) MOZ_DELETE;\n" % (name, name, name))
            disallowedCopyConstructors = [DisallowedCopyConstructor()]
        else:
            disallowedCopyConstructors = []

        order = [(self.enums, ''), (self.unions, ''),
                 (self.typedefs, ''), (self.members, ''),
                 (self.constructors + disallowedCopyConstructors, '\n'),
                 (self.destructors, '\n'), (self.methods, '\n')]

        lastVisibility = self.defaultVisibility
        itemCount = 0
        for (memberList, separator) in order:
            (memberString, lastVisibility, itemCount) = \
                declareMembers(self, memberList, lastVisibility, itemCount,
                               separator)
            if self.indent:
                memberString = CGIndenter(CGGeneric(memberString),
                                          len(self.indent)).define()
            result = result + memberString

        result = result + self.indent + '};\n'
        return result

    def define(self):
        def defineMembers(cgClass, memberList, itemCount, separator=''):
            result = ''
            for member in memberList:
                if itemCount != 0:
                    result = result + separator
                definition = member.define(cgClass)
                if definition:
                    
                    result += definition
                    itemCount += 1
            return (result, itemCount)

        order = [(self.members, ''), (self.constructors, '\n'),
                 (self.destructors, '\n'), (self.methods, '\n')]

        result = self.extradefinitions
        itemCount = 0
        for (memberList, separator) in order:
            (memberString, itemCount) = defineMembers(self, memberList,
                                                      itemCount, separator)
            result = result + memberString
        return result

class CGResolveOwnProperty(CGAbstractStaticMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'),
                Argument('JS::Handle<JSObject*>', 'wrapper'),
                Argument('JS::Handle<JSObject*>', 'obj'),
                Argument('JS::Handle<jsid>', 'id'),
                Argument('JS::MutableHandle<JSPropertyDescriptor>', 'desc'),
                Argument('unsigned', 'flags'),
                ]
        CGAbstractStaticMethod.__init__(self, descriptor, "ResolveOwnProperty",
                                        "bool", args)
    def definition_body(self):
        return """  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc, flags);
"""

class CGResolveOwnPropertyViaNewresolve(CGAbstractBindingMethod):
    """
    An implementation of Xray ResolveOwnProperty stuff for things that have a
    newresolve hook.
    """
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'),
                Argument('JS::Handle<JSObject*>', 'wrapper'),
                Argument('JS::Handle<JSObject*>', 'obj'),
                Argument('JS::Handle<jsid>', 'id'),
                Argument('JS::MutableHandle<JSPropertyDescriptor>', 'desc'),
                Argument('unsigned', 'flags'),
                ]
        CGAbstractBindingMethod.__init__(self, descriptor,
                                         "ResolveOwnPropertyViaNewresolve",
                                         args, getThisObj="",
                                         callArgs="")
    def generate_code(self):
        return CGIndenter(CGGeneric(
                "JS::Rooted<JS::Value> value(cx);\n"
                "if (!self->DoNewResolve(cx, obj, id, &value)) {\n"
                "  return false;\n"
                "}\n"
                "if (!value.isUndefined()) {\n"
                "  FillPropertyDescriptor(desc, wrapper, value, /* readonly = */ false);\n"
                "}\n"
                "return true;"))

class CGEnumerateOwnProperties(CGAbstractStaticMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'),
                Argument('JS::Handle<JSObject*>', 'wrapper'),
                Argument('JS::Handle<JSObject*>', 'obj'),
                Argument('JS::AutoIdVector&', 'props')]
        CGAbstractStaticMethod.__init__(self, descriptor,
                                        "EnumerateOwnProperties", "bool", args)
    def definition_body(self):
        return """  return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);
"""

class CGEnumerateOwnPropertiesViaGetOwnPropertyNames(CGAbstractBindingMethod):
    """
    An implementation of Xray EnumerateOwnProperties stuff for things
    that have a newresolve hook.
    """
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'),
                Argument('JS::Handle<JSObject*>', 'wrapper'),
                Argument('JS::Handle<JSObject*>', 'obj'),
                Argument('JS::AutoIdVector&', 'props')]
        CGAbstractBindingMethod.__init__(self, descriptor,
                                         "EnumerateOwnPropertiesViaGetOwnPropertyNames",
                                         args, getThisObj="",
                                         callArgs="")
    def generate_code(self):
        return CGIndenter(CGGeneric(
                "nsAutoTArray<nsString, 8> names;\n"
                "ErrorResult rv;\n"
                "self->GetOwnPropertyNames(cx, names, rv);\n"
                "rv.WouldReportJSException();\n"
                "if (rv.Failed()) {\n"
                '  return ThrowMethodFailedWithDetails<true>(cx, rv, "%s", "enumerate");\n'
                "}\n"
                '// OK to pass null as "proxy" because it\'s ignored if\n'
                "// shadowPrototypeProperties is true\n"
                "return AppendNamedPropertyIds(cx, JS::NullPtr(), names, true, props);"))

class CGPrototypeTraitsClass(CGClass):
    def __init__(self, descriptor, indent=''):
        templateArgs = [Argument('prototypes::ID', 'PrototypeID')]
        templateSpecialization = ['prototypes::id::' + descriptor.name]
        enums = [ClassEnum('', ['Depth'],
                           [descriptor.interface.inheritanceDepth()])]
        CGClass.__init__(self, 'PrototypeTraits', indent=indent,
                         templateArgs=templateArgs,
                         templateSpecialization=templateSpecialization,
                         enums=enums, isStruct=True)
    def deps(self):
        return set()

class CGClassForwardDeclare(CGThing):
    def __init__(self, name, isStruct=False):
        CGThing.__init__(self)
        self.name = name
        self.isStruct = isStruct
    def declare(self):
        type = 'struct' if self.isStruct else 'class'
        return '%s %s;\n' % (type, self.name)
    def define(self):
        
        return ''
    def deps(self):
        return set()

class CGProxySpecialOperation(CGPerSignatureCall):
    """
    Base class for classes for calling an indexed or named special operation
    (don't use this directly, use the derived classes below).
    """
    def __init__(self, descriptor, operation):
        nativeName = MakeNativeName(descriptor.binaryNames.get(operation, operation))
        operation = descriptor.operations[operation]
        assert len(operation.signatures()) == 1
        signature = operation.signatures()[0]

        (returnType, arguments) = signature

        
        
        CGPerSignatureCall.__init__(self, returnType, arguments, nativeName,
                                    False, descriptor, operation,
                                    len(arguments))

        if operation.isSetter() or operation.isCreator():
            
            argument = arguments[1]
            info = getJSToNativeConversionInfo(
                argument.type, descriptor,
                treatNullAs=argument.treatNullAs,
                treatUndefinedAs=argument.treatUndefinedAs,
                sourceDescription=("value being assigned to %s setter" %
                                   descriptor.interface.identifier.name))
            templateValues = {
                "declName": argument.identifier.name,
                "holderName": argument.identifier.name + "_holder",
                "val": "desc.value()",
                "mutableVal" : "desc.value()",
                "obj": "obj"
            }
            self.cgRoot.prepend(instantiateJSToNativeConversion(info, templateValues))
        elif operation.isGetter() or operation.isDeleter():
            self.cgRoot.prepend(CGGeneric("bool found;"))

    def getArguments(self):
        args = [(a, a.identifier.name) for a in self.arguments]
        if self.idlNode.isGetter() or self.idlNode.isDeleter():
            args.append((FakeArgument(BuiltinTypes[IDLBuiltinType.Types.boolean],
                                      self.idlNode),
                         "found"))
        return args

    def wrap_return_value(self):
        if not self.idlNode.isGetter() or self.templateValues is None:
            return ""

        wrap = CGGeneric(wrapForType(self.returnType, self.descriptor, self.templateValues))
        wrap = CGIfWrapper(wrap, "found")
        return "\n" + wrap.define()

class CGProxyIndexedOperation(CGProxySpecialOperation):
    """
    Class to generate a call to an indexed operation.
    """
    def __init__(self, descriptor, name):
        CGProxySpecialOperation.__init__(self, descriptor, name)
    def define(self):
        
        argName = self.arguments[0].identifier.name
        if argName == "index":
            
            setIndex = ""
        else:
            setIndex = "uint32_t %s = index;\n" % argName
        return (setIndex +
                "%s* self = UnwrapProxy(proxy);\n" +
                CGProxySpecialOperation.define(self))

class CGProxyIndexedGetter(CGProxyIndexedOperation):
    """
    Class to generate a call to an indexed getter. If templateValues is not None
    the returned value will be wrapped with wrapForType using templateValues.
    """
    def __init__(self, descriptor, templateValues=None):
        self.templateValues = templateValues
        CGProxyIndexedOperation.__init__(self, descriptor, 'IndexedGetter')

class CGProxyIndexedPresenceChecker(CGProxyIndexedGetter):
    """
    Class to generate a call that checks whether an indexed property exists.

    For now, we just delegate to CGProxyIndexedGetter
    """
    def __init__(self, descriptor):
        CGProxyIndexedGetter.__init__(self, descriptor)
        self.cgRoot.append(CGGeneric("(void)result;"))

class CGProxyIndexedSetter(CGProxyIndexedOperation):
    """
    Class to generate a call to an indexed setter.
    """
    def __init__(self, descriptor):
        CGProxyIndexedOperation.__init__(self, descriptor, 'IndexedSetter')

class CGProxyNamedOperation(CGProxySpecialOperation):
    """
    Class to generate a call to a named operation.

    'value' is the jsval to use for the name; None indicates that it should be
    gotten from the property id.
    """
    def __init__(self, descriptor, name, value=None):
        CGProxySpecialOperation.__init__(self, descriptor, name)
        self.value = value
    def define(self):
        
        argName = self.arguments[0].identifier.name
        if argName == "id":
            
            idDecl = "JS::Rooted<jsid> id_(cx, id);\n"
            idName = "id_"
        else:
            idDecl = ""
            idName = "id"
        unwrapString = (
            "if (!ConvertJSValueToString(cx, nameVal, &nameVal,\n"
            "                            eStringify, eStringify, %s)) {\n"
            "  return false;\n"
            "}" % argName)
        if self.value is None:
            
            
            unwrapString = CGIfElseWrapper(
                ("MOZ_LIKELY(JSID_IS_ATOM(%s))" % idName),
                CGGeneric(
                    "%s.SetData(js::GetAtomChars(JSID_TO_ATOM(%s)), js::GetAtomLength(JSID_TO_ATOM(%s)));" % (argName, idName, idName)),
                CGGeneric(("nameVal = js::IdToValue(%s);\n" % idName) +
                          unwrapString)).define()
        else:
            unwrapString = ("nameVal = %s;\n" % self.value) + unwrapString

        
        
        
        
        return ("JS::Rooted<JS::Value> nameVal(cx);\n" +
                idDecl +
                ("FakeDependentString %s;\n" % argName) +
                unwrapString +
                ("\n"
                 "\n"
                 "%s* self = UnwrapProxy(proxy);\n" %
                 self.descriptor.nativeType) +
                CGProxySpecialOperation.define(self))

class CGProxyNamedGetter(CGProxyNamedOperation):
    """
    Class to generate a call to an named getter. If templateValues is not None
    the returned value will be wrapped with wrapForType using templateValues.
    'value' is the jsval to use for the name; None indicates that it should be
    gotten from the property id.
    """
    def __init__(self, descriptor, templateValues=None, value=None):
        self.templateValues = templateValues
        CGProxyNamedOperation.__init__(self, descriptor, 'NamedGetter', value)

class CGProxyNamedPresenceChecker(CGProxyNamedGetter):
    """
    Class to generate a call that checks whether a named property exists.

    For now, we just delegate to CGProxyNamedGetter
    """
    def __init__(self, descriptor):
        CGProxyNamedGetter.__init__(self, descriptor)
        self.cgRoot.append(CGGeneric("(void)result;"))

class CGProxyNamedSetter(CGProxyNamedOperation):
    """
    Class to generate a call to a named setter.
    """
    def __init__(self, descriptor):
        CGProxyNamedOperation.__init__(self, descriptor, 'NamedSetter')

class CGProxyIndexedDeleter(CGProxyIndexedOperation):
    """
    Class to generate a call to an indexed deleter.
    """
    def __init__(self, descriptor):
        CGProxyIndexedOperation.__init__(self, descriptor, 'IndexedDeleter')

class CGProxyNamedDeleter(CGProxyNamedOperation):
    """
    Class to generate a call to a named deleter.
    """
    def __init__(self, descriptor):
        CGProxyNamedOperation.__init__(self, descriptor, 'NamedDeleter')

class CGProxyIsProxy(CGAbstractMethod):
    def __init__(self, descriptor):
        args = [Argument('JSObject*', 'obj')]
        CGAbstractMethod.__init__(self, descriptor, "IsProxy", "bool", args, alwaysInline=True)
    def declare(self):
        return ""
    def definition_body(self):
        return "  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();"

class CGProxyUnwrap(CGAbstractMethod):
    def __init__(self, descriptor):
        args = [Argument('JSObject*', 'obj')]
        CGAbstractMethod.__init__(self, descriptor, "UnwrapProxy", descriptor.nativeType + '*', args, alwaysInline=True)
    def declare(self):
        return ""
    def definition_body(self):
        return """  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<%s*>(js::GetProxyPrivate(obj).toPrivate());""" % (self.descriptor.nativeType)

class CGDOMJSProxyHandlerDOMClass(CGThing):
    def __init__(self, descriptor):
        CGThing.__init__(self)
        self.descriptor = descriptor
    def declare(self):
        return ""
    def define(self):
        return """
static const DOMClass Class = """ + DOMClass(self.descriptor) + """;

"""

class CGDOMJSProxyHandler_CGDOMJSProxyHandler(ClassConstructor):
    def __init__(self):
        ClassConstructor.__init__(self, [], inline=True, visibility="private",
                                  baseConstructors=["mozilla::dom::DOMProxyHandler(Class)"])

class CGDOMJSProxyHandler_getOwnPropertyDescriptor(ClassMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'), Argument('JS::Handle<JSObject*>', 'proxy'),
                Argument('JS::Handle<jsid>', 'id'),
                Argument('JS::MutableHandle<JSPropertyDescriptor>', 'desc'),
                Argument('unsigned', 'flags')]
        ClassMethod.__init__(self, "getOwnPropertyDescriptor", "bool", args)
        self.descriptor = descriptor
    def getBody(self):
        indexedGetter = self.descriptor.operations['IndexedGetter']
        indexedSetter = self.descriptor.operations['IndexedSetter']

        setOrIndexedGet = "bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);\n"
        if self.descriptor.supportsIndexedProperties():
            setOrIndexedGet += "int32_t index = GetArrayIndexFromId(cx, id);\n"
            readonly = toStringBool(indexedSetter is None)
            fillDescriptor = "FillPropertyDescriptor(desc, proxy, %s);\nreturn true;" % readonly
            templateValues = {'jsvalRef': 'desc.value()', 'jsvalHandle': 'desc.value()',
                              'obj': 'proxy', 'successCode': fillDescriptor}
            get = ("if (IsArrayIndex(index)) {\n" +
                   CGIndenter(CGProxyIndexedGetter(self.descriptor, templateValues)).define() + "\n" +
                   "}\n") % (self.descriptor.nativeType)

        if UseHolderForUnforgeable(self.descriptor):
            getUnforgeable = """if (!JS_GetPropertyDescriptorById(cx, ${holder}, id, flags, desc)) {
  return false;
}
MOZ_ASSERT_IF(desc.object(), desc.object() == ${holder});"""
            getUnforgeable = CallOnUnforgeableHolder(self.descriptor,
                                                     getUnforgeable, "isXray")
            getUnforgeable += """if (desc.object()) {
  desc.object().set(proxy);
  return !isXray || JS_WrapPropertyDescriptor(cx, desc);
}

"""
        else:
            getUnforgeable = ""

        if indexedSetter or self.descriptor.operations['NamedSetter']:
            setOrIndexedGet += "if (flags & JSRESOLVE_ASSIGNING) {\n"
            if indexedSetter:
                setOrIndexedGet += ("  if (IsArrayIndex(index)) {\n")
                if not 'IndexedCreator' in self.descriptor.operations:
                    
                    
                    
                    
                    assert False
                setOrIndexedGet += ("    FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);\n" +
                                    "    return true;\n" +
                                    "  }\n")
            setOrIndexedGet += CGIndenter(CGGeneric(getUnforgeable)).define()
            if self.descriptor.operations['NamedSetter']:
                if not 'NamedCreator' in self.descriptor.operations:
                    
                    assert False
                create = CGGeneric("FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);\n"
                                   "return true;")
                
                if (self.descriptor.supportsIndexedProperties() and
                    not indexedSetter):
                    create = CGIfWrapper(create, "!IsArrayIndex(index)")
                setOrIndexedGet += CGIndenter(create).define() + "\n"
            setOrIndexedGet += "}"
            if indexedGetter:
                setOrIndexedGet += (" else {\n" +
                                    CGIndenter(CGGeneric(get + "\n" + getUnforgeable)).define() +
                                    "}")
            else:
                setOrIndexedGet += (" else {\n" +
                                    CGIndenter(CGGeneric(getUnforgeable)).define() +
                                    "}")
            setOrIndexedGet += "\n\n"
        else:
            if indexedGetter:
                setOrIndexedGet += ("if (!(flags & JSRESOLVE_ASSIGNING)) {\n" +
                                    CGIndenter(CGGeneric(get)).define() +
                                    "}\n\n")
            setOrIndexedGet += getUnforgeable

        if self.descriptor.supportsNamedProperties():
            readonly = toStringBool(self.descriptor.operations['NamedSetter'] is None)
            fillDescriptor = "FillPropertyDescriptor(desc, proxy, %s);\nreturn true;" % readonly
            templateValues = {'jsvalRef': 'desc.value()', 'jsvalHandle': 'desc.value()',
                              'obj': 'proxy', 'successCode': fillDescriptor}
            condition = "!HasPropertyOnPrototype(cx, proxy, id)"
            if self.descriptor.interface.getExtendedAttribute('OverrideBuiltins'):
                condition = "(!isXray || %s)" % condition
            condition = "!(flags & JSRESOLVE_ASSIGNING) && " + condition
            if self.descriptor.supportsIndexedProperties():
                condition = "!IsArrayIndex(index) && " + condition
            namedGet = ("\n" +
                        CGIfWrapper(CGProxyNamedGetter(self.descriptor, templateValues),
                                    condition).define() +
                        "\n")
        else:
            namedGet = ""

        return setOrIndexedGet + """JS::Rooted<JSObject*> expando(cx);
if (!isXray && (expando = GetExpandoObject(proxy))) {
  if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
    return false;
  }
  if (desc.object()) {
    // Pretend the property lives on the wrapper.
    desc.object().set(proxy);
    return true;
  }
}
""" + namedGet + """
desc.object().set(nullptr);
return true;"""

class CGDOMJSProxyHandler_defineProperty(ClassMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'), Argument('JS::Handle<JSObject*>', 'proxy'),
                Argument('JS::Handle<jsid>', 'id'),
                Argument('JS::MutableHandle<JSPropertyDescriptor>', 'desc'),
                Argument('bool*', 'defined')]
        ClassMethod.__init__(self, "defineProperty", "bool", args, virtual=True, override=True)
        self.descriptor = descriptor
    def getBody(self):
        set = ""

        indexedSetter = self.descriptor.operations['IndexedSetter']
        if indexedSetter:
            if not (self.descriptor.operations['IndexedCreator'] is indexedSetter):
                raise TypeError("Can't handle creator that's different from the setter")
            set += ("int32_t index = GetArrayIndexFromId(cx, id);\n" +
                    "if (IsArrayIndex(index)) {\n" +
                    "  *defined = true;" +
                    CGIndenter(CGProxyIndexedSetter(self.descriptor)).define() +
                    "  return true;\n" +
                    "}\n") % (self.descriptor.nativeType)
        elif self.descriptor.supportsIndexedProperties():
            
            
            
            set += ("if (IsArrayIndex(GetArrayIndexFromId(cx, id))) {\n" +
                    "  return ThrowErrorMessage(cx, MSG_NO_PROPERTY_SETTER, \"%s\");\n" +
                    "}\n") % self.descriptor.name

        if UseHolderForUnforgeable(self.descriptor):
            defineOnUnforgeable = ("bool hasUnforgeable;\n"
                                   "if (!JS_HasPropertyById(cx, ${holder}, id, &hasUnforgeable)) {\n"
                                   "  return false;\n"
                                   "}\n"
                                   "if (hasUnforgeable) {\n"
                                   "  *defined = true;" +
                                   "  bool unused;\n"
                                   "  return js_DefineOwnProperty(cx, ${holder}, id, desc, &unused);\n"
                                   "}\n")
            set += CallOnUnforgeableHolder(self.descriptor,
                                           defineOnUnforgeable,
                                           "xpc::WrapperFactory::IsXrayWrapper(proxy)")

        namedSetter = self.descriptor.operations['NamedSetter']
        if namedSetter:
            if not self.descriptor.operations['NamedCreator'] is namedSetter:
                raise TypeError("Can't handle creator that's different from the setter")
            
            
            set += ("*defined = true;\n" +
                    CGProxyNamedSetter(self.descriptor).define() + "\n" +
                    "return true;\n")
        else:
            if self.descriptor.supportsNamedProperties():
                
                
                
                
                
                set += (CGProxyNamedPresenceChecker(self.descriptor).define() + "\n" +
                        "if (found) {\n"
                        "  return ThrowErrorMessage(cx, MSG_NO_PROPERTY_SETTER, \"%s\");\n"
                        "}" % self.descriptor.name)
            set += ("return mozilla::dom::DOMProxyHandler::defineProperty(%s);" %
                    ", ".join(a.name for a in self.args))
        return set

class CGDOMJSProxyHandler_delete(ClassMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'), Argument('JS::Handle<JSObject*>', 'proxy'),
                Argument('JS::Handle<jsid>', 'id'),
                Argument('bool*', 'bp')]
        ClassMethod.__init__(self, "delete_", "bool", args)
        self.descriptor = descriptor

    def getBody(self):
        def getDeleterBody(type):
            """
            type should be "Named" or "Indexed"
            """
            assert type is "Named" or type is "Indexed"
            deleter = self.descriptor.operations[type + 'Deleter']
            if deleter:
                if (not deleter.signatures()[0][0].isPrimitive() or
                    deleter.signatures()[0][0].nullable() or
                    deleter.signatures()[0][0].tag() != IDLType.Tags.bool):
                    setBp = "*bp = true;"
                else:
                    setBp = ("if (found) {\n"
                             "  *bp = result;\n"
                             "} else {\n"
                             "  *bp = true;\n"
                             "}")
                body = (eval("CGProxy%sDeleter" % type)(self.descriptor).define() +
                        setBp)
            elif eval("self.descriptor.supports%sProperties()" % type):
                body = (eval("CGProxy%sPresenceChecker" % type)(self.descriptor).define() +
                        "if (found) {\n"
                        "  *bp = false;\n"
                        "} else {\n"
                        "  *bp = true;\n"
                        "}")
            else:
                body = None
            return body

        delete = """MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
          "Should not have a XrayWrapper here");

"""

        indexedBody = getDeleterBody("Indexed")
        if indexedBody is not None:
            delete += ("int32_t index = GetArrayIndexFromId(cx, id);\n" +
                       "if (IsArrayIndex(index)) {\n" +
                       CGIndenter(CGGeneric(indexedBody)).define() + "\n"
                       "  // We always return here, even if the property was not found\n"
                       "  return true;\n" +
                       "}\n") % self.descriptor.nativeType

        if UseHolderForUnforgeable(self.descriptor):
            unforgeable = ("bool hasUnforgeable;\n"
                           "if (!JS_HasPropertyById(cx, ${holder}, id, &hasUnforgeable)) {\n"
                           "  return false;\n"
                           "}\n"
                           "if (hasUnforgeable) {\n"
                           "  *bp = false;\n"
                           "  return true;\n"
                           "}")
            delete += CallOnUnforgeableHolder(self.descriptor, unforgeable)
            delete += "\n"

        namedBody = getDeleterBody("Named")
        if namedBody is not None:
            
            
            
            delete += (CGGeneric(namedBody).define() + "\n"
                       "if (found) {\n"
                       "  return true;\n"
                       "}\n")
            if not self.descriptor.interface.getExtendedAttribute('OverrideBuiltins'):
                delete = CGIfWrapper(CGGeneric(delete),
                                     "!HasPropertyOnPrototype(cx, proxy, id)").define()
        delete += """

return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);"""

        return delete

class CGDOMJSProxyHandler_getOwnPropertyNames(ClassMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'),
                Argument('JS::Handle<JSObject*>', 'proxy'),
                Argument('JS::AutoIdVector&', 'props')]
        ClassMethod.__init__(self, "getOwnPropertyNames", "bool", args)
        self.descriptor = descriptor
    def getBody(self):
        
        if self.descriptor.supportsIndexedProperties():
            addIndices = """
uint32_t length = UnwrapProxy(proxy)->Length();
MOZ_ASSERT(int32_t(length) >= 0);
for (int32_t i = 0; i < int32_t(length); ++i) {
  if (!props.append(INT_TO_JSID(i))) {
    return false;
  }
}
"""
        else:
            addIndices = ""

        if self.descriptor.supportsNamedProperties():
            if self.descriptor.interface.getExtendedAttribute('OverrideBuiltins'):
                shadow = "!isXray"
            else:
                shadow = "false"
            addNames = """
nsTArray<nsString> names;
UnwrapProxy(proxy)->GetSupportedNames(names);
if (!AppendNamedPropertyIds(cx, proxy, names, %s, props)) {
  return false;
}
""" % shadow
        else:
            addNames = ""

        if UseHolderForUnforgeable(self.descriptor):
            addUnforgeable = (
                "if (!js::GetPropertyNames(cx, ${holder}, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {\n"
                "  return false;\n"
                "}")
            addUnforgeable = CallOnUnforgeableHolder(self.descriptor,
                                                     addUnforgeable,
                                                     "isXray")
        else:
            addUnforgeable = ""
        return """bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
""" + addIndices + addUnforgeable + addNames + """
JS::Rooted<JSObject*> expando(cx);
if (!isXray && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
    !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
  return false;
}

return true;"""

class CGDOMJSProxyHandler_hasOwn(ClassMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'),
                Argument('JS::Handle<JSObject*>', 'proxy'),
                Argument('JS::Handle<jsid>', 'id'),
                Argument('bool*', 'bp')]
        ClassMethod.__init__(self, "hasOwn", "bool", args)
        self.descriptor = descriptor
    def getBody(self):
        if self.descriptor.supportsIndexedProperties():
            indexed = ("int32_t index = GetArrayIndexFromId(cx, id);\n" + 
                       "if (IsArrayIndex(index)) {\n" +
                       CGIndenter(CGProxyIndexedPresenceChecker(self.descriptor)).define() + "\n" +
                       "  *bp = found;\n" +
                       "  return true;\n" +
                       "}\n\n") % (self.descriptor.nativeType)
        else:
            indexed = ""

        if UseHolderForUnforgeable(self.descriptor):
            unforgeable = ("bool b = true;\n"
                           "bool ok = JS_AlreadyHasOwnPropertyById(cx, ${holder}, id, &b);\n"
                           "*bp = !!b;\n"
                           "if (!ok || *bp) {\n"
                           "  return ok;\n"
                           "}")
            unforgeable = CallOnUnforgeableHolder(self.descriptor, unforgeable)
        else:
            unforgeable = ""

        if self.descriptor.supportsNamedProperties():
            
            
            named = (CGProxyNamedPresenceChecker(self.descriptor).define() + "\n" +
                     "*bp = found;\n")
            if not self.descriptor.interface.getExtendedAttribute('OverrideBuiltins'):
                named = CGIfWrapper(CGGeneric(named + "return true;\n"),
                                    "!HasPropertyOnPrototype(cx, proxy, id)").define()
                named += ("\n"
                          "*bp = false;")
        else:
            named = "*bp = false;"

        return """MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
          "Should not have a XrayWrapper here");

""" + indexed + unforgeable + """
JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
if (expando) {
  bool b = true;
  bool ok = JS_HasPropertyById(cx, expando, id, &b);
  *bp = !!b;
  if (!ok || *bp) {
    return ok;
  }
}

""" + named + """
return true;"""

class CGDOMJSProxyHandler_get(ClassMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'),
                Argument('JS::Handle<JSObject*>', 'proxy'),
                Argument('JS::Handle<JSObject*>', 'receiver'),
                Argument('JS::Handle<jsid>', 'id'),
                Argument('JS::MutableHandle<JS::Value>', 'vp')]
        ClassMethod.__init__(self, "get", "bool", args)
        self.descriptor = descriptor
    def getBody(self):
        if UseHolderForUnforgeable(self.descriptor):
            hasUnforgeable = (
                "bool hasUnforgeable;\n"
                 "if (!JS_AlreadyHasOwnPropertyById(cx, ${holder}, id, &hasUnforgeable)) {\n"
                 "  return false;\n"
                 "}\n"
                 "if (hasUnforgeable) {\n"
                 "  return JS_ForwardGetPropertyTo(cx, ${holder}, id, proxy, vp);\n"
                 "}")
            getUnforgeableOrExpando = CallOnUnforgeableHolder(self.descriptor,
                                                              hasUnforgeable)
        else:
            getUnforgeableOrExpando = ""
        getUnforgeableOrExpando += """JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
if (expando) {
  bool hasProp;
  if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
    return false;
  }

  if (hasProp) {
    // Forward the get to the expando object, but our receiver is whatever our
    // receiver is.
    return JS_ForwardGetPropertyTo(cx, expando, id, receiver, vp);
  }
}"""

        templateValues = {'jsvalRef': 'vp', 'jsvalHandle': 'vp', 'obj': 'proxy'}

        if self.descriptor.supportsIndexedProperties():
            getIndexedOrExpando = ("int32_t index = GetArrayIndexFromId(cx, id);\n" +
                                   "if (IsArrayIndex(index)) {\n" +
                                   CGIndenter(CGProxyIndexedGetter(self.descriptor, templateValues)).define()) % (self.descriptor.nativeType)
            getIndexedOrExpando += """
  // Even if we don't have this index, we don't forward the
  // get on to our expando object.
} else {
  %s
}

""" % (stripTrailingWhitespace(getUnforgeableOrExpando.replace('\n', '\n  ')))
        else:
            getIndexedOrExpando = getUnforgeableOrExpando + "\n\n"

        if self.descriptor.supportsNamedProperties():
            getNamed = CGProxyNamedGetter(self.descriptor, templateValues)
            if self.descriptor.supportsIndexedProperties():
                getNamed = CGIfWrapper(getNamed, "!IsArrayIndex(index)")
            getNamed = getNamed.define() + "\n\n"
        else:
            getNamed = ""

        getOnPrototype = """bool foundOnPrototype;
if (!GetPropertyOnPrototype(cx, proxy, id, &foundOnPrototype, vp.address())) {
  return false;
}

if (foundOnPrototype) {
  return true;
}

"""
        if self.descriptor.interface.getExtendedAttribute('OverrideBuiltins'):
            getNamed = getNamed + getOnPrototype
        else:
            getNamed = getOnPrototype + getNamed

        return """MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

""" + getIndexedOrExpando + getNamed + """vp.setUndefined();
return true;"""

class CGDOMJSProxyHandler_className(ClassMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'), Argument('JS::Handle<JSObject*>', 'proxy')]
        ClassMethod.__init__(self, "className", "const char*", args,
                             virtual=True, override=True)
        self.descriptor = descriptor
    def getBody(self):
        return 'return "%s";' % self.descriptor.name

class CGDOMJSProxyHandler_finalizeInBackground(ClassMethod):
    def __init__(self, descriptor):
        args = [Argument('JS::Value', 'priv')]
        ClassMethod.__init__(self, "finalizeInBackground", "bool", args)
        self.descriptor = descriptor
    def getBody(self):
        return ("return false;")

class CGDOMJSProxyHandler_finalize(ClassMethod):
    def __init__(self, descriptor):
        args = [Argument('JSFreeOp*', 'fop'), Argument('JSObject*', 'proxy')]
        ClassMethod.__init__(self, "finalize", "void", args)
        self.descriptor = descriptor
    def getBody(self):
        return ("%s self = UnwrapProxy(proxy);\n\n" % (self.descriptor.nativeType + "*") +
                finalizeHook(self.descriptor, FINALIZE_HOOK_NAME, self.args[0].name).define())

class CGDOMJSProxyHandler_getElementIfPresent(ClassMethod):
    def __init__(self, descriptor):
        args = [Argument('JSContext*', 'cx'),
                Argument('JS::Handle<JSObject*>', 'proxy'),
                Argument('JS::Handle<JSObject*>', 'receiver'),
                Argument('uint32_t', 'index'),
                Argument('JS::MutableHandle<JS::Value>', 'vp'),
                Argument('bool*', 'present')]
        ClassMethod.__init__(self, "getElementIfPresent", "bool", args)
        self.descriptor = descriptor
    def getBody(self):
        successCode = ("*present = found;\n"
                       "return true;")
        templateValues = {'jsvalRef': 'vp', 'jsvalHandle': 'vp',
                          'obj': 'proxy', 'successCode': successCode}
        if self.descriptor.supportsIndexedProperties():
            get = (CGProxyIndexedGetter(self.descriptor, templateValues).define() + "\n"
                   "// We skip the expando object and any named getters if\n"
                   "// there is an indexed getter.\n" +
                   "\n") % (self.descriptor.nativeType)
        else:
            if self.descriptor.supportsNamedProperties():
                get = CGProxyNamedGetter(self.descriptor, templateValues,
                                         "UINT_TO_JSVAL(index)").define()
            get += """

JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
if (expando) {
  bool isPresent;
  if (!JS_GetElementIfPresent(cx, expando, index, expando, vp, &isPresent)) {
    return false;
  }
  if (isPresent) {
    *present = true;
    return true;
  }
}
"""

        return """MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");

""" + get + """
JS::Rooted<JSObject*> proto(cx);
if (!js::GetObjectProto(cx, proxy, &proto)) {
  return false;
}
if (proto) {
  bool isPresent;
  if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
    return false;
  }
  *present = isPresent;
  return true;
}

*present = false;
// Can't Debug_SetValueRangeToCrashOnTouch because it's not public
return true;"""

class CGDOMJSProxyHandler_getInstance(ClassMethod):
    def __init__(self):
        ClassMethod.__init__(self, "getInstance", "DOMProxyHandler*", [], static=True)
    def getBody(self):
        return """static DOMProxyHandler instance;
return &instance;"""

class CGDOMJSProxyHandler(CGClass):
    def __init__(self, descriptor):
        constructors = [CGDOMJSProxyHandler_CGDOMJSProxyHandler()]
        methods = [CGDOMJSProxyHandler_getOwnPropertyDescriptor(descriptor)]
        
        
        
        if (descriptor.operations['IndexedSetter'] or
            descriptor.operations['NamedSetter'] or
            UseHolderForUnforgeable(descriptor)):
            methods.extend([CGDOMJSProxyHandler_defineProperty(descriptor),
                            ClassUsingDeclaration("mozilla::dom::DOMProxyHandler",
                                                  "defineProperty")])
        methods.extend([CGDOMJSProxyHandler_getOwnPropertyNames(descriptor),
                        CGDOMJSProxyHandler_hasOwn(descriptor),
                        CGDOMJSProxyHandler_get(descriptor),
                        CGDOMJSProxyHandler_className(descriptor),
                        CGDOMJSProxyHandler_finalizeInBackground(descriptor),
                        CGDOMJSProxyHandler_finalize(descriptor),
                        CGDOMJSProxyHandler_getElementIfPresent(descriptor),
                        CGDOMJSProxyHandler_getInstance(),
                        CGDOMJSProxyHandler_delete(descriptor)])
        CGClass.__init__(self, 'DOMProxyHandler',
                         bases=[ClassBase('mozilla::dom::DOMProxyHandler')],
                         constructors=constructors,
                         methods=methods)

class CGDOMJSProxyHandlerDeclarer(CGThing):
    """
    A class for declaring a DOMProxyHandler.
    """
    def __init__(self, handlerThing):
        self.handlerThing = handlerThing

    def declare(self):
        
        return ""

    def define(self):
        return self.handlerThing.declare()

class CGDOMJSProxyHandlerDefiner(CGThing):
    """
    A class for defining a DOMProxyHandler.
    """
    def __init__(self, handlerThing):
        self.handlerThing = handlerThing

    def declare(self):
        return ""

    def define(self):
        return self.handlerThing.define()

def stripTrailingWhitespace(text):
    tail = '\n' if text.endswith('\n') else ''
    lines = text.splitlines()
    for i in range(len(lines)):
        lines[i] = lines[i].rstrip()
    return '\n'.join(lines) + tail

class CGDescriptor(CGThing):
    def __init__(self, descriptor):
        CGThing.__init__(self)

        assert not descriptor.concrete or descriptor.interface.hasInterfacePrototypeObject()

        if descriptor.nativeOwnership == 'owned' and (
           descriptor.interface.hasChildInterfaces() or
           descriptor.interface.parent):
           raise TypeError("Owned interface cannot have a parent or children")

        self._deps = descriptor.interface.getDeps()

        cgThings = []
        cgThings.append(CGGeneric(declare="typedef %s NativeType;\n" %
                                  descriptor.nativeType))
        
        
        (hasMethod, hasGetter, hasLenientGetter, hasSetter, hasJsonifier,
            hasLenientSetter) = False, False, False, False, False, False
        for n in descriptor.interface.namedConstructors:
            cgThings.append(CGClassConstructor(descriptor, n,
                                               NamedConstructorName(n)))
        for m in descriptor.interface.members:
            if (m.isMethod() and m == descriptor.operations['Jsonifier']):
                hasJsonifier = True
                hasMethod = True
                jsonifierMethod = m
            elif (m.isMethod() and
                  (not m.isIdentifierLess() or m == descriptor.operations['Stringifier'])):
                if m.isStatic():
                    assert descriptor.interface.hasInterfaceObject
                    cgThings.append(CGStaticMethod(descriptor, m))
                elif descriptor.interface.hasInterfacePrototypeObject():
                    cgThings.append(CGSpecializedMethod(descriptor, m))
                    cgThings.append(CGMemberJITInfo(descriptor, m))
                    hasMethod = True
            elif m.isAttr():
                if m.isStatic():
                    assert descriptor.interface.hasInterfaceObject
                    cgThings.append(CGStaticGetter(descriptor, m))
                elif descriptor.interface.hasInterfacePrototypeObject():
                    cgThings.append(CGSpecializedGetter(descriptor, m))
                    if m.hasLenientThis():
                        hasLenientGetter = True
                    else:
                        hasGetter = True
                if not m.readonly:
                    if m.isStatic():
                        assert descriptor.interface.hasInterfaceObject
                        cgThings.append(CGStaticSetter(descriptor, m))
                    elif descriptor.interface.hasInterfacePrototypeObject():
                        cgThings.append(CGSpecializedSetter(descriptor, m))
                        if m.hasLenientThis():
                            hasLenientSetter = True
                        else:
                            hasSetter = True
                elif m.getExtendedAttribute("PutForwards"):
                    cgThings.append(CGSpecializedForwardingSetter(descriptor, m))
                    hasSetter = True
                if (not m.isStatic() and
                    descriptor.interface.hasInterfacePrototypeObject()):
                    cgThings.append(CGMemberJITInfo(descriptor, m))
        if hasJsonifier:
            cgThings.append(CGJsonifierMethod(descriptor, jsonifierMethod))
            cgThings.append(CGMemberJITInfo(descriptor, jsonifierMethod))
        if hasMethod: cgThings.append(CGGenericMethod(descriptor))
        if hasGetter: cgThings.append(CGGenericGetter(descriptor))
        if hasLenientGetter: cgThings.append(CGGenericGetter(descriptor,
                                                             lenientThis=True))
        if hasSetter: cgThings.append(CGGenericSetter(descriptor))
        if hasLenientSetter: cgThings.append(CGGenericSetter(descriptor,
                                                             lenientThis=True))

        if descriptor.interface.getNavigatorProperty():
            cgThings.append(CGConstructNavigatorObjectHelper(descriptor))
            cgThings.append(CGConstructNavigatorObject(descriptor))

        if descriptor.concrete and not descriptor.proxy:
            if not descriptor.workers and descriptor.wrapperCache:
                cgThings.append(CGAddPropertyHook(descriptor))

            
            
            cgThings.append(CGClassFinalizeHook(descriptor))

            
            if (descriptor.customTrace):
                cgThings.append(CGClassTraceHook(descriptor))

        properties = PropertyArrays(descriptor)
        cgThings.append(CGGeneric(define=str(properties)))
        cgThings.append(CGNativeProperties(descriptor, properties))

        
        
        if not descriptor.workers and descriptor.concrete and descriptor.proxy:
            cgThings.append(CGResolveOwnProperty(descriptor))
            cgThings.append(CGEnumerateOwnProperties(descriptor))
        elif descriptor.interface.getExtendedAttribute("NeedNewResolve"):
            cgThings.append(CGResolveOwnPropertyViaNewresolve(descriptor))
            cgThings.append(CGEnumerateOwnPropertiesViaGetOwnPropertyNames(descriptor))

        
        
        cgThings.append(CGNativePropertyHooks(descriptor, properties))

        if descriptor.interface.hasInterfaceObject():
            cgThings.append(CGClassConstructor(descriptor,
                                               descriptor.interface.ctor()))
            cgThings.append(CGClassHasInstanceHook(descriptor))
            cgThings.append(CGInterfaceObjectJSClass(descriptor, properties))
            if descriptor.needsConstructHookHolder():
                cgThings.append(CGClassConstructHookHolder(descriptor))
            cgThings.append(CGNamedConstructors(descriptor))

        cgThings.append(CGLegacyCallHook(descriptor))
        if descriptor.interface.getExtendedAttribute("NeedNewResolve"):
            cgThings.append(CGNewResolveHook(descriptor))
            cgThings.append(CGEnumerateHook(descriptor))

        if descriptor.interface.hasInterfacePrototypeObject():
            cgThings.append(CGPrototypeJSClass(descriptor, properties))

        if descriptor.interface.hasInterfaceObject():
            cgThings.append(CGDefineDOMInterfaceMethod(descriptor))

        if ((descriptor.interface.hasInterfaceObject() or descriptor.interface.getNavigatorProperty()) and
            not descriptor.interface.isExternal() and
            
            not descriptor.workers):
            prefControlled = descriptor.interface.getExtendedAttribute("PrefControlled")
            havePref = descriptor.interface.getExtendedAttribute("Pref")
            haveChromeOnly = descriptor.interface.getExtendedAttribute("ChromeOnly")
            haveFunc = descriptor.interface.getExtendedAttribute("Func")
            
            if (bool(prefControlled) + bool(havePref) +
                bool(haveChromeOnly) + bool(haveFunc) > 1):
                raise TypeError("Interface %s has more than one of "
                                "'PrefControlled', 'Pref', 'Func', and "
                                "'ChomeOnly' specified", descriptor.name)
            if prefControlled is not None:
                cgThings.append(CGConstructorEnabledViaPrefEnabled(descriptor))
            elif havePref is not None:
                cgThings.append(CGConstructorEnabledViaPref(descriptor))
            elif haveChromeOnly is not None:
                cgThings.append(CGConstructorEnabledChromeOnly(descriptor))
            elif haveFunc is not None:
                cgThings.append(CGConstructorEnabledViaFunc(descriptor))

        if descriptor.concrete:
            if descriptor.proxy:
                cgThings.append(CGGeneric("""static_assert(IsBaseOf<nsISupports, %s >::value,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");

""" % descriptor.nativeType))
                if not descriptor.wrapperCache:
                    raise TypeError("We need a wrappercache to support expandos for proxy-based "
                                    "bindings (" + descriptor.name + ")")
                handlerThing = CGDOMJSProxyHandler(descriptor)
                cgThings.append(CGDOMJSProxyHandlerDeclarer(handlerThing))
                cgThings.append(CGProxyIsProxy(descriptor))
                cgThings.append(CGProxyUnwrap(descriptor))
                cgThings.append(CGDOMJSProxyHandlerDOMClass(descriptor))
                cgThings.append(CGDOMJSProxyHandlerDefiner(handlerThing))
            else:
                cgThings.append(CGDOMJSClass(descriptor))
                cgThings.append(CGGetJSClassMethod(descriptor))

            if descriptor.wrapperCache:
                cgThings.append(CGWrapWithCacheMethod(descriptor, properties))
                cgThings.append(CGWrapMethod(descriptor))
            else:
                cgThings.append(CGWrapNonWrapperCacheMethod(descriptor,
                                                            properties))

        
        
        cgThings.append(CGCreateInterfaceObjectsMethod(descriptor, properties))

        
        
        if descriptor.interface.hasInterfacePrototypeObject():
            cgThings.append(CGGetProtoObjectMethod(descriptor))
        if descriptor.interface.hasInterfaceObject():
            cgThings.append(CGGetConstructorObjectMethod(descriptor))

        cgThings = CGList((CGIndenter(t, declareOnly=True) for t in cgThings), "\n")
        cgThings = CGWrapper(cgThings, pre='\n', post='\n')
        self.cgRoot = CGWrapper(CGNamespace(toBindingNamespace(descriptor.name),
                                            cgThings),
                                post='\n')

    def declare(self):
        return self.cgRoot.declare()
    def define(self):
        return self.cgRoot.define()
    def deps(self):
        return self._deps

class CGNamespacedEnum(CGThing):
    def __init__(self, namespace, enumName, names, values, comment=""):

        if not values:
            values = []

        
        entries = []
        for i in range(0, len(names)):
            if len(values) > i and values[i] is not None:
                entry = "%s = %s" % (names[i], values[i])
            else:
                entry = names[i]
            entries.append(entry)

        
        entries.append('_' + enumName + '_Count')

        
        entries = ['  ' + e for e in entries]

        
        enumstr = comment + 'enum %s\n{\n%s\n};\n' % (enumName, ',\n'.join(entries))
        curr = CGGeneric(declare=enumstr)

        
        curr = CGWrapper(curr, pre='\n',post='\n')

        
        curr = CGNamespace(namespace, curr)

        
        typedef = '\ntypedef %s::%s %s;\n\n' % (namespace, enumName, enumName)
        curr = CGList([curr, CGGeneric(declare=typedef)])

        
        self.node = curr

    def declare(self):
        return self.node.declare()
    def define(self):
        assert False 

class CGDictionary(CGThing):
    def __init__(self, dictionary, descriptorProvider):
        self.dictionary = dictionary
        self.descriptorProvider = descriptorProvider
        self.needToInitIds = len(dictionary.members) > 0
        self.memberInfo = [
            (member,
             getJSToNativeConversionInfo(
                            member.type,
                            descriptorProvider,
                            isMember="Dictionary",
                            isOptional=(not member.defaultValue),
                            defaultValue=member.defaultValue,
                            sourceDescription=("'%s' member of %s" %
                                               (member.identifier.name,
                                                dictionary.identifier.name))))
            for member in dictionary.members ]
        self.structs = self.getStructs()

    def declare(self):
        return self.structs.declare()

    def define(self):
        return self.structs.define()

    def base(self):
        if self.dictionary.parent:
            return self.makeClassName(self.dictionary.parent)
        return "MainThreadDictionaryBase"

    def initMethod(self):
        body = (
            "// Passing a null JSContext is OK only if we're initing from null,\n"
            "// Since in that case we will not have to do any property gets\n"
            "MOZ_ASSERT_IF(!cx, val.isNull());\n")

        if self.needToInitIds:
            initIdText = """${dictName}Atoms* atomsCache = nullptr;
if (cx) {
  atomsCache = GetAtomCache<${dictName}Atoms>(cx);
  if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
    return false;
  }
}

"""
            body += string.Template(initIdText).substitute(
              { "dictName": self.makeClassName(self.dictionary)})

        if self.dictionary.parent:
            body += (
                "// Per spec, we init the parent's members first\n"
                "if (!%s::Init(cx, val)) {\n"
                "  return false;\n"
                "}\n"
                "MOZ_ASSERT(IsConvertibleToDictionary(cx, val));\n"
                "\n") % self.makeClassName(self.dictionary.parent)
        else:
            body += (
                "if (!IsConvertibleToDictionary(cx, val)) {\n"
                "  return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY, sourceDescription);\n"
                "}\n"
                "\n")

        memberInits = [self.getMemberConversion(m).define()
                       for m in self.memberInfo]
        if memberInits:
            body += (
                "bool isNull = val.isNullOrUndefined();\n"
                "// We only need |temp| if !isNull, in which case we have |cx|.\n"
                "Maybe<JS::Rooted<JS::Value> > temp;\n"
                "if (!isNull) {\n"
                "  temp.construct(cx);\n"
                "}\n")
            body += "\n\n".join(memberInits) + "\n"

        body += "return true;"

        return ClassMethod("Init", "bool", [
            Argument('JSContext*', 'cx'),
            Argument('JS::Handle<JS::Value>', 'val'),
            Argument('const char*', 'sourceDescription', default='"Value"')
        ], body=body)

    def initFromJSONMethod(self):
        return ClassMethod("Init", "bool", [
                Argument('const nsAString&', 'aJSON'),
            ], body=(
                "MOZ_ASSERT(NS_IsMainThread());\n"
                "AutoSafeJSContext cx;\n"
                "JS::Rooted<JS::Value> json(cx);\n"
                "bool ok = ParseJSON(cx, aJSON, &json);\n"
                "NS_ENSURE_TRUE(ok, false);\n"
                "return Init(cx, json);"
            ))

    def toObjectMethod(self):
        body = ""
        if self.needToInitIds:
            initIdText = """${dictName}Atoms* atomsCache = GetAtomCache<${dictName}Atoms>(cx);
if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
  return false;
}

"""
            body += string.Template(initIdText).substitute(
              { "dictName": self.makeClassName(self.dictionary)})

        if self.dictionary.parent:
            body += (
                "// Per spec, we define the parent's members first\n"
                "if (!%s::ToObject(cx, parentObject, rval)) {\n"
                "  return false;\n"
                "}\n"
                "JS::Rooted<JSObject*> obj(cx, &rval.toObject());\n"
                "\n") % self.makeClassName(self.dictionary.parent)
        else:
            body += (
                "JS::Rooted<JSObject*> obj(cx, JS_NewObject(cx, nullptr, nullptr, nullptr));\n"
                "if (!obj) {\n"
                "  return false;\n"
                "}\n"
                "rval.set(JS::ObjectValue(*obj));\n"
                "\n")

        body += "\n\n".join(self.getMemberDefinition(m).define()
                            for m in self.memberInfo)
        body += "\n\nreturn true;"

        return ClassMethod("ToObject", "bool", [
            Argument('JSContext*', 'cx'),
            Argument('JS::Handle<JSObject*>', 'parentObject'),
            Argument('JS::MutableHandle<JS::Value>', 'rval'),
        ], const=True, body=body)

    def initIdsMethod(self):
        assert self.needToInitIds
        idinit = [CGGeneric('!InternJSString(cx, atomsCache->%s, "%s")' %
                            (m.identifier.name + "_id", m.identifier.name))
                  for m in self.dictionary.members]
        idinit.reverse();
        idinit = CGList(idinit, " ||\n")
        idinit = CGWrapper(idinit, pre="""
// Initialize these in reverse order so that any failure leaves the first one
// uninitialized.
if (""",
                           post=(") {\n"
                                 "  return false;\n"
                                 "}"),
                           reindent=True)
        body = (
           "MOZ_ASSERT(!*reinterpret_cast<jsid**>(atomsCache));\n"
           "%s\n"
           "return true;") % idinit.define()

        return ClassMethod("InitIds", "bool", [
            Argument("JSContext*", "cx"),
            Argument("%sAtoms*" % self.makeClassName(self.dictionary),
                     "atomsCache"),
        ], static=True, body=body, visibility="private")

    def traceDictionaryMethod(self):
        body = ""
        if self.dictionary.parent:
            cls = self.makeClassName(self.dictionary.parent)
            body += "%s::TraceDictionary(trc);\n" % cls

        memberTraces = [self.getMemberTrace(m)
                        for m in self.dictionary.members
                        if typeNeedsRooting(m.type, self.descriptorProvider)]

        body += "\n\n".join(memberTraces)

        return ClassMethod("TraceDictionary", "void", [
            Argument("JSTracer*", "trc"),
        ], body=body)

    def getStructs(self):
        d = self.dictionary
        selfName = self.makeClassName(d)
        members = [ClassMember(self.makeMemberName(m[0].identifier.name),
                               self.getMemberType(m),
                               visibility="public",
                               body=self.getMemberInitializer(m))
                   for m in self.memberInfo]
        ctor = ClassConstructor([], bodyInHeader=True, visibility="public")
        methods = []

        if self.needToInitIds:
            methods.append(self.initIdsMethod())

        methods.append(self.initMethod())
        methods.append(self.initFromJSONMethod())
        methods.append(self.toObjectMethod())
        methods.append(self.traceDictionaryMethod())

        struct = CGClass(selfName,
            bases=[ClassBase(self.base())],
            members=members,
            constructors=[ctor],
            methods=methods,
            isStruct=True,
            disallowCopyConstruction=True)


        initializerCtor = ClassConstructor([],
            visibility="public",
            body=(
                "// Safe to pass a null context if we pass a null value\n"
                "Init(nullptr, JS::NullHandleValue);"))
        initializerStruct = CGClass(selfName + "Initializer",
            bases=[ClassBase(selfName)],
            constructors=[initializerCtor],
            isStruct=True)

        return CGList([struct, initializerStruct])

    def deps(self):
        return self.dictionary.getDeps()

    @staticmethod
    def makeDictionaryName(dictionary):
        return dictionary.identifier.name

    def makeClassName(self, dictionary):
        return self.makeDictionaryName(dictionary)

    @staticmethod
    def makeMemberName(name):
        return "m" + name[0].upper() + name[1:]

    def getMemberType(self, memberInfo):
        (_, conversionInfo) = memberInfo
        
        assert conversionInfo.holderType is None
        declType = conversionInfo.declType
        if conversionInfo.dealWithOptional:
            declType = CGTemplatedType("Optional", declType)
        return declType.define()

    def getMemberConversion(self, memberInfo):
        (member, conversionInfo) = memberInfo
        replacements = { "val": "temp.ref()",
                         "mutableVal": "&temp.ref()",
                         "declName": self.makeMemberName(member.identifier.name),
                         
                         
                         
                         "holderName": "holder" }
        
        assert conversionInfo.holderType is None
        if conversionInfo.dealWithOptional:
            replacements["declName"] = "(" + replacements["declName"] + ".Value())"
        if member.defaultValue:
            replacements["haveValue"] = "!isNull && !temp.ref().isUndefined()"

        propId = self.makeIdName(member.identifier.name);
        propGet = ("JS_GetPropertyById(cx, &val.toObject(), atomsCache->%s, &temp.ref())" %
                   propId)

        conversionReplacements = {
            "prop": self.makeMemberName(member.identifier.name),
            "convert": string.Template(conversionInfo.template).substitute(replacements),
            "propGet": propGet
            }
        conversion = ("if (!isNull && !${propGet}) {\n"
                      "  return false;\n"
                      "}\n")
        if member.defaultValue:
            conversion += (
                "${convert}")
        else:
            conversion += (
                "if (!isNull && !temp.ref().isUndefined()) {\n"
                "  ${prop}.Construct();\n"
                "${convert}\n"
                "}")
            conversionReplacements["convert"] = CGIndenter(
                CGGeneric(conversionReplacements["convert"])).define()
        
        return CGGeneric(
            string.Template(conversion).substitute(conversionReplacements)
            )

    def getMemberDefinition(self, memberInfo):
        member = memberInfo[0]
        declType = memberInfo[1].declType
        memberLoc = self.makeMemberName(member.identifier.name)
        if member.defaultValue:
            memberData = memberLoc
        else:
            
            memberData = "%s.InternalValue()" % memberLoc

        propDef = (
            'JS_DefinePropertyById(cx, obj, atomsCache->%s, temp, nullptr, nullptr, JSPROP_ENUMERATE)' %
            self.makeIdName(member.identifier.name))

        innerTemplate = wrapForType(
            member.type, self.descriptorProvider,
            {
                'result' : "currentValue",
                'successCode' : ("if (!%s) {\n"
                                 "  return false;\n"
                                 "}\n"
                                 "break;" % propDef),
                'jsvalRef': "temp",
                'jsvalHandle': "&temp",
                'isCreator': False,
                'obj': "parentObject",
                'typedArraysAreStructs': True
            })
        conversion = CGGeneric(innerTemplate)
        conversion = CGWrapper(conversion,
                               pre=("JS::Rooted<JS::Value> temp(cx);\n"
                                    "%s const & currentValue = %s;\n" %
                                    (declType.define(), memberData)
                                    ))

        
        
        
        conversion = CGWrapper(
            CGIndenter(conversion),
            pre=("do {\n"
                 "  // block for our 'break' successCode and scope for 'temp' and 'currentValue'\n"),
            post="\n} while(0);")
        if not member.defaultValue:
            
            conversion = CGIfWrapper(conversion, "%s.WasPassed()" % memberLoc)
        return conversion

    def getMemberTrace(self, member):
        type = member.type;
        assert typeNeedsRooting(type, self.descriptorProvider)
        memberLoc = self.makeMemberName(member.identifier.name)
        if member.defaultValue:
            memberData = memberLoc
        else:
            
            memberData = "%s.Value()" % memberLoc

        memberName = "%s.%s" % (self.makeClassName(self.dictionary),
                                memberLoc)

        if type.isObject():
            trace = CGGeneric('JS_CallObjectTracer(trc, %s, "%s");' %
                              ("&"+memberData, memberName))
        elif type.isAny():
            trace = CGGeneric('JS_CallValueTracer(trc, %s, "%s");' %
                              ("&"+memberData, memberName))
        elif (type.isSequence() or type.isDictionary() or
              type.isSpiderMonkeyInterface()):
            if type.nullable():
                memberNullable = memberData
                memberData = "%s.Value()" % memberData
            if type.isSequence():
                trace = CGGeneric('DoTraceSequence(trc, %s);' % memberData)
            elif type.isDictionary():
                trace = CGGeneric('%s.TraceDictionary(trc);' % memberData)
            else:
                assert type.isSpiderMonkeyInterface()
                trace = CGGeneric('%s.TraceSelf(trc);' % memberData)
            if type.nullable():
                trace = CGIfWrapper(trace, "!%s.IsNull()" % memberNullable)
        else:
            assert 0 

        if not member.defaultValue:
            trace = CGIfWrapper(trace, "%s.WasPassed()" % memberLoc)

        return trace.define()

    def getMemberInitializer(self, memberInfo):
        """
        Get the right initializer for the member.  Most members don't need one,
        but we need to pre-initialize 'any' and 'object' that have a default
        value, so they're safe to trace at all times.
        """
        (member, _) = memberInfo
        if not member.defaultValue:
            
            
            
            return None
        type = member.type
        if type.isAny():
            return "JS::UndefinedValue()"
        if type.isObject():
            return "nullptr"
        return None

    @staticmethod
    def makeIdName(name):
        return name + "_id"

    @staticmethod
    def getDictionaryDependenciesFromType(type):
        if type.isDictionary():
            return set([type.unroll().inner])
        if type.isSequence() or type.isArray():
            return CGDictionary.getDictionaryDependenciesFromType(type.unroll())
        return set()

    @staticmethod
    def getDictionaryDependencies(dictionary):
        deps = set();
        if dictionary.parent:
            deps.add(dictionary.parent)
        for member in dictionary.members:
            deps |= CGDictionary.getDictionaryDependenciesFromType(member.type)
        return deps


class CGRegisterProtos(CGAbstractMethod):
    def __init__(self, config):
        CGAbstractMethod.__init__(self, None, 'Register', 'void',
                                  [Argument('nsScriptNameSpaceManager*', 'aNameSpaceManager')])
        self.config = config

    def _defineMacro(self):
       return """
#define REGISTER_PROTO(_dom_class, _ctor_check) \\
  aNameSpaceManager->RegisterDefineDOMInterface(NS_LITERAL_STRING(#_dom_class), _dom_class##Binding::DefineDOMInterface, _ctor_check);
#define REGISTER_CONSTRUCTOR(_dom_constructor, _dom_class, _ctor_check) \\
  aNameSpaceManager->RegisterDefineDOMInterface(NS_LITERAL_STRING(#_dom_constructor), _dom_class##Binding::DefineDOMInterface, _ctor_check);
#define REGISTER_NAVIGATOR_CONSTRUCTOR(_prop, _dom_class, _ctor_check) \\
  aNameSpaceManager->RegisterNavigatorDOMConstructor(NS_LITERAL_STRING(_prop), _dom_class##Binding::ConstructNavigatorObject, _ctor_check);

"""
    def _undefineMacro(self):
        return """
#undef REGISTER_CONSTRUCTOR
#undef REGISTER_PROTO
#undef REGISTER_NAVIGATOR_CONSTRUCTOR"""
    def _registerProtos(self):
        def getCheck(desc):
            if (desc.interface.getExtendedAttribute("PrefControlled") is None and
                desc.interface.getExtendedAttribute("Pref") is None and
                desc.interface.getExtendedAttribute("ChromeOnly") is None and
                desc.interface.getExtendedAttribute("Func") is None):
                return "nullptr"
            return "%sBinding::ConstructorEnabled" % desc.name
        lines = []
        for desc in self.config.getDescriptors(hasInterfaceObject=True,
                                               isExternal=False,
                                               workers=False,
                                               register=True):
            lines.append("REGISTER_PROTO(%s, %s);" % (desc.name, getCheck(desc)))
            lines.extend("REGISTER_CONSTRUCTOR(%s, %s, %s);" % (n.identifier.name, desc.name, getCheck(desc))
                         for n in desc.interface.namedConstructors)
        for desc in self.config.getDescriptors(isNavigatorProperty=True, register=True):
            propName = desc.interface.getNavigatorProperty()
            assert propName
            lines.append('REGISTER_NAVIGATOR_CONSTRUCTOR("%s", %s, %s);' % (propName, desc.name, getCheck(desc)))
        return '\n'.join(lines) + '\n'
    def definition_body(self):
        return self._defineMacro() + self._registerProtos() + self._undefineMacro()

def dependencySortObjects(objects, dependencyGetter, nameGetter):
    """
    Sort IDL objects with dependencies on each other such that if A
    depends on B then B will come before A.  This is needed for
    declaring C++ classes in the right order, for example.  Objects
    that have no dependencies are just sorted by name.

    objects should be something that can produce a set of objects
    (e.g. a set, iterator, list, etc).

    dependencyGetter is something that, given an object, should return
    the set of objects it depends on.
    """
    
    
    
    
    sortedObjects = []
    objects = set(objects)
    while len(objects) != 0:
        
        
        toMove = [o for o in objects if
                  len(dependencyGetter(o) & objects) == 0]
        if len(toMove) == 0:
            raise TypeError("Loop in dependency graph\n" +
                            "\n".join(o.location for o in objects))
        objects = objects - set(toMove)
        sortedObjects.extend(sorted(toMove, key=nameGetter))
    return sortedObjects


class ForwardDeclarationBuilder:
    """
    Create a canonical representation of a set of namespaced forward
    declarations.
    """
    def __init__(self):
        """
        The set of declarations is represented as a tree of nested namespaces.
        Each tree node has a set of declarations |decls| and a dict |children|.
        Each declaration is a pair consisting of the class name and a boolean
        that is true iff the class is really a struct. |children| maps the
        names of inner namespaces to the declarations in that namespace.
        """
        self.decls = set([])
        self.children = {}

    def _listAdd(self, namespaces, name, isStruct=False):
        """
        Add a forward declaration, where |namespaces| is a list of namespaces.
        |name| should not contain any other namespaces.
        """
        if namespaces:
            child = self.children.setdefault(namespaces[0], ForwardDeclarationBuilder())
            child._listAdd(namespaces[1:], name, isStruct)
        else:
            assert not '::' in name
            self.decls.add((name, isStruct))

    def addInMozillaDom(self, name, isStruct=False):
        """
        Add a forward declaration to the mozilla::dom:: namespace. |name| should not
        contain any other namespaces.
        """
        self._listAdd(["mozilla", "dom"], name, isStruct)

    def add(self, nativeType, isStruct=False):
        """
        Add a forward declaration, where |nativeType| is a string containing
        the type and its namespaces, in the usual C++ way.
        """
        components = nativeType.split('::')
        self._listAdd(components[:-1], components[-1], isStruct)

    def _build(self, atTopLevel):
        """
        Return a codegenerator for the forward declarations.
        """
        decls = []
        if self.decls:
            decls.append(CGList([CGClassForwardDeclare(cname, isStruct)
                                 for (cname, isStruct) in sorted(self.decls)]))
        for namespace, child in sorted(self.children.iteritems()):
            decls.append(CGNamespace(namespace, child._build(atTopLevel=False), declareOnly=True))

        cg = CGList(decls, joiner='\n')
        if not atTopLevel and len(decls) + len(self.decls) > 1:
            cg = CGWrapper(cg, pre='\n', post='\n')
        return cg

    def build(self):
        return self._build(atTopLevel=True)


class CGForwardDeclarations(CGWrapper):
    """
    Code generate the forward declarations for a header file.
    """
    def __init__(self, config, descriptors, mainCallbacks, workerCallbacks,
                 dictionaries, callbackInterfaces):
        builder = ForwardDeclarationBuilder()

        def forwardDeclareForType(t, workerness='both'):
            t = t.unroll()
            if t.isGeckoInterface():
                name = t.inner.identifier.name
                
                if workerness != 'workeronly':
                    try:
                        desc = config.getDescriptor(name, False)
                        builder.add(desc.nativeType)
                    except NoSuchDescriptorError:
                        pass
                
                if workerness != 'mainthreadonly':
                    try:
                        desc = config.getDescriptor(name, True)
                        builder.add(desc.nativeType)
                    except NoSuchDescriptorError:
                        pass
            elif t.isCallback():
                builder.addInMozillaDom(str(t))
            elif t.isDictionary():
                builder.addInMozillaDom(t.inner.identifier.name, isStruct=True)
            elif t.isCallbackInterface():
                builder.addInMozillaDom(t.inner.identifier.name)
            elif t.isUnion():
                builder.addInMozillaDom(str(t))
            
            

        
        for d in descriptors:
            builder.add(d.nativeType)

        
        builder.addInMozillaDom("NativePropertyHooks")

        for callback in mainCallbacks:
            forwardDeclareForType(callback)
            for t in getTypesFromCallback(callback):
                forwardDeclareForType(t, workerness='mainthreadonly')

        for callback in workerCallbacks:
            forwardDeclareForType(callback)
            for t in getTypesFromCallback(callback):
                forwardDeclareForType(t, workerness='workeronly')

        for d in callbackInterfaces:
            builder.add(d.nativeType)
            for t in getTypesFromDescriptor(d):
                forwardDeclareForType(t)

        for d in dictionaries:
            if len(d.members) > 0:
                builder.addInMozillaDom(d.identifier.name + "Atoms", isStruct=True)
            for t in getTypesFromDictionary(d):
                forwardDeclareForType(t)

        CGWrapper.__init__(self, builder.build())


class CGBindingRoot(CGThing):
    """
    Root codegen class for binding generation. Instantiate the class, and call
    declare or define to generate header or cpp code (respectively).
    """
    def __init__(self, config, prefix, webIDLFile):
        bindingHeaders = {}
        descriptors = config.getDescriptors(webIDLFile=webIDLFile,
                                            hasInterfaceOrInterfacePrototypeObject=True,
                                            skipGen=False)
        def descriptorRequiresPreferences(desc):
            iface = desc.interface
            return any(m.getExtendedAttribute("Pref") for m in iface.members + [iface]);
        bindingHeaders["mozilla/Preferences.h"] = any(
            descriptorRequiresPreferences(d) for d in descriptors)
        bindingHeaders["mozilla/dom/NonRefcountedDOMObject.h"] = any(
            d.nativeOwnership == 'owned' for d in descriptors)
        bindingHeaders["mozilla/dom/DOMJSProxyHandler.h"] = any(
            d.concrete and d.proxy for d in descriptors)
        def descriptorHasChromeOnly(desc):
            return (any(isChromeOnly(a) for a in desc.interface.members) or
                    desc.interface.getExtendedAttribute("ChromeOnly") is not None or
                    
                    
                    (desc.interface.isJSImplemented() and
                     desc.interface.hasInterfaceObject()))
        bindingHeaders["AccessCheck.h"] = any(
            descriptorHasChromeOnly(d) for d in descriptors)
        
        bindingHeaders['xpcprivate.h'] = webIDLFile.endswith("EventTarget.webidl")
        hasWorkerStuff = len(config.getDescriptors(webIDLFile=webIDLFile,
                                                   workers=True)) != 0
        bindingHeaders["WorkerPrivate.h"] = hasWorkerStuff
        bindingHeaders["nsThreadUtils.h"] = hasWorkerStuff

        dictionaries = config.getDictionaries(webIDLFile=webIDLFile)
        bindingHeaders["nsCxPusher.h"] = dictionaries
        bindingHeaders["AtomList.h"] = any(
            len(dict.members) > 0 for dict in dictionaries)
        mainCallbacks = config.getCallbacks(webIDLFile=webIDLFile,
                                            workers=False)
        workerCallbacks = config.getCallbacks(webIDLFile=webIDLFile,
                                              workers=True)
        callbackDescriptors = config.getDescriptors(webIDLFile=webIDLFile,
                                                    isCallback=True)
        jsImplemented = config.getDescriptors(webIDLFile=webIDLFile,
                                              isJSImplemented=True)
        bindingHeaders["nsPIDOMWindow.h"] = jsImplemented

        def addHeaderBasedOnTypes(header, typeChecker):
            bindingHeaders[header] = (
                bindingHeaders.get(header, False) or
                any(map(typeChecker,
                        getAllTypes(descriptors + callbackDescriptors,
                                    dictionaries,
                                    mainCallbacks + workerCallbacks))))

        bindingHeaders["nsDOMQS.h"] = any(d.hasXPConnectImpls for d in descriptors)
        
        provider = config.getDescriptorProvider(False)
        def checkForXPConnectImpls(typeInfo):
            (type, _, _) = typeInfo
            type = type.unroll()
            if not type.isInterface() or not type.isGeckoInterface():
                return False
            try:
                typeDesc = provider.getDescriptor(type.inner.identifier.name)
            except NoSuchDescriptorError:
                return False
            return typeDesc.hasXPConnectImpls
        addHeaderBasedOnTypes("nsDOMQS.h", checkForXPConnectImpls)

        
        enums = config.getEnums(webIDLFile)
        cgthings = [ CGEnum(e) for e in enums ]

        bindingHeaders["mozilla/dom/BindingUtils.h"] = (
            descriptors or callbackDescriptors or dictionaries or
            mainCallbacks or workerCallbacks)
        bindingHeaders["mozilla/dom/BindingDeclarations.h"] = (
            not bindingHeaders["mozilla/dom/BindingUtils.h"] and enums)

        bindingHeaders["WrapperFactory.h"] = descriptors
        bindingHeaders["mozilla/dom/DOMJSClass.h"] = descriptors

        
        
        
        
        cgthings.extend([CGDictionary(d, config.getDescriptorProvider(False))
                         for d in
                         dependencySortObjects(dictionaries,
                                               CGDictionary.getDictionaryDependencies,
                                               lambda d: d.identifier.name)])

        
        
        
        cgthings.extend(CGCallbackFunction(c, config.getDescriptorProvider(False))
                        for c in mainCallbacks)

        
        cgthings.extend([CGDescriptor(x) for x in descriptors])

        
        
        cgthings.extend([CGCallbackInterface(x) for x in callbackDescriptors if
                         not x.workers])

        
        def getParentDescriptor(desc):
            if not desc.interface.parent:
                return set()
            return { desc.getDescriptor(desc.interface.parent.identifier.name) }
        for x in dependencySortObjects(jsImplemented, getParentDescriptor,
                                       lambda d: d.interface.identifier.name):
            cgthings.append(CGCallbackInterface(x))
            cgthings.append(CGJSImplClass(x))

        
        curr = CGWrapper(CGList(cgthings, "\n\n"), post="\n\n")

        
        curr = CGNamespace.build(['mozilla', 'dom'],
                                 CGWrapper(curr, pre="\n"))

        curr = CGList([CGForwardDeclarations(config, descriptors,
                                             mainCallbacks, workerCallbacks,
                                             dictionaries,
                                             callbackDescriptors + jsImplemented),
                       curr],
                      "\n")

        
        bindingHeaders = [header for (header, include) in
                          bindingHeaders.iteritems() if include]
        curr = CGHeaders(descriptors,
                         dictionaries,
                         mainCallbacks + workerCallbacks,
                         callbackDescriptors,
                         ['mozilla/dom/BindingDeclarations.h',
                          'mozilla/ErrorResult.h',
                          'jspubtd.h',
                          'js/RootingAPI.h',
                          ],
                         bindingHeaders,
                         prefix,
                         curr,
                         config,
                         jsImplemented)

        
        curr = CGIncludeGuard(prefix, curr)

        
        curr = CGWrapper(curr, pre=AUTOGENERATED_WARNING_COMMENT)

        
        self.root = curr

    def declare(self):
        return stripTrailingWhitespace(self.root.declare())
    def define(self):
        return stripTrailingWhitespace(self.root.define())

    def deps(self):
        return self.root.deps()

class CGNativeMember(ClassMethod):
    def __init__(self, descriptorProvider, member, name, signature, extendedAttrs,
                 breakAfter=True, passJSBitsAsNeeded=True, visibility="public",
                 jsObjectsArePtr=False, variadicIsSequence=False):
        """
        If jsObjectsArePtr is true, typed arrays and "object" will be
        passed as JSObject*.

        If passJSBitsAsNeeded is false, we don't automatically pass in a
        JSContext* or a JSObject* based on the return and argument types.  We
        can still pass it based on 'implicitJSContext' annotations.
        """
        self.descriptorProvider = descriptorProvider
        self.member = member
        self.extendedAttrs = extendedAttrs
        self.resultAlreadyAddRefed = isResultAlreadyAddRefed(self.descriptorProvider,
                                                             self.extendedAttrs)
        self.passJSBitsAsNeeded = passJSBitsAsNeeded
        self.jsObjectsArePtr = jsObjectsArePtr
        self.variadicIsSequence = variadicIsSequence
        breakAfterSelf = "\n" if breakAfter else ""
        ClassMethod.__init__(self, name,
                             self.getReturnType(signature[0], False),
                             self.getArgs(signature[0], signature[1]),
                             static=member.isStatic(),
                             
                             
                             const=(not member.isStatic() and member.isAttr() and
                                    not signature[0].isVoid()),
                             breakAfterReturnDecl=" ",
                             breakAfterSelf=breakAfterSelf,
                             visibility=visibility)

    def getReturnType(self, type, isMember):
        return self.getRetvalInfo(type, isMember)[0]

    def getRetvalInfo(self, type, isMember):
        """
        Returns a tuple:

        The first element is the type declaration for the retval

        The second element is a default value that can be used on error returns.
        For cases whose behavior depends on isMember, the second element will be
        None if isMember is true.

        The third element is a template for actually returning a value stored in
        "${declName}" and "${holderName}".  This means actually returning it if
        we're not outparam, else assigning to the "retval" outparam.  If
        isMember is true, this can be None, since in that case the caller will
        never examine this value.
        """
        if type.isVoid():
            return "void", "", ""
        if type.isPrimitive() and type.tag() in builtinNames:
            result = CGGeneric(builtinNames[type.tag()])
            defaultReturnArg = "0"
            if type.nullable():
                result = CGTemplatedType("Nullable", result)
                defaultReturnArg = ""
            return (result.define(),
                    "%s(%s)" % (result.define(), defaultReturnArg),
                    "return ${declName};")
        if type.isDOMString():
            if isMember:
                
                return "nsString", None, None
            
            return "void", "", "retval = ${declName};"
        if type.isByteString():
            if isMember:
                
                return "nsCString", None, None
            
            return "void", "", "retval = ${declName};"
        if type.isEnum():
            enumName = type.unroll().inner.identifier.name
            if type.nullable():
                enumName = CGTemplatedType("Nullable",
                                           CGGeneric(enumName)).define()
                defaultValue = "%s()" % enumName
            else:
                defaultValue = "%s(0)" % enumName
            return enumName, defaultValue, "return ${declName};"
        if type.isGeckoInterface():
            iface = type.unroll().inner;
            nativeType = self.descriptorProvider.getDescriptor(
                iface.identifier.name).nativeType
            
            nativeType = nativeType.split("::")
            if nativeType[0] == "mozilla":
                nativeType.pop(0)
                if nativeType[0] == "dom":
                    nativeType.pop(0)
            result = CGGeneric("::".join(nativeType))
            if self.resultAlreadyAddRefed:
                if isMember:
                    holder = "nsRefPtr"
                else:
                    holder = "already_AddRefed"
                if memberIsCreator(self.member):
                    warning = ""
                else:
                    warning = "// Mark this as resultNotAddRefed to return raw pointers\n"
                result = CGWrapper(result,
                                   pre=("%s%s<" % (warning, holder)),
                                   post=">")
            else:
                result = CGWrapper(result, post="*")
            
            
            
            return result.define(), "nullptr", "return ${declName}.forget();"
        if type.isCallback():
            return ("already_AddRefed<%s>" % type.unroll().identifier.name,
                    "nullptr", "return ${declName}.forget();")
        if type.isAny():
            return "JS::Value", "JS::UndefinedValue()", "return ${declName};"
        if type.isObject():
            return "JSObject*", "nullptr", "return ${declName};"
        if type.isSpiderMonkeyInterface():
            if type.nullable():
                returnCode = "return ${declName}.IsNull() ? nullptr : ${declName}.Value().Obj();"
            else:
                returnCode = "return ${declName}.Obj();"
            return "JSObject*", "nullptr", returnCode
        if type.isSequence():
            
            
            
            assert not isMember
            
            if type.nullable():
                returnCode = ("if (${declName}.IsNull()) {\n"
                              "  retval.SetNull();\n"
                              "} else {\n"
                              "  retval.SetValue().SwapElements(${declName}.Value());\n"
                              "}")
            else:
                returnCode = "retval.SwapElements(${declName});"
            return "void", "", returnCode
        if type.isDate():
            result = CGGeneric("Date")
            if type.nullable():
                result = CGTemplatedType("Nullable", result)
            return (result.define(), "%s()" % result.define(),
                    "return ${declName};")
        raise TypeError("Don't know how to declare return value for %s" %
                        type)

    def getArgs(self, returnType, argList):
        args = [self.getArg(arg) for arg in argList]
        
        if returnType.isDOMString():
            args.append(Argument("nsString&", "retval"))
        if returnType.isByteString():
            args.append(Argument("nsCString&", "retval"))
        elif returnType.isSequence():
            nullable = returnType.nullable()
            if nullable:
                returnType = returnType.inner
            
            elementDecl = self.getReturnType(returnType.inner, True)
            type = CGTemplatedType("nsTArray", CGGeneric(elementDecl))
            if nullable:
                type = CGTemplatedType("Nullable", type)
            args.append(Argument("%s&" % type.define(), "retval"))
        
        if not 'infallible' in self.extendedAttrs:
            
            args.append(Argument("ErrorResult&", "aRv"))
        
        if self.member.isMethod() and self.member.isLegacycaller():
            
            assert self.member.isIdentifierLess()
            args.insert(0, Argument("JS::Value", "aThisVal"))
        
        if needCx(returnType, argList, self.extendedAttrs,
                  self.descriptorProvider, self.passJSBitsAsNeeded):
            args.insert(0, Argument("JSContext*", "cx"))
            if needScopeObject(returnType, argList, self.extendedAttrs,
                               self.descriptorProvider, self.descriptorProvider,
                               self.passJSBitsAsNeeded):
                args.insert(1, Argument("JS::Handle<JSObject*>", "obj"))
        
        if self.member.isStatic():
            args.insert(0, Argument("const GlobalObject&", "global"))
        return args

    def doGetArgType(self, type, optional, isMember):
        """
        The main work of getArgType.  Returns a string type decl, whether this
        is a const ref, as well as whether the type should be wrapped in
        Nullable as needed.

        isMember can be false or one of the strings "Sequence" or "Variadic"
        """
        if type.isArray():
            raise TypeError("Can't handle array arguments yet")

        if type.isSequence():
            nullable = type.nullable()
            if nullable:
                type = type.inner
            elementType = type.inner
            argType = self.getArgType(elementType, False, "Sequence")[0]
            decl = CGTemplatedType("Sequence", argType)
            return decl.define(), True, True

        if type.isUnion():
            if type.nullable():
                type = type.inner
            return str(type), True, True

        if (type.isGeckoInterface() and
            (not type.isCallbackInterface() or
             type.unroll().inner.identifier.name == "EventListener")):
            iface = type.unroll().inner
            argIsPointer = type.nullable() or iface.isExternal()
            forceOwningType = iface.isCallback() or isMember
            if argIsPointer:
                if (optional or isMember) and forceOwningType:
                    typeDecl = "nsRefPtr<%s>"
                else:
                    typeDecl = "%s*"
            else:
                if optional or isMember:
                    if forceOwningType:
                        typeDecl = "OwningNonNull<%s>"
                    else:
                        typeDecl = "NonNull<%s>"
                else:
                    typeDecl = "%s&"
            return ((typeDecl %
                     self.descriptorProvider.getDescriptor(iface.identifier.name).nativeType),
                    False, False)

        if type.isSpiderMonkeyInterface():
            if self.jsObjectsArePtr:
                return "JSObject*", False, False

            return type.name, True, True

        if type.isDOMString():
            if isMember:
                declType = "nsString"
            else:
                declType = "nsAString"
            return declType, True, False

        if type.isByteString():
            declType = "nsCString"
            return declType, True, False

        if type.isEnum():
            return type.unroll().inner.identifier.name, False, True

        if type.isCallback() or type.isCallbackInterface():
            forceOwningType = optional or isMember
            if type.nullable():
                if forceOwningType:
                    declType = "nsRefPtr<%s>"
                else:
                    declType = "%s*"
            else:
                if forceOwningType:
                    declType = "OwningNonNull<%s>"
                else:
                    declType = "%s&"
            if type.isCallback():
                name = type.unroll().identifier.name
            else:
                name = type.unroll().inner.identifier.name
            return declType % name, False, False

        if type.isAny():
            
            if isMember:
                declType = "JS::Value"
            else:
                declType = "JS::Handle<JS::Value>"
            return declType, False, False

        if type.isObject():
            if isMember:
                declType = "JSObject*"
            else:
                declType = "JS::Handle<JSObject*>"
            return declType, False, False

        if type.isDictionary():
            typeName = CGDictionary.makeDictionaryName(type.inner)
            return typeName, True, True

        if type.isDate():
            return "Date", False, True

        assert type.isPrimitive()

        return builtinNames[type.tag()], False, True

    def getArgType(self, type, optional, isMember):
        """
        Get the type of an argument declaration.  Returns the type CGThing, and
        whether this should be a const ref.

        isMember can be False, "Sequence", or "Variadic"
        """
        (decl, ref, handleNullable) = self.doGetArgType(type, optional,
                                                        isMember)
        decl = CGGeneric(decl)
        if handleNullable and type.nullable():
            decl = CGTemplatedType("Nullable", decl)
            ref = True
        if isMember == "Variadic":
            arrayType = "Sequence" if self.variadicIsSequence else "nsTArray"
            decl = CGTemplatedType(arrayType, decl)
            ref = True
        elif optional:
            
            
            decl = CGTemplatedType("Optional", decl)
            ref = True
        return (decl, ref)

    def getArg(self, arg):
        """
        Get the full argument declaration for an argument
        """
        (decl, ref) = self.getArgType(arg.type,
                                      arg.optional and not arg.defaultValue,
                                      "Variadic" if arg.variadic else False)
        if ref:
            decl = CGWrapper(decl, pre="const ", post="&")

        return Argument(decl.define(), arg.identifier.name)


class CGExampleMethod(CGNativeMember):
    def __init__(self, descriptor, method, signature, isConstructor, breakAfter=True):
        CGNativeMember.__init__(self, descriptor, method,
                                CGSpecializedMethod.makeNativeName(descriptor,
                                                                   method),
                                signature,
                                descriptor.getExtendedAttributes(method),
                                breakAfter=breakAfter,
                                variadicIsSequence=True)
    def define(self, cgClass):
        return ''

class CGExampleGetter(CGNativeMember):
    def __init__(self, descriptor, attr):
        CGNativeMember.__init__(self, descriptor, attr,
                                CGSpecializedGetter.makeNativeName(descriptor,
                                                                   attr),
                                (attr.type, []),
                                descriptor.getExtendedAttributes(attr,
                                                                 getter=True))
    def define(self, cgClass):
        return ''

class CGExampleSetter(CGNativeMember):
    def __init__(self, descriptor, attr):
        CGNativeMember.__init__(self, descriptor, attr,
                                CGSpecializedSetter.makeNativeName(descriptor,
                                                                   attr),
                                (BuiltinTypes[IDLBuiltinType.Types.void],
                                 [FakeArgument(attr.type, attr)]),
                                descriptor.getExtendedAttributes(attr,
                                                                 setter=True))
    def define(self, cgClass):
        return ''

class CGBindingImplClass(CGClass):
    """
    Common codegen for generating a C++ implementation of a WebIDL interface
    """
    def __init__(self, descriptor, cgMethod, cgGetter, cgSetter):
        """
        cgMethod, cgGetter and cgSetter are classes used to codegen methods,
        getters and setters.
        """
        self.descriptor = descriptor
        self._deps = descriptor.interface.getDeps()

        iface = descriptor.interface

        self.methodDecls = []
        def appendMethod(m, isConstructor=False):
            sigs = m.signatures()
            for s in sigs[:-1]:
                
                
                self.methodDecls.append(cgMethod(descriptor, m, s,
                                                 isConstructor,
                                                 breakAfter=False))
            self.methodDecls.append(cgMethod(descriptor, m, sigs[-1],
                                             isConstructor))

        if iface.ctor():
            appendMethod(iface.ctor(), isConstructor=True)
        for n in iface.namedConstructors:
            appendMethod(n, isConstructor=True)
        for m in iface.members:
            if m.isMethod():
                if m.isIdentifierLess():
                    continue
                appendMethod(m)
            elif m.isAttr():
                self.methodDecls.append(cgGetter(descriptor, m))
                if not m.readonly:
                    self.methodDecls.append(cgSetter(descriptor, m))

        
        def appendSpecialOperation(name, op):
            if op is None:
                return
            if name == "IndexedCreator" or name == "NamedCreator":
                
                return
            assert len(op.signatures()) == 1
            (returnType, args) = op.signatures()[0]
            
            args = list(args)
            if op.isGetter() or op.isDeleter():
                
                
                
                args.append(FakeArgument(BuiltinTypes[IDLBuiltinType.Types.boolean],
                                         op, name="&found"))
            if name == "Stringifier":
                if op.isIdentifierLess():
                    
                    name = "Stringify"
                else:
                    
                    return
            if name == "LegacyCaller":
                if op.isIdentifierLess():
                    
                    name = "LegacyCall"
                else:
                    
                    return
            if name == "Jsonifier":
                
                return
            self.methodDecls.append(
                CGNativeMember(descriptor, op,
                               name,
                               (returnType, args),
                               descriptor.getExtendedAttributes(op)))
        
        ops = descriptor.operations.items()
        ops.sort(key=lambda x: x[0])
        for (name, op) in ops:
            appendSpecialOperation(name, op)
        
        
        if descriptor.supportsIndexedProperties():
            
            
            haveLengthAttr = any(
                m for m in iface.members if m.isAttr() and
                CGSpecializedGetter.makeNativeName(descriptor, m) == "Length")
            if not haveLengthAttr:
                self.methodDecls.append(
                    CGNativeMember(descriptor, FakeMember(),
                                   "Length",
                                   (BuiltinTypes[IDLBuiltinType.Types.unsigned_long],
                                    []),
                                   { "infallible": True }))
        
        
        if descriptor.supportsNamedProperties():
            self.methodDecls.append(
                CGNativeMember(
                    descriptor, FakeMember(),
                    "GetSupportedNames",
                    (IDLSequenceType(None,
                                     BuiltinTypes[IDLBuiltinType.Types.domstring]),
                     []),
                    { "infallible": True }))

        wrapArgs = [Argument('JSContext*', 'aCx'),
                    Argument('JS::Handle<JSObject*>', 'aScope')]
        self.methodDecls.insert(0,
                                ClassMethod("WrapObject", "JSObject*",
                                            wrapArgs, virtual=descriptor.wrapperCache,
                                            breakAfterReturnDecl=" ",
                                            override=descriptor.wrapperCache,
                                            body=self.getWrapObjectBody()))
        self.methodDecls.insert(0,
                                ClassMethod("GetParentObject",
                                            self.getGetParentObjectReturnType(),
                                            [], const=True,
                                            breakAfterReturnDecl=" ",
                                            body=self.getGetParentObjectBody()))

        

    def getWrapObjectBody(self):
        return None

    def getGetParentObjectReturnType(self):
        return ("// TODO: return something sensible here, and change the return type\n"
                "%s*" % self.descriptor.nativeType.split('::')[-1])

    def getGetParentObjectBody(self):
        return None

    def deps(self):
        return self._deps


class CGExampleClass(CGBindingImplClass):
    """
    Codegen for the actual example class implementation for this descriptor
    """
    def __init__(self, descriptor):
        CGBindingImplClass.__init__(self, descriptor, CGExampleMethod, CGExampleGetter, CGExampleSetter)

        extradeclarations=(
            "public:\n"
            "  NS_DECL_CYCLE_COLLECTING_ISUPPORTS\n"
            "  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(%s)\n"
            "\n" % descriptor.nativeType.split('::')[-1])

        CGClass.__init__(self, descriptor.nativeType.split('::')[-1],
                         bases=[ClassBase("nsISupports /* Change nativeOwnership in the binding configuration if you don't want this */"),
                                ClassBase("nsWrapperCache /* Change wrapperCache in the binding configuration if you don't want this */")],
                         constructors=[ClassConstructor([],
                                                        visibility="public")],
                         destructor=ClassDestructor(visibility="public"),
                         methods=self.methodDecls,
                         decorators="MOZ_FINAL",
                         extradeclarations=extradeclarations)

    def define(self):
        
        classImpl = """
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_0(${nativeType})
NS_IMPL_CYCLE_COLLECTING_ADDREF(${nativeType})
NS_IMPL_CYCLE_COLLECTING_RELEASE(${nativeType})
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(${nativeType})
  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
  NS_INTERFACE_MAP_ENTRY(nsISupports)
NS_INTERFACE_MAP_END

${nativeType}::${nativeType}()
{
  SetIsDOMBinding();
}

${nativeType}::~${nativeType}()
{
}

JSObject*
${nativeType}::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aScope)
{
  return ${ifaceName}Binding::Wrap(aCx, aScope, this);
}

"""
        return string.Template(classImpl).substitute(
            { "ifaceName": self.descriptor.name,
              "nativeType": self.descriptor.nativeType.split('::')[-1] }
            )


class CGExampleRoot(CGThing):
    """
    Root codegen class for example implementation generation.  Instantiate the
    class and call declare or define to generate header or cpp code,
    respectively.
    """
    def __init__(self, config, interfaceName):
        
        descriptor = config.getDescriptor(interfaceName, False)

        self.root = CGWrapper(CGExampleClass(descriptor),
                              pre="\n", post="\n")

        self.root = CGNamespace.build(["mozilla", "dom"], self.root);

        self.root = CGList([CGClassForwardDeclare("JSContext", isStruct=True),
                            self.root], "\n")

        
        self.root = CGHeaders([], [], [], [],
                              [ "nsWrapperCache.h",
                                "nsCycleCollectionParticipant.h",
                                "mozilla/Attributes.h",
                                "mozilla/ErrorResult.h" ],
                              [ "%s.h" % interfaceName,
                                "mozilla/dom/%sBinding.h" % interfaceName,
                                "nsContentUtils.h" ], "", self.root);

        
        self.root = CGIncludeGuard(interfaceName, self.root)

        
        self.root = CGWrapper(self.root, pre="""/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim:set ts=2 sw=2 sts=2 et cindent: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

""")

    def declare(self):
        return self.root.declare()

    def define(self):
        return self.root.define()


def jsImplName(name):
    return name + "JSImpl"

class CGJSImplMethod(CGNativeMember):
    def __init__(self, descriptor, method, signature, isConstructor, breakAfter=True):
        CGNativeMember.__init__(self, descriptor, method,
                                CGSpecializedMethod.makeNativeName(descriptor,
                                                                   method),
                                signature,
                                descriptor.getExtendedAttributes(method),
                                breakAfter=breakAfter,
                                variadicIsSequence=True,
                                passJSBitsAsNeeded=False)
        self.signature = signature
        self.descriptor = descriptor
        if isConstructor:
            self.body = self.getConstructorImpl()
        else:
            self.body = self.getImpl()

    def getImpl(self):
        callbackArgs = [arg.name for arg in self.getArgs(self.signature[0], self.signature[1])]
        return 'return mImpl->%s(%s);' % (self.name, ", ".join(callbackArgs))

    def getConstructorImpl(self):
        assert self.descriptor.interface.isJSImplemented()
        if self.name != 'Constructor':
            raise TypeError("Named constructors are not supported for JS implemented WebIDL. See bug 851287.")
        if len(self.signature[1]) != 0:
            args = self.getArgs(self.signature[0], self.signature[1])
            
            
            assert args[0].argType == 'const GlobalObject&'
            assert args[1].argType == 'JSContext*'
            args = args[2:]
            constructorArgs = [arg.name for arg in args]
            initCall = """
// Wrap the object before calling __Init so that __DOM_IMPL__ is available.
nsCOMPtr<nsIGlobalObject> globalHolder = do_QueryInterface(window);
JS::Rooted<JSObject*> scopeObj(cx, globalHolder->GetGlobalJSObject());
JS::Rooted<JS::Value> wrappedVal(cx);
if (!WrapNewBindingObject(cx, scopeObj, impl, &wrappedVal)) {
  MOZ_ASSERT(JS_IsExceptionPending(cx));
  aRv.Throw(NS_ERROR_UNEXPECTED);
  return nullptr;
}
// Initialize the object with the constructor arguments.
impl->mImpl->__Init(%s);
if (aRv.Failed()) {
  return nullptr;
}""" % (", ".join(constructorArgs))
        else:
            initCall = ""
        return genConstructorBody(self.descriptor, initCall)

def genConstructorBody(descriptor, initCall=""):
    template = (
        "JS::Rooted<JSObject*> jsImplObj(cx);\n"
        "nsCOMPtr<nsPIDOMWindow> window =\n"
        '  ConstructJSImplementation(cx, "${contractId}", global, &jsImplObj, aRv);\n'
        "if (aRv.Failed()) {\n"
        "  return nullptr;\n"
        "}\n"
        "// Build the C++ implementation.\n"
        
        "nsRefPtr<${implClass}> impl = new ${implClass}(jsImplObj, window);"
        "${initCall}\n"
        "return impl.forget();")

    return string.Template(template).substitute({
        "implClass" : descriptor.name,
        "contractId" : descriptor.interface.getJSImplementation(),
        "initCall" : initCall
    })


def callbackGetterName(attr):
    return "Get" + MakeNativeName(attr.identifier.name)

def callbackSetterName(attr):
    return "Set" + MakeNativeName(attr.identifier.name)

class CGJSImplGetter(CGNativeMember):
    def __init__(self, descriptor, attr):
        CGNativeMember.__init__(self, descriptor, attr,
                                CGSpecializedGetter.makeNativeName(descriptor,
                                                                   attr),
                                (attr.type, []),
                                descriptor.getExtendedAttributes(attr,
                                                                 getter=True),
                                passJSBitsAsNeeded=False)
        self.body = self.getImpl()

    def getImpl(self):
        callbackArgs = [arg.name for arg in self.getArgs(self.member.type, [])]
        return 'return mImpl->%s(%s);' % (callbackGetterName(self.member), ", ".join(callbackArgs))

class CGJSImplSetter(CGNativeMember):
    def __init__(self, descriptor, attr):
        CGNativeMember.__init__(self, descriptor, attr,
                                CGSpecializedSetter.makeNativeName(descriptor,
                                                                   attr),
                                (BuiltinTypes[IDLBuiltinType.Types.void],
                                 [FakeArgument(attr.type, attr)]),
                                descriptor.getExtendedAttributes(attr,
                                                                 setter=True),
                                passJSBitsAsNeeded=False)
        self.body = self.getImpl()

    def getImpl(self):
        callbackArgs = [arg.name for arg in self.getArgs(BuiltinTypes[IDLBuiltinType.Types.void],
                                                         [FakeArgument(self.member.type, self.member)])]
        return 'mImpl->%s(%s);' % (callbackSetterName(self.member), ", ".join(callbackArgs))

class CGJSImplClass(CGBindingImplClass):
    def __init__(self, descriptor):
        CGBindingImplClass.__init__(self, descriptor, CGJSImplMethod, CGJSImplGetter, CGJSImplSetter)

        if descriptor.interface.parent:
            parentClass = descriptor.getDescriptor(
                descriptor.interface.parent.identifier.name).jsImplParent
            baseClasses = [ClassBase(parentClass)]
            isupportsDecl = "NS_DECL_ISUPPORTS_INHERITED"
            ccDecl = ("NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(%s, %s)" %
                      (descriptor.name, parentClass))
            constructorBody = (
                "// Make sure we're an nsWrapperCache already\n"
                "MOZ_ASSERT(static_cast<nsWrapperCache*>(this));\n"
                "// And that our ancestor has called SetIsDOMBinding()\n"
                "MOZ_ASSERT(IsDOMBinding());")
            extradefinitions= string.Template(
                "NS_IMPL_CYCLE_COLLECTION_INHERITED_2(${ifaceName}, ${parentClass}, mImpl, mParent)\n"
                "NS_IMPL_ADDREF_INHERITED(${ifaceName}, ${parentClass})\n"
                "NS_IMPL_RELEASE_INHERITED(${ifaceName}, ${parentClass})\n"
                "NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(${ifaceName})\n"
                "NS_INTERFACE_MAP_END_INHERITING(${parentClass})\n").substitute(
                { "ifaceName": self.descriptor.name,
                  "parentClass": parentClass })
        else:
            baseClasses = [ClassBase("nsISupports"),
                           ClassBase("nsWrapperCache")]
            isupportsDecl = "NS_DECL_CYCLE_COLLECTING_ISUPPORTS"
            ccDecl = ("NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(%s)" %
                      descriptor.name)
            constructorBody = "SetIsDOMBinding();"
            extradefinitions= string.Template(
                "NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_2(${ifaceName}, mImpl, mParent)\n"
                "NS_IMPL_CYCLE_COLLECTING_ADDREF(${ifaceName})\n"
                "NS_IMPL_CYCLE_COLLECTING_RELEASE(${ifaceName})\n"
                "NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(${ifaceName})\n"
                "  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY\n"
                "  NS_INTERFACE_MAP_ENTRY(nsISupports)\n"
                "NS_INTERFACE_MAP_END\n").substitute({ "ifaceName": self.descriptor.name })

        extradeclarations=(
            "public:\n"
            "  %s\n"
            "  %s\n"
            "\n"
            "private:\n"
            "  nsRefPtr<%s> mImpl;\n"
            "  nsCOMPtr<nsISupports> mParent;\n"
            "\n" % (isupportsDecl, ccDecl, jsImplName(descriptor.name)))

        if descriptor.interface.hasChildInterfaces():
            decorators = ""
            
            destructor = ClassDestructor(virtual=True, visibility="public")
        else:
            decorators = "MOZ_FINAL"
            destructor = None

        baseConstructors=["mImpl(new %s(aJSImplObject))" % jsImplName(descriptor.name),
                          "mParent(aParent)"]
        parentInterface = descriptor.interface.parent
        while parentInterface:
            if parentInterface.isJSImplemented():
                baseConstructors.insert(
                    0, "%s(aJSImplObject, aParent)" % parentClass )
                break
            parentInterface = parentInterface.parent
        if not parentInterface and descriptor.interface.parent:
            
            baseConstructors.insert(0,
                                    "%s(aParent)" % parentClass)

        constructor = ClassConstructor(
            [Argument("JS::Handle<JSObject*>", "aJSImplObject"),
             Argument("nsPIDOMWindow*", "aParent")],
            visibility="public",
            baseConstructors=baseConstructors,
            body=constructorBody)

        self.methodDecls.append(
            ClassMethod("_Create",
                        "bool",
                        [Argument("JSContext*", "cx"),
                         Argument("unsigned", "argc"),
                         Argument("JS::Value*", "vp")],
                        static=True,
                        body=self.getCreateFromExistingBody()))

        CGClass.__init__(self, descriptor.name,
                         bases=baseClasses,
                         constructors=[constructor],
                         destructor=destructor,
                         methods=self.methodDecls,
                         decorators=decorators,
                         extradeclarations=extradeclarations,
                         extradefinitions=extradefinitions)

    def getWrapObjectBody(self):
        return ("JS::Rooted<JSObject*> obj(aCx, %sBinding::Wrap(aCx, aScope, this));\n"
                "if (!obj) {\n"
                "  return nullptr;\n"
                "}\n"
                "\n"
                "// Now define it on our chrome object\n"
                "JSAutoCompartment ac(aCx, mImpl->Callback());\n"
                "if (!JS_WrapObject(aCx, obj.address())) {\n"
                "  return nullptr;\n"
                "}\n"
                'if (!JS_DefineProperty(aCx, mImpl->Callback(), "__DOM_IMPL__", JS::ObjectValue(*obj), nullptr, nullptr, 0)) {\n'
                "  return nullptr;\n"
                "}\n"
                "return obj;" % self.descriptor.name)

    def getGetParentObjectReturnType(self):
        return "nsISupports*"

    def getGetParentObjectBody(self):
        return "return mParent;"

    def getCreateFromExistingBody(self):
        
        
        
        
        
        return string.Template(
            "JS::CallArgs args = JS::CallArgsFromVp(argc, vp);\n"
            "if (args.length() < 2) {\n"
            '  return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "${ifaceName}._create");\n'
            "}\n"
            "if (!args[0].isObject()) {\n"
            '  return ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of ${ifaceName}._create");\n'
            "}\n"
            "if (!args[1].isObject()) {\n"
            '  return ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of ${ifaceName}._create");\n'
            "}\n"
            "\n"
            "// GlobalObject will go through wrappers as needed for us, and\n"
            "// is simpler than the right UnwrapArg incantation.\n"
            "GlobalObject global(cx, &args[0].toObject());\n"
            "if (global.Failed()) {\n"
            "  return false;\n"
            "}\n"
            "nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(global.GetAsSupports());\n"
            "if (!window) {\n"
            '  return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of ${ifaceName}._create", "Window");\n'
            "}\n"
            "JS::Rooted<JSObject*> arg(cx, &args[1].toObject());\n"
            "nsRefPtr<${implName}> impl = new ${implName}(arg, window);\n"
            "return WrapNewBindingObject(cx, arg, impl, args.rval());").substitute({
                "ifaceName": self.descriptor.interface.identifier.name,
                "implName": self.descriptor.name
                })

def isJSImplementedDescriptor(descriptorProvider):
    return (isinstance(descriptorProvider, Descriptor) and
            descriptorProvider.interface.isJSImplemented())

class CGCallback(CGClass):
    def __init__(self, idlObject, descriptorProvider, baseName, methods,
                 getters=[], setters=[]):
        self.baseName = baseName
        self._deps = idlObject.getDeps()
        name = idlObject.identifier.name
        if descriptorProvider.workers:
            name += "Workers"
        if isJSImplementedDescriptor(descriptorProvider):
            name = jsImplName(name)
        
        
        
        
        
        
        realMethods = []
        for method in methods:
            if not method.needThisHandling:
                realMethods.append(method)
            else:
                realMethods.extend(self.getMethodImpls(method))
        CGClass.__init__(self, name,
                         bases=[ClassBase(baseName)],
                         constructors=self.getConstructors(),
                         methods=realMethods+getters+setters)

    def getConstructors(self):
        return [ClassConstructor(
            [Argument("JSObject*", "aCallback")],
            bodyInHeader=True,
            visibility="public",
            explicit=True,
            baseConstructors=[
                "%s(aCallback)" % self.baseName
                ])]

    def getMethodImpls(self, method):
        assert method.needThisHandling
        args = list(method.args)
        
        
        assert args[0].name == "cx" and args[0].argType == "JSContext*"
        assert args[1].name == "aThisObj" and args[1].argType == "JS::Handle<JSObject*>"
        args = args[2:]
        
        
        argnames = [arg.name for arg in args]
        argnamesWithThis = ["s.GetContext()", "thisObjJS"] + argnames
        argnamesWithoutThis = ["s.GetContext()", "JS::NullPtr()"] + argnames
        
        
        
        args.append(Argument("ExceptionHandling", "aExceptionHandling",
                             "eReportExceptions"))
        
        argsWithoutThis = list(args)
        args.insert(0, Argument("const T&",  "thisObj"))

        setupCall = ("CallSetup s(CallbackPreserveColor(), aRv, aExceptionHandling);\n"
                     "if (!s.GetContext()) {\n"
                     "  aRv.Throw(NS_ERROR_UNEXPECTED);\n"
                     "  return${errorReturn};\n"
                     "}\n")

        bodyWithThis = string.Template(
            setupCall+
            "JS::Rooted<JSObject*> thisObjJS(s.GetContext(),\n"
            "  WrapCallThisObject(s.GetContext(), CallbackPreserveColor(), thisObj));\n"
            "if (!thisObjJS) {\n"
            "  aRv.Throw(NS_ERROR_FAILURE);\n"
            "  return${errorReturn};\n"
            "}\n"
            "return ${methodName}(${callArgs});").substitute({
                "errorReturn" : method.getDefaultRetval(),
                "callArgs" : ", ".join(argnamesWithThis),
                "methodName": method.name,
                })
        bodyWithoutThis = string.Template(
            setupCall +
            "return ${methodName}(${callArgs});").substitute({
                "errorReturn" : method.getDefaultRetval(),
                "callArgs" : ", ".join(argnamesWithoutThis),
                "methodName": method.name,
                })
        return [ClassMethod(method.name, method.returnType, args,
                            bodyInHeader=True,
                            templateArgs=["typename T"],
                            body=bodyWithThis),
                ClassMethod(method.name, method.returnType, argsWithoutThis,
                            bodyInHeader=True,
                            body=bodyWithoutThis),
                method]

    def deps(self):
        return self._deps

class CGCallbackFunction(CGCallback):
    def __init__(self, callback, descriptorProvider):
        CGCallback.__init__(self, callback, descriptorProvider,
                            "CallbackFunction",
                            methods=[CallCallback(callback, descriptorProvider)])

    def getConstructors(self):
        return CGCallback.getConstructors(self) + [
            ClassConstructor(
            [Argument("CallbackFunction*", "aOther")],
            bodyInHeader=True,
            visibility="public",
            explicit=True,
            baseConstructors=[
                "CallbackFunction(aOther)"
                ])]

class CGCallbackInterface(CGCallback):
    def __init__(self, descriptor):
        iface = descriptor.interface
        attrs = [m for m in iface.members if m.isAttr() and not m.isStatic()]
        getters = [CallbackGetter(a, descriptor) for a in attrs]
        setters = [CallbackSetter(a, descriptor) for a in attrs
                   if not a.readonly]
        methods = [m for m in iface.members
                   if m.isMethod() and not m.isStatic() and not m.isIdentifierLess()]
        methods = [CallbackOperation(m, sig, descriptor) for m in methods
                   for sig in m.signatures()]
        if iface.isJSImplemented() and iface.ctor():
            sigs = descriptor.interface.ctor().signatures()
            if len(sigs) != 1:
                raise TypeError("We only handle one constructor.  See bug 869268.")
            methods.append(CGJSImplInitOperation(sigs[0], descriptor))
        CGCallback.__init__(self, iface, descriptor, "CallbackInterface",
                            methods, getters=getters, setters=setters)

class FakeMember():
    def __init__(self):
        self.treatUndefinedAs = self.treatNullAs = "Default"
    def isStatic(self):
        return False
    def isAttr(self):
        return False
    def isMethod(self):
        return False
    def getExtendedAttribute(self, name):
        
        
        
        if name == "Creator":
            return True
        return None

class CallbackMember(CGNativeMember):
    def __init__(self, sig, name, descriptorProvider, needThisHandling):
        """
        needThisHandling is True if we need to be able to accept a specified
        thisObj, False otherwise.
        """
        self.retvalType = sig[0]
        self.originalSig = sig
        args = sig[1]
        self.argCount = len(args)
        if self.argCount > 0:
            
            lastArg = args[self.argCount-1]
            if lastArg.variadic:
                self.argCountStr = (
                    "(%d - 1) + %s.Length()" % (self.argCount,
                                                lastArg.identifier.name))
            else:
                self.argCountStr = "%d" % self.argCount
        self.needThisHandling = needThisHandling
        
        
        visibility = "private" if needThisHandling else "public"
        
        
        
        CGNativeMember.__init__(self, descriptorProvider, FakeMember(),
                                name, (self.retvalType, args),
                                extendedAttrs={},
                                passJSBitsAsNeeded=False,
                                visibility=visibility,
                                jsObjectsArePtr=True)
        
        
        self.exceptionCode=("aRv.Throw(NS_ERROR_UNEXPECTED);\n"
                            "return%s;" % self.getDefaultRetval())
        self.body = self.getImpl()

    def getImpl(self):
        replacements = {
            "declRval": self.getRvalDecl(),
            "errorReturn" : self.getDefaultRetval(),
            "returnResult": self.getResultConversion(),
            "convertArgs": self.getArgConversions(),
            "doCall": self.getCall(),
            "setupCall": self.getCallSetup(),
            }
        if self.argCount > 0:
            replacements["argCount"] = self.argCountStr
            replacements["argvDecl"] = string.Template(
                "JS::AutoValueVector argv(cx);\n"
                "if (!argv.resize(${argCount})) {\n"
                "  aRv.Throw(NS_ERROR_OUT_OF_MEMORY);\n"
                "  return${errorReturn};\n"
                "}\n"
                ).substitute(replacements)
        else:
            
            replacements["argvDecl"] = ""

        return string.Template(
            
            "${setupCall}"
            "${declRval}"
            "${argvDecl}"
            "${convertArgs}"
            "${doCall}"
            "${returnResult}").substitute(replacements)

    def getResultConversion(self):
        replacements = {
            "val": "rval",
            "mutableVal": "&rval",
            "holderName" : "rvalHolder",
            "declName" : "rvalDecl",
            
            
            
            "obj": "nullptr"
            }

        if isJSImplementedDescriptor(self.descriptorProvider):
            isCallbackReturnValue = "JSImpl"
        else:
            isCallbackReturnValue = "Callback"
        convertType = instantiateJSToNativeConversion(
            getJSToNativeConversionInfo(self.retvalType,
                                        self.descriptorProvider,
                                        exceptionCode=self.exceptionCode,
                                        isCallbackReturnValue=isCallbackReturnValue,
                                        
                                        sourceDescription="return value"),
            replacements)
        assignRetval = string.Template(
            self.getRetvalInfo(self.retvalType,
                               False)[2]).substitute(replacements)
        return convertType.define() + "\n" + assignRetval

    def getArgConversions(self):
        
        
        
        argConversions = [self.getArgConversion(i, arg) for (i, arg)
                          in enumerate(self.originalSig[1])]
        
        
        argConversions.reverse();
        
        
        argConversions = [CGWrapper(CGIndenter(CGGeneric(c)),
                                    pre="do {\n",
                                    post="\n} while (0);")
                          for c in argConversions]
        if self.argCount > 0:
            argConversions.insert(0, self.getArgcDecl())
        
        return CGList(argConversions, "\n\n").define() + "\n\n"

    def getArgConversion(self, i, arg):
        argval = arg.identifier.name

        if arg.variadic:
            argval = argval + "[idx]"
            jsvalIndex = "%d + idx" % i
        else:
            jsvalIndex = "%d" % i
            if arg.optional and not arg.defaultValue:
                argval += ".Value()"
        if arg.type.isDOMString():
            
            
            
            result = "mutableStr"
            prepend = "nsString mutableStr(%s);\n" % argval
        else:
            result = argval
            prepend = ""

        conversion = prepend + wrapForType(
            arg.type, self.descriptorProvider,
            {
                'result' : result,
                'successCode' : "continue;" if arg.variadic else "break;",
                'jsvalRef' : "argv.handleAt(%s)" % jsvalIndex,
                'jsvalHandle' : "argv.handleAt(%s)" % jsvalIndex,
                
                
                
                'obj' : 'CallbackPreserveColor()',
                'isCreator': False,
                'exceptionCode' : self.exceptionCode
                })
        if arg.variadic:
            conversion = string.Template(
                "for (uint32_t idx = 0; idx < ${arg}.Length(); ++idx) {\n" +
                CGIndenter(CGGeneric(conversion)).define() + "\n"
                "}\n"
                "break;").substitute({ "arg": arg.identifier.name })
        elif arg.optional and not arg.defaultValue:
            conversion = (
                CGIfWrapper(CGGeneric(conversion),
                            "%s.WasPassed()" % arg.identifier.name).define() +
                " else if (argc == %d) {\n"
                "  // This is our current trailing argument; reduce argc\n"
                "  --argc;\n"
                "} else {\n"
                "  argv[%d] = JS::UndefinedValue();\n"
                "}" % (i+1, i))
        return conversion

    def getDefaultRetval(self):
        default = self.getRetvalInfo(self.retvalType, False)[1]
        if len(default) != 0:
            default = " " + default
        return default

    def getArgs(self, returnType, argList):
        args = CGNativeMember.getArgs(self, returnType, argList)
        if not self.needThisHandling:
            
            
            return args + [Argument("ExceptionHandling", "aExceptionHandling",
                                    "eReportExceptions")]
        
        
        return [Argument("JSContext*", "cx"),
                Argument("JS::Handle<JSObject*>", "aThisObj")] + args

    def getCallSetup(self):
        if self.needThisHandling:
            
            return ""
        return string.Template(
            "CallSetup s(CallbackPreserveColor(), aRv, aExceptionHandling);\n"
            "JSContext* cx = s.GetContext();\n"
            "if (!cx) {\n"
            "  aRv.Throw(NS_ERROR_UNEXPECTED);\n"
            "  return${errorReturn};\n"
            "}\n").substitute({
                "errorReturn" : self.getDefaultRetval(),
                })

    def getArgcDecl(self):
        return CGGeneric("unsigned argc = %s;" % self.argCountStr);

    @staticmethod
    def ensureASCIIName(idlObject):
        type = "attribute" if idlObject.isAttr() else "operation"
        if re.match("[^\x20-\x7E]", idlObject.identifier.name):
            raise SyntaxError('Callback %s name "%s" contains non-ASCII '
                              "characters.  We can't handle that.  %s" %
                              (type, idlObject.identifier.name,
                               idlObject.location))
        if re.match('"', idlObject.identifier.name):
            raise SyntaxError("Callback %s name '%s' contains "
                              "double-quote character.  We can't handle "
                              "that.  %s" %
                              (type, idlObject.identifier.name,
                               idlObject.location))

class CallbackMethod(CallbackMember):
    def __init__(self, sig, name, descriptorProvider, needThisHandling):
        CallbackMember.__init__(self, sig, name, descriptorProvider,
                                needThisHandling)
    def getRvalDecl(self):
        return "JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());\n"

    def getCall(self):
        replacements = {
            "errorReturn" : self.getDefaultRetval(),
            "thisObj": self.getThisObj(),
            "getCallable": self.getCallableDecl()
            }
        if self.argCount > 0:
            replacements["argv"] = "argv.begin()"
            replacements["argc"] = "argc"
        else:
            replacements["argv"] = "nullptr"
            replacements["argc"] = "0"
        return string.Template("${getCallable}"
                "if (!JS_CallFunctionValue(cx, ${thisObj}, callable,\n"
                "                          ${argc}, ${argv}, rval.address())) {\n"
                "  aRv.Throw(NS_ERROR_UNEXPECTED);\n"
                "  return${errorReturn};\n"
                "}\n").substitute(replacements)

class CallCallback(CallbackMethod):
    def __init__(self, callback, descriptorProvider):
        CallbackMethod.__init__(self, callback.signatures()[0], "Call",
                                descriptorProvider, needThisHandling=True)

    def getThisObj(self):
        return "aThisObj"

    def getCallableDecl(self):
        return "JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));\n"

class CallbackOperationBase(CallbackMethod):
    """
    Common class for implementing various callback operations.
    """
    def __init__(self, signature, jsName, nativeName, descriptor, singleOperation):
        self.singleOperation = singleOperation
        self.methodName = jsName
        CallbackMethod.__init__(self, signature, nativeName, descriptor, singleOperation)

    def getThisObj(self):
        if not self.singleOperation:
            return "mCallback"
        
        
        
        return "isCallable ? aThisObj.get() : mCallback"

    def getCallableDecl(self):
        replacements = {
            "errorReturn" : self.getDefaultRetval(),
            "methodName": self.methodName
            }
        getCallableFromProp = string.Template(
                'if (!GetCallableProperty(cx, "${methodName}", &callable)) {\n'
                '  aRv.Throw(NS_ERROR_UNEXPECTED);\n'
                '  return${errorReturn};\n'
                '}\n').substitute(replacements)
        if not self.singleOperation:
            return 'JS::Rooted<JS::Value> callable(cx);\n' + getCallableFromProp
        return (
            'bool isCallable = JS_ObjectIsCallable(cx, mCallback);\n'
            'JS::Rooted<JS::Value> callable(cx);\n'
            'if (isCallable) {\n'
            '  callable = JS::ObjectValue(*mCallback);\n'
            '} else {\n'
            '%s'
            '}\n' % CGIndenter(CGGeneric(getCallableFromProp)).define())

class CallbackOperation(CallbackOperationBase):
    """
    Codegen actual WebIDL operations on callback interfaces.
    """
    def __init__(self, method, signature, descriptor):
        self.ensureASCIIName(method)
        jsName = method.identifier.name
        CallbackOperationBase.__init__(self, signature,
                                       jsName, MakeNativeName(jsName),
                                       descriptor, descriptor.interface.isSingleOperationInterface())

class CallbackGetter(CallbackMember):
    def __init__(self, attr, descriptor):
        self.ensureASCIIName(attr)
        self.attrName = attr.identifier.name
        CallbackMember.__init__(self,
                                (attr.type, []),
                                callbackGetterName(attr),
                                descriptor,
                                needThisHandling=False)

    def getRvalDecl(self):
        return "JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());\n"

    def getCall(self):
        replacements = {
            "errorReturn" : self.getDefaultRetval(),
            "attrName": self.attrName
            }
        return string.Template(
            'if (!JS_GetProperty(cx, mCallback, "${attrName}", &rval)) {\n'
            '  aRv.Throw(NS_ERROR_UNEXPECTED);\n'
            '  return${errorReturn};\n'
            '}\n').substitute(replacements);

class CallbackSetter(CallbackMember):
    def __init__(self, attr, descriptor):
        self.ensureASCIIName(attr)
        self.attrName = attr.identifier.name
        CallbackMember.__init__(self,
                                (BuiltinTypes[IDLBuiltinType.Types.void],
                                 [FakeArgument(attr.type, attr)]),
                                callbackSetterName(attr),
                                descriptor,
                                needThisHandling=False)

    def getRvalDecl(self):
        
        return ""

    def getCall(self):
        replacements = {
            "errorReturn" : self.getDefaultRetval(),
            "attrName": self.attrName,
            "argv": "argv.handleAt(0)",
            }
        return string.Template(
            'MOZ_ASSERT(argv.length() == 1);\n'
            'if (!JS_SetProperty(cx, mCallback, "${attrName}", ${argv})) {\n'
            '  aRv.Throw(NS_ERROR_UNEXPECTED);\n'
            '  return${errorReturn};\n'
            '}\n').substitute(replacements)

    def getArgcDecl(self):
        return None

class CGJSImplInitOperation(CallbackOperationBase):
    """
    Codegen the __Init() method used to pass along constructor arguments for JS-implemented WebIDL.
    """
    def __init__(self, sig, descriptor):
        assert sig in descriptor.interface.ctor().signatures()
        CallbackOperationBase.__init__(self, (BuiltinTypes[IDLBuiltinType.Types.void], sig[1]),
                                       "__init", "__Init", descriptor, False)

class GlobalGenRoots():
    """
    Roots for global codegen.

    To generate code, call the method associated with the target, and then
    call the appropriate define/declare method.
    """

    @staticmethod
    def GeneratedAtomList(config):
        
        dictionaries = config.dictionaries

        structs = []

        for dict in dictionaries:
            dictMembers = dict.members
            if len(dictMembers) == 0:
                continue

            classMembers = [ClassMember(m.identifier.name + "_id",
                                        "jsid",
                                        visibility="public",
                                        body="JSID_VOID") for m in dictMembers]

            structName = dict.identifier.name + "Atoms"
            structs.append((structName,
                            CGWrapper(CGClass(structName,
                bases=None,
                isStruct=True,
                members=classMembers), post='\n')))

        structs.sort()
        generatedStructs = [struct for (structName, struct) in structs]
        structNames = [structName for (structName, struct) in structs]

        mainStruct = CGWrapper(CGClass("PerThreadAtomCache",
            bases=[ClassBase(structName) for structName in structNames],
            isStruct=True), post='\n')

        structs = CGList(generatedStructs + [mainStruct])

        
        curr = CGNamespace.build(['mozilla', 'dom'],
                                  CGWrapper(structs, pre='\n'))
        curr = CGWrapper(curr, post='\n')

        
        curr = CGIncludeGuard('GeneratedAtomList', curr)

        
        curr = CGWrapper(curr, pre=AUTOGENERATED_WARNING_COMMENT)

        
        return curr

    @staticmethod
    def PrototypeList(config):

        
        descriptorsWithPrototype = config.getDescriptors(hasInterfacePrototypeObject=True)
        protos = [d.name for d in descriptorsWithPrototype]
        idEnum = CGNamespacedEnum('id', 'ID', ['_ID_Start'] + protos,
                                  [0, '_ID_Start'])
        idEnum = CGList([idEnum])

        
        
        def ifaceChainMacro(ifaceCount):
            supplied = [CGGeneric(declare="_iface_" + str(i + 1)) for i in range(ifaceCount)]
            remaining = [CGGeneric(declare="prototypes::id::_ID_Count")] * (config.maxProtoChainLength - ifaceCount)
            macro = CGWrapper(CGList(supplied, ", "),
                              pre="#define INTERFACE_CHAIN_" + str(ifaceCount) + "(",
                              post=") \\\n")
            macroContent = CGIndenter(CGList(supplied + remaining, ", \\\n"))
            macroContent = CGIndenter(CGWrapper(macroContent, pre="{ \\\n",
                                                post=" \\\n}"))
            return CGWrapper(CGList([macro, macroContent]), post="\n\n")

        idEnum.append(ifaceChainMacro(1))

        
        idEnum = CGNamespace.build(['mozilla', 'dom', 'prototypes'],
                                   CGWrapper(idEnum, pre='\n'))
        idEnum = CGWrapper(idEnum, post='\n')

        curr = CGList([idEnum])

        
        maxMacro = CGGeneric(declare="#define MAX_PROTOTYPE_CHAIN_LENGTH " + str(config.maxProtoChainLength))
        curr.append(CGWrapper(maxMacro, post='\n\n'))

        
        constructors = [d.name for d in config.getDescriptors(hasInterfaceObject=True)]
        idEnum = CGNamespacedEnum('id', 'ID', ['_ID_Start'] + constructors,
                                  ['prototypes::id::_ID_Count', '_ID_Start'])

        
        idEnum = CGNamespace.build(['mozilla', 'dom', 'constructors'],
                                   CGWrapper(idEnum, pre='\n'))
        idEnum = CGWrapper(idEnum, post='\n')

        curr.append(idEnum)

        traitsDecls = [CGGeneric(declare="""
template <prototypes::ID PrototypeID>
struct PrototypeTraits;
""")]
        traitsDecls.extend(CGPrototypeTraitsClass(d) for d in descriptorsWithPrototype)

        traitsDecl = CGNamespace.build(['mozilla', 'dom'],
                                        CGList(traitsDecls, "\n"))

        curr.append(traitsDecl)

        
        curr = CGIncludeGuard('PrototypeList', curr)

        
        curr = CGWrapper(curr, pre=AUTOGENERATED_WARNING_COMMENT)

        
        return curr

    @staticmethod
    def RegisterBindings(config):

        
        curr = CGRegisterProtos(config)

        
        curr = CGNamespace.build(['mozilla', 'dom'],
                                 CGWrapper(curr, post='\n'))
        curr = CGWrapper(curr, post='\n')

        
        defineIncludes = [CGHeaders.getDeclarationFilename(desc.interface)
                          for desc in config.getDescriptors(hasInterfaceObject=True,
                                                            workers=False,
                                                            register=True)]
        defineIncludes.append('nsScriptNameSpaceManager.h')
        defineIncludes.extend([CGHeaders.getDeclarationFilename(desc.interface)
                               for desc in config.getDescriptors(isNavigatorProperty=True,
                                                                 workers=False,
                                                                 register=True)])
        curr = CGHeaders([], [], [], [], [], defineIncludes, 'RegisterBindings',
                         curr)

        
        curr = CGIncludeGuard('RegisterBindings', curr)

        
        return curr

    @staticmethod
    def UnionTypes(config):

        (includes, implincludes,
         declarations, unions) = UnionTypes(config.getDescriptors(),
                                            config.getDictionaries(),
                                            config.getCallbacks(),
                                            config)
        includes.add("mozilla/dom/BindingUtils.h")

        
        curr = CGNamespace.build(['mozilla', 'dom'], unions)

        curr = CGWrapper(curr, post='\n')

        namespaces = []
        stack = [CGList([])]
        for (clazz, isStruct) in SortedTuples(declarations):
            elements = clazz.split("::")
            clazz = CGClassForwardDeclare(elements.pop(), isStruct=isStruct)
            i = 0
            if len(elements) > 0:
                common = min(len(namespaces), len(elements))
                while i < common and namespaces[i] == elements[i]:
                    i += 1

            
            namespaces = namespaces[:i]

            
            for j, namespace in enumerate(elements[i:]):
                namespaces.append(namespace)
                
                list = CGList([])
                
                stack[i + j].append(CGNamespace(namespace, list))
                
                
                stack[i + j + 1:] = [list]

            stack[len(elements)].append(clazz)

        curr = CGList([stack[0], curr], "\n")

        curr = CGHeaders([], [], [], [], includes, implincludes, 'UnionTypes',
                         curr)

        
        curr = CGIncludeGuard('UnionTypes', curr)

        
        return curr

    @staticmethod
    def UnionConversions(config):

        (headers, unions) = UnionConversions(config.getDescriptors(),
                                             config.getDictionaries(),
                                             config.getCallbacks(),
                                             config)

        
        curr = CGNamespace.build(['mozilla', 'dom'], unions)

        curr = CGWrapper(curr, post='\n')

        headers.update(["nsDebug.h", "mozilla/dom/UnionTypes.h", "XPCWrapper.h"])
        curr = CGHeaders([], [], [], [], headers, [], 'UnionConversions', curr)

        
        curr = CGIncludeGuard('UnionConversions', curr)

        
        return curr

