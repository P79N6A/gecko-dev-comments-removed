<?xml version="1.0"?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<bindings id="browserToolbarBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="toolbar">
    <resources>
      <stylesheet src="chrome://global/skin/toolbar.css"/>
    </resources>
    <implementation implements="nsIAccessibleProvider">
      <property name="accessibleType" readonly="true">
        <getter>
          return Components.interfaces.nsIAccessibleProvider.XULToolbar;
        </getter>
      </property>

      <constructor><![CDATA[
          if (document.readyState == "complete") {
            this._init();
          } else {
            // Need to wait until XUL overlays are loaded. See bug 554279.
            let self = this;
            document.addEventListener("readystatechange", function onReadyStateChange() {
              if (document.readyState != "complete")
                return;
              document.removeEventListener("readystatechange", onReadyStateChange, false);
              self._init();
            }, false);
          }
      ]]></constructor>

      <method name="_init">
        <body><![CDATA[
          let scope = {};
          Cu.import("resource:///modules/CustomizableUI.jsm", scope);
          let CustomizableUI = scope.CustomizableUI;

          // Searching for the toolbox palette in the toolbar binding because
          // toolbars are constructed first.
          let toolbox = this.toolbox;
          if (toolbox && !toolbox.palette) {
            for (let node of toolbox.children) {
              if (node.localName == "toolbarpalette") {
                // Hold on to the palette but remove it from the document.
                toolbox.palette = node;
                toolbox.removeChild(node);
              }
            }
          }

          CustomizableUI.registerToolbar(this);
        ]]></body>
      </method>

      <method name="insertItem">
        <parameter name="aId"/>
        <parameter name="aBeforeElt"/>
        <parameter name="aWrapper"/>
        <body><![CDATA[
          if (aWrapper) {
            Cu.reportError("Can't insert " + aId + ": using insertItem " +
                           "no longer supports wrapper elements.");
            return null;
          }

          // Hack, the customizable UI code makes this be the last position
          let pos = null;
          if (aBeforeElt) {
            let beforeInfo = CustomizableUI.getPlacementOfWidget(aBeforeElt.id);
            if (beforeInfo.area != this.id) {
              Cu.reportError("Can't insert " + aId + " before " +
                             aBeforeElt.id + " which isn't in this area (" +
                             this.id + ").");
              return null;
            }
            pos = beforeInfo.position;
          }

          CustomizableUI.addWidgetToArea(aId, this.id, pos);
          return this.ownerDocument.getElementById(aId);
        ]]></body>
      </method>

      <property name="toolbarName"
                onget="return this.getAttribute('toolbarname');"
                onset="this.setAttribute('toolbarname', val); return val;"/>

      <property name="customizationTarget" readonly="true">
        <getter><![CDATA[
          if (this._customizationTarget)
            return this._customizationTarget;

          let id = this.getAttribute("customizationtarget");
          if (id)
            this._customizationTarget = document.getElementById(id);

          if (this._customizationTarget)
            this._customizationTarget.insertItem = this.insertItem.bind(this);
          else
            this._customizationTarget = this;

          return this._customizationTarget;
        ]]></getter>
      </property>

      <property name="toolbox" readonly="true">
        <getter><![CDATA[
          if (this._toolbox)
            return this._toolbox;

          let toolboxId = this.getAttribute("toolboxid");
          if (toolboxId) {
            let toolbox = document.getElementById(toolboxId);
            if (toolbox) {
              if (toolbox.externalToolbars.indexOf(this) == -1)
                toolbox.externalToolbars.push(this);

              this._toolbox = toolbox;
            }
          }

          if (!this._toolbox && this.parentNode &&
              this.parentNode.localName == "toolbox") {
            this._toolbox = this.parentNode;
          }

          return this._toolbox;
        ]]></getter>
      </property>

      <property name="currentSet" readonly="true">
        <getter><![CDATA[
          if (!this._customizationTarget)
            return "";

          return [node.id for (node of this._customizationTarget.children)].join(',');
        ]]></getter>
      </property>


    </implementation>
  </binding>

  <!-- The toolbar-menubar-autohide and toolbar-drag bindings are almost
       verbatim copies of their toolkit counterparts - they just inherit from
       the customizableui's toolbar binding instead of toolkit's. We're currently
       OK with the maintainance burden of having two copies of a binding, since
       the long term goal is to move the customization framework into toolkit. -->

  <binding id="toolbar-menubar-autohide"
           extends="chrome://browser/content/customizableui/toolbar.xml#toolbar">
    <implementation>
      <constructor>
        this._setInactive();
      </constructor>
      <destructor>
        this._setActive();
      </destructor>

      <field name="_inactiveTimeout">null</field>

      <field name="_contextMenuListener"><![CDATA[({
        toolbar: this,
        contextMenu: null,

        get active () !!this.contextMenu,

        init: function (event) {
          let node = event.target;
          while (node != this.toolbar) {
            if (node.localName == "menupopup")
              return;
            node = node.parentNode;
          }

          let contextMenuId = this.toolbar.getAttribute("context");
          if (!contextMenuId)
            return;

          this.contextMenu = document.getElementById(contextMenuId);
          if (!this.contextMenu)
            return;

          this.contextMenu.addEventListener("popupshown", this, false);
          this.contextMenu.addEventListener("popuphiding", this, false);
          this.toolbar.addEventListener("mousemove", this, false);
        },
        handleEvent: function (event) {
          switch (event.type) {
            case "popupshown":
              this.toolbar.removeEventListener("mousemove", this, false);
              break;
            case "popuphiding":
            case "mousemove":
              this.toolbar._setInactiveAsync();
              this.toolbar.removeEventListener("mousemove", this, false);
              this.contextMenu.removeEventListener("popuphiding", this, false);
              this.contextMenu.removeEventListener("popupshown", this, false);
              this.contextMenu = null;
              break;
          }
        }
      })]]></field>

      <method name="_setInactive">
        <body><![CDATA[
          this.setAttribute("inactive", "true");
        ]]></body>
      </method>

      <method name="_setInactiveAsync">
        <body><![CDATA[
          this._inactiveTimeout = setTimeout(function (self) {
            if (self.getAttribute("autohide") == "true") {
              self._inactiveTimeout = null;
              self._setInactive();
            }
          }, 0, this);
        ]]></body>
      </method>

      <method name="_setActive">
        <body><![CDATA[
          if (this._inactiveTimeout) {
            clearTimeout(this._inactiveTimeout);
            this._inactiveTimeout = null;
          }
          this.removeAttribute("inactive");
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="DOMMenuBarActive"     action="this._setActive();"/>
      <handler event="popupshowing"         action="this._setActive();"/>
      <handler event="mousedown" button="2" action="this._contextMenuListener.init(event);"/>
      <handler event="DOMMenuBarInactive"><![CDATA[
        if (!this._contextMenuListener.active)
          this._setInactiveAsync();
      ]]></handler>
    </handlers>
  </binding>

  <binding id="toolbar-drag"
           extends="chrome://browser/content/customizableui/toolbar.xml#toolbar">
    <implementation>
      <field name="_dragBindingAlive">true</field>
      <constructor><![CDATA[
        if (!this._draggableStarted) {
          this._draggableStarted = true;
          try {
            let tmp = {};
            Components.utils.import("resource://gre/modules/WindowDraggingUtils.jsm", tmp);
            let draggableThis = new tmp.WindowDraggingElement(this);
            draggableThis.mouseDownCheck = function(e) {
              // Don't move while customizing.
              return this._dragBindingAlive &&
                     this.getAttribute("customizing") != "true";
            };
          } catch (e) {}
        }
      ]]></constructor>
    </implementation>
  </binding>
</bindings>
