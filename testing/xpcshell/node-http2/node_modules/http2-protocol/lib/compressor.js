
















exports.HeaderTable = HeaderTable;
exports.HuffmanTable = HuffmanTable;
exports.HeaderSetCompressor = HeaderSetCompressor;
exports.HeaderSetDecompressor = HeaderSetDecompressor;
exports.Compressor = Compressor;
exports.Decompressor = Decompressor;

var TransformStream = require('stream').Transform;
var assert = require('assert');
var util = require('util');












function HeaderTable(log, limit) {
  var self = HeaderTable.staticTable.map(entryFromPair);
  self._log = log;
  self._limit = limit || DEFAULT_HEADER_TABLE_LIMIT;
  self._staticLength = self.length;
  self._size = 0;
  self._enforceLimit = HeaderTable.prototype._enforceLimit;
  self.add = HeaderTable.prototype.add;
  self.setSizeLimit = HeaderTable.prototype.setSizeLimit;
  return self;
}



























function entryFromPair(pair) {
  var entry = pair.slice();
  entry.reference = false;
  entry.emitted = false;
  entry.keep = false;
  entry._size = size(entry);
  return entry;
}









var DEFAULT_HEADER_TABLE_LIMIT = 4096;

function size(entry) {
  return (new Buffer(entry[0] + entry[1], 'utf8')).length + 32;
}



















HeaderTable.prototype._enforceLimit = function _enforceLimit(limit) {
  var droppedEntries = [];
  var dropPoint = this.length - this._staticLength;
  while ((this._size > limit) && (dropPoint > 0)) {
    dropPoint -= 1;
    var dropped = this.splice(dropPoint, 1)[0];
    this._size -= dropped._size;
    droppedEntries[dropPoint] = dropped;
  }
  return droppedEntries;
};

HeaderTable.prototype.add = function(entry) {
  var limit = this._limit - entry._size;
  var droppedEntries = this._enforceLimit(limit);

  if (this._size <= limit) {
    this.unshift(entry);
    this._size += entry._size;
  }

  return droppedEntries;
};


HeaderTable.prototype.setSizeLimit = function setSizeLimit(limit) {
  this._limit = limit;
  this._enforceLimit(this._limit);
};









HeaderTable.staticTable  = [
  [ ':authority'                  , ''            ],
  [ ':method'                     , 'GET'         ],
  [ ':method'                     , 'POST'        ],
  [ ':path'                       , '/'           ],
  [ ':path'                       , '/index.html' ],
  [ ':scheme'                     , 'http'        ],
  [ ':scheme'                     , 'https'       ],
  [ ':status'                     , '200'         ],
  [ ':status'                     , '500'         ],
  [ ':status'                     , '404'         ],
  [ ':status'                     , '403'         ],
  [ ':status'                     , '400'         ],
  [ ':status'                     , '401'         ],
  [ 'accept-charset'              , ''            ],
  [ 'accept-encoding'             , ''            ],
  [ 'accept-language'             , ''            ],
  [ 'accept-ranges'               , ''            ],
  [ 'accept'                      , ''            ],
  [ 'access-control-allow-origin' , ''            ],
  [ 'age'                         , ''            ],
  [ 'allow'                       , ''            ],
  [ 'authorization'               , ''            ],
  [ 'cache-control'               , ''            ],
  [ 'content-disposition'         , ''            ],
  [ 'content-encoding'            , ''            ],
  [ 'content-language'            , ''            ],
  [ 'content-length'              , ''            ],
  [ 'content-location'            , ''            ],
  [ 'content-range'               , ''            ],
  [ 'content-type'                , ''            ],
  [ 'cookie'                      , ''            ],
  [ 'date'                        , ''            ],
  [ 'etag'                        , ''            ],
  [ 'expect'                      , ''            ],
  [ 'expires'                     , ''            ],
  [ 'from'                        , ''            ],
  [ 'host'                        , ''            ],
  [ 'if-match'                    , ''            ],
  [ 'if-modified-since'           , ''            ],
  [ 'if-none-match'               , ''            ],
  [ 'if-range'                    , ''            ],
  [ 'if-unmodified-since'         , ''            ],
  [ 'last-modified'               , ''            ],
  [ 'link'                        , ''            ],
  [ 'location'                    , ''            ],
  [ 'max-forwards'                , ''            ],
  [ 'proxy-authenticate'          , ''            ],
  [ 'proxy-authorization'         , ''            ],
  [ 'range'                       , ''            ],
  [ 'referer'                     , ''            ],
  [ 'refresh'                     , ''            ],
  [ 'retry-after'                 , ''            ],
  [ 'server'                      , ''            ],
  [ 'set-cookie'                  , ''            ],
  [ 'strict-transport-security'   , ''            ],
  [ 'transfer-encoding'           , ''            ],
  [ 'user-agent'                  , ''            ],
  [ 'vary'                        , ''            ],
  [ 'via'                         , ''            ],
  [ 'www-authenticate'            , ''            ]
];











util.inherits(HeaderSetDecompressor, TransformStream);
function HeaderSetDecompressor(log, table) {
  TransformStream.call(this, { objectMode: true });

  this._log = log.child({ component: 'compressor' });
  this._table = table;
  this._chunks = [];
}




HeaderSetDecompressor.prototype._transform = function _transform(chunk, encoding, callback) {
  this._chunks.push(chunk);
  callback();
};























HeaderSetDecompressor.prototype._execute = function _execute(rep) {
  this._log.trace({ key: rep.name, value: rep.value, index: rep.index },
                  'Executing header representation');

  var entry, pair;

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  if (typeof rep.value === 'number') {
    var index = rep.value;
    entry = this._table[index];

    if (index == -1) {
      if (rep.index) {
        for (var i = 0; i < this._table.length; i++) {
          this._table[i].reference = false;
        }
      } else {
        
        this.setTableSizeLimit(rep.name);
      }
    }

    else if (entry.reference) {
      entry.reference = false;
    }

    else {
      pair = entry.slice();
      this.push(pair);

      if (index >= this._table.length - this._table._staticLength) {
        entry = entryFromPair(pair);
        this._table.add(entry);
      }

      entry.reference = true;
      entry.emitted = true;
    }
  }

  
  
  
  
  
  
  
  else {
    if (typeof rep.name === 'number') {
      pair = [this._table[rep.name][0], rep.value];
    } else {
      pair = [rep.name, rep.value];
    }

    if (rep.index) {
      entry = entryFromPair(pair);
      entry.reference = true;
      entry.emitted = true;
      this._table.add(entry);
    }

    this.push(pair);
  }
};





HeaderSetDecompressor.prototype._flush = function _flush(callback) {
  var buffer = concat(this._chunks);

  
  buffer.cursor = 0;
  while (buffer.cursor < buffer.length) {
    this._execute(HeaderSetDecompressor.header(buffer));
  }

  
  for (var index = 0; index < this._table.length; index++) {
    var entry = this._table[index];
    if (entry.reference && !entry.emitted) {
      this.push(entry.slice());
    }
    entry.emitted = false;
  }

  callback();
};













util.inherits(HeaderSetCompressor, TransformStream);
function HeaderSetCompressor(log, table) {
  TransformStream.call(this, { objectMode: true });

  this._log = log.child({ component: 'compressor' });
  this._table = table;
  this.push = TransformStream.prototype.push.bind(this);
}

HeaderSetCompressor.prototype.send = function send(rep) {
  this._log.trace({ key: rep.name, value: rep.value, index: rep.index },
                  'Emitting header representation');

  if (!rep.chunks) {
    rep.chunks = HeaderSetCompressor.header(rep);
  }
  rep.chunks.forEach(this.push);
};




HeaderSetCompressor.prototype._transform = function _transform(pair, encoding, callback) {
  var name = pair[0].toLowerCase();
  var value = pair[1];
  var entry, rep;

  
  var nameMatch = -1, fullMatch = -1;
  for (var droppedIndex = 0; droppedIndex < this._table.length; droppedIndex++) {
    entry = this._table[droppedIndex];
    if (entry[0] === name) {
      if (entry[1] === value) {
        fullMatch = droppedIndex;
        break;
      } else if (nameMatch === -1) {
        nameMatch = droppedIndex;
      }
    }
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  if (fullMatch !== -1) {
    rep = { name: fullMatch, value: fullMatch, index: false };

    if (!entry.reference) {
      if (fullMatch >= this._table.length - this._table._staticLength) {
        entry = entryFromPair(pair);
        this._table.add(entry);
      }
      this.send(rep);
      entry.reference = true;
      entry.emitted = true;
    }

    else if (entry.keep) {
      this.send(rep);
      this.send(rep);
      this.send(rep);
      this.send(rep);
      entry.keep = false;
      entry.emitted = true;
    }

    else if (entry.emitted) {
      this.send(rep);
      this.send(rep);
    }

    else {
      entry.keep = true;
    }
  }

  
  else {
    entry = entryFromPair(pair);
    entry.emitted = true;

    var indexing = (entry._size < this._table._limit / 2);

    if (indexing) {
      entry.reference = true;
      var droppedEntries = this._table.add(entry);
      for (droppedIndex in droppedEntries) {
        droppedIndex = Number(droppedIndex)
        var dropped = droppedEntries[droppedIndex];
        if (dropped.keep) {
          rep = { name: droppedIndex, value: droppedIndex, index: false };
          this.send(rep);
          this.send(rep);
        }
      }
    }

    this.send({ name: (nameMatch !== -1) ? nameMatch : name, value: value, index: indexing });
  }

  callback();
};




HeaderSetCompressor.prototype._flush = function _flush(callback) {
  
  for (var index = 0; index < this._table.length; index++) {
    var entry = this._table[index];
    if (entry.reference && !entry.keep && !entry.emitted) {
      this.send({ name: index, value: index, index: false });
      entry.reference = false;
    }
    entry.keep = false;
    entry.emitted = false;
  }

  callback();
};

















HeaderSetCompressor.integer = function writeInteger(I, N) {
  var limit = Math.pow(2,N) - 1;
  if (I < limit) {
    return [new Buffer([I])];
  }

  var bytes = [];
  if (N !== 0) {
    bytes.push(limit);
  }
  I -= limit;

  var Q = 1, R;
  while (Q > 0) {
    Q = Math.floor(I / 128);
    R = I % 128;

    if (Q > 0) {
      R += 128;
    }
    bytes.push(R);

    I = Q;
  }

  return [new Buffer(bytes)];
};














HeaderSetDecompressor.integer = function readInteger(buffer, N) {
  var limit = Math.pow(2,N) - 1;

  var I = buffer[buffer.cursor] & limit;
  if (N !== 0) {
    buffer.cursor += 1;
  }

  if (I === limit) {
    var M = 0;
    do {
      I += (buffer[buffer.cursor] & 127) << M;
      M += 7;
      buffer.cursor += 1;
    } while (buffer[buffer.cursor - 1] & 128);
  }

  return I;
};



function HuffmanTable(table) {
  function createTree(codes, position) {
    if (codes.length === 1) {
      return [table.indexOf(codes[0])];
    }

    else {
      position = position || 0;
      var zero = [];
      var one = [];
      for (var i = 0; i < codes.length; i++) {
        var string = codes[i];
        if (string[position] === '0') {
          zero.push(string);
        } else {
          one.push(string);
        }
      }
      return [createTree(zero, position + 1), createTree(one, position + 1)];
    }
  }

  this.tree = createTree(table);

  this.codes = table.map(function(bits) {
    return parseInt(bits, 2);
  });
  this.lengths = table.map(function(bits) {
    return bits.length;
  });
}

HuffmanTable.prototype.encode = function encode(buffer) {
  var result = [];
  var space = 8;

  function add(data) {
    if (space === 8) {
      result.push(data);
    } else {
      result[result.length - 1] |= data;
    }
  }

  for (var i = 0; i < buffer.length; i++) {
    var byte = buffer[i];
    var code = this.codes[byte];
    var length = this.lengths[byte];

    while (length !== 0) {
      if (space >= length) {
        add(code << (space - length));
        code = 0;
        space -= length;
        length = 0;
      } else {
        var shift = length - space;
        var msb = code >> shift;
        add(msb);
        code -= msb << shift;
        length -= space;
        space = 0;
      }

      if (space === 0) {
        space = 8;
      }
    }
  }

  if (space !== 8) {
    add(this.codes[256] >> (this.lengths[256] - space));
  }

  return new Buffer(result);
}

HuffmanTable.prototype.decode = function decode(buffer) {
  var result = [];
  var subtree = this.tree;

  for (var i = 0; i < buffer.length; i++) {
    var byte = buffer[i];

    for (var j = 0; j < 8; j++) {
      var bit = (byte & 128) ? 1 : 0;
      byte = byte << 1;

      subtree = subtree[bit];
      if (subtree.length === 1) {
        result.push(subtree[0]);
        subtree = this.tree;
      }
    }
  }

  return new Buffer(result);
}






HuffmanTable.huffmanTable = new HuffmanTable([
  '111111111111111111110111010',
  '111111111111111111110111011',
  '111111111111111111110111100',
  '111111111111111111110111101',
  '111111111111111111110111110',
  '111111111111111111110111111',
  '111111111111111111111000000',
  '111111111111111111111000001',
  '111111111111111111111000010',
  '111111111111111111111000011',
  '111111111111111111111000100',
  '111111111111111111111000101',
  '111111111111111111111000110',
  '111111111111111111111000111',
  '111111111111111111111001000',
  '111111111111111111111001001',
  '111111111111111111111001010',
  '111111111111111111111001011',
  '111111111111111111111001100',
  '111111111111111111111001101',
  '111111111111111111111001110',
  '111111111111111111111001111',
  '111111111111111111111010000',
  '111111111111111111111010001',
  '111111111111111111111010010',
  '111111111111111111111010011',
  '111111111111111111111010100',
  '111111111111111111111010101',
  '111111111111111111111010110',
  '111111111111111111111010111',
  '111111111111111111111011000',
  '111111111111111111111011001',
  '11101000',
  '111111111100',
  '11111111111010',
  '111111111111100',
  '111111111111101',
  '100100',
  '1101110',
  '111111111111110',
  '11111111010',
  '11111111011',
  '1111111010',
  '11111111100',
  '11101001',
  '100101',
  '00100',
  '0000',
  '00101',
  '00110',
  '00111',
  '100110',
  '100111',
  '101000',
  '101001',
  '101010',
  '101011',
  '101100',
  '111101100',
  '11101010',
  '111111111111111110',
  '101101',
  '11111111111111100',
  '111101101',
  '11111111111011',
  '1101111',
  '11101011',
  '11101100',
  '11101101',
  '11101110',
  '1110000',
  '111101110',
  '111101111',
  '111110000',
  '111110001',
  '1111111011',
  '111110010',
  '11101111',
  '111110011',
  '111110100',
  '111110101',
  '111110110',
  '111110111',
  '11110000',
  '11110001',
  '111111000',
  '111111001',
  '111111010',
  '111111011',
  '111111100',
  '1111111100',
  '11111111111100',
  '111111111111111111111011010',
  '1111111111100',
  '11111111111101',
  '101110',
  '1111111111111111110',
  '01000',
  '101111',
  '01001',
  '110000',
  '0001',
  '110001',
  '110010',
  '110011',
  '01010',
  '1110001',
  '1110010',
  '01011',
  '110100',
  '01100',
  '01101',
  '01110',
  '11110010',
  '01111',
  '10000',
  '10001',
  '110101',
  '1110011',
  '110110',
  '11110011',
  '11110100',
  '11110101',
  '11111111111111101',
  '11111111101',
  '11111111111111110',
  '111111111101',
  '111111111111111111111011011',
  '111111111111111111111011100',
  '111111111111111111111011101',
  '111111111111111111111011110',
  '111111111111111111111011111',
  '111111111111111111111100000',
  '111111111111111111111100001',
  '111111111111111111111100010',
  '111111111111111111111100011',
  '111111111111111111111100100',
  '111111111111111111111100101',
  '111111111111111111111100110',
  '111111111111111111111100111',
  '111111111111111111111101000',
  '111111111111111111111101001',
  '111111111111111111111101010',
  '111111111111111111111101011',
  '111111111111111111111101100',
  '111111111111111111111101101',
  '111111111111111111111101110',
  '111111111111111111111101111',
  '111111111111111111111110000',
  '111111111111111111111110001',
  '111111111111111111111110010',
  '111111111111111111111110011',
  '111111111111111111111110100',
  '111111111111111111111110101',
  '111111111111111111111110110',
  '111111111111111111111110111',
  '111111111111111111111111000',
  '111111111111111111111111001',
  '111111111111111111111111010',
  '111111111111111111111111011',
  '111111111111111111111111100',
  '111111111111111111111111101',
  '111111111111111111111111110',
  '111111111111111111111111111',
  '11111111111111111110000000',
  '11111111111111111110000001',
  '11111111111111111110000010',
  '11111111111111111110000011',
  '11111111111111111110000100',
  '11111111111111111110000101',
  '11111111111111111110000110',
  '11111111111111111110000111',
  '11111111111111111110001000',
  '11111111111111111110001001',
  '11111111111111111110001010',
  '11111111111111111110001011',
  '11111111111111111110001100',
  '11111111111111111110001101',
  '11111111111111111110001110',
  '11111111111111111110001111',
  '11111111111111111110010000',
  '11111111111111111110010001',
  '11111111111111111110010010',
  '11111111111111111110010011',
  '11111111111111111110010100',
  '11111111111111111110010101',
  '11111111111111111110010110',
  '11111111111111111110010111',
  '11111111111111111110011000',
  '11111111111111111110011001',
  '11111111111111111110011010',
  '11111111111111111110011011',
  '11111111111111111110011100',
  '11111111111111111110011101',
  '11111111111111111110011110',
  '11111111111111111110011111',
  '11111111111111111110100000',
  '11111111111111111110100001',
  '11111111111111111110100010',
  '11111111111111111110100011',
  '11111111111111111110100100',
  '11111111111111111110100101',
  '11111111111111111110100110',
  '11111111111111111110100111',
  '11111111111111111110101000',
  '11111111111111111110101001',
  '11111111111111111110101010',
  '11111111111111111110101011',
  '11111111111111111110101100',
  '11111111111111111110101101',
  '11111111111111111110101110',
  '11111111111111111110101111',
  '11111111111111111110110000',
  '11111111111111111110110001',
  '11111111111111111110110010',
  '11111111111111111110110011',
  '11111111111111111110110100',
  '11111111111111111110110101',
  '11111111111111111110110110',
  '11111111111111111110110111',
  '11111111111111111110111000',
  '11111111111111111110111001',
  '11111111111111111110111010',
  '11111111111111111110111011',
  '11111111111111111110111100',
  '11111111111111111110111101',
  '11111111111111111110111110',
  '11111111111111111110111111',
  '11111111111111111111000000',
  '11111111111111111111000001',
  '11111111111111111111000010',
  '11111111111111111111000011',
  '11111111111111111111000100',
  '11111111111111111111000101',
  '11111111111111111111000110',
  '11111111111111111111000111',
  '11111111111111111111001000',
  '11111111111111111111001001',
  '11111111111111111111001010',
  '11111111111111111111001011',
  '11111111111111111111001100',
  '11111111111111111111001101',
  '11111111111111111111001110',
  '11111111111111111111001111',
  '11111111111111111111010000',
  '11111111111111111111010001',
  '11111111111111111111010010',
  '11111111111111111111010011',
  '11111111111111111111010100',
  '11111111111111111111010101',
  '11111111111111111111010110',
  '11111111111111111111010111',
  '11111111111111111111011000',
  '11111111111111111111011001',
  '11111111111111111111011010',
  '11111111111111111111011011',
  '11111111111111111111011100'
]);
































HeaderSetCompressor.string = function writeString(str) {
  str = new Buffer(str, 'utf8');

  var huffman = HuffmanTable.huffmanTable.encode(str);
  if (huffman.length < str.length) {
    var length = HeaderSetCompressor.integer(huffman.length, 7)
    length[0][0] |= 128;
    return length.concat(huffman);
  }

  else {
    length = HeaderSetCompressor.integer(str.length, 7)
    return length.concat(str);
  }
};

HeaderSetDecompressor.string = function readString(buffer) {
  var huffman = buffer[buffer.cursor] & 128;
  var length = HeaderSetDecompressor.integer(buffer, 7);
  var encoded = buffer.slice(buffer.cursor, buffer.cursor + length);
  buffer.cursor += length;
  return (huffman ? HuffmanTable.huffmanTable.decode(encoded) : encoded).toString('utf8');
};




































































var representations = {
  indexed             : { prefix: 7, pattern: 0x80 },
  literal             : { prefix: 6, pattern: 0x40 },
  literalIncremental  : { prefix: 6, pattern: 0x00 }
};

HeaderSetCompressor.header = function writeHeader(header) {
  var representation, buffers = [];

  if (typeof header.value === 'number') {
    representation = representations.indexed;
  } else if (header.index) {
    representation = representations.literalIncremental;
  } else {
    representation = representations.literal;
  }

  if (representation === representations.indexed) {
    buffers.push(HeaderSetCompressor.integer(header.value + 1, representation.prefix));
    if (header.value == -1) {
      if (header.index) {
        buffers.push(HeaderSetCompressor.integer(0x80, 8));
      } else {
        buffers.push(HeaderSetCompressor.integer(header.name, 7));
      }
    }
  }

  else {
    if (typeof header.name === 'number') {
      buffers.push(HeaderSetCompressor.integer(header.name + 1, representation.prefix));
    } else {
      buffers.push(HeaderSetCompressor.integer(0, representation.prefix));
      buffers.push(HeaderSetCompressor.string(header.name));
    }
    buffers.push(HeaderSetCompressor.string(header.value));
  }

  buffers[0][0][0] |= representation.pattern;

  return Array.prototype.concat.apply([], buffers); 
};

HeaderSetDecompressor.header = function readHeader(buffer) {
  var representation, header = {};

  var firstByte = buffer[buffer.cursor];
  if (firstByte & 0x80) {
    representation = representations.indexed;
  } else if (firstByte & 0x40) {
    representation = representations.literal;
  } else {
    representation = representations.literalIncremental;
  }

  if (representation === representations.indexed) {
    header.value = header.name = HeaderSetDecompressor.integer(buffer, representation.prefix) - 1;
    header.index = false;
    if (header.value === -1) {
      if (buffer[buffer.cursor] & 0x80) {
        header.index = true;
        buffer.cursor += 1;
      } else {
        header.name = HeaderSetDecompressor.integer(buffer, 7);
      }
    }
  }

  else {
    header.name = HeaderSetDecompressor.integer(buffer, representation.prefix) - 1;
    if (header.name === -1) {
      header.name = HeaderSetDecompressor.string(buffer);
    }
    header.value = HeaderSetDecompressor.string(buffer);
    header.index = (representation === representations.literalIncremental);
  }

  return header;
};























var MAX_HTTP_PAYLOAD_SIZE = 16383;





util.inherits(Compressor, TransformStream);
function Compressor(log, type) {
  TransformStream.call(this, { objectMode: true });

  this._log = log.child({ component: 'compressor' });

  assert((type === 'REQUEST') || (type === 'RESPONSE'));
  this._table = new HeaderTable(this._log);
}


Compressor.prototype.setTableSizeLimit = function setTableSizeLimit(size) {
  this._table.setSizeLimit(size);
};




Compressor.prototype.compress = function compress(headers) {
  var compressor = new HeaderSetCompressor(this._log, this._table);
  for (var name in headers) {
    var value = headers[name];
    name = String(name).toLowerCase();

    
    
    if (name == 'cookie') {
      if (!(value instanceof Array)) {
        value = [value]
      }
      value = Array.prototype.concat.apply([], value.map(function(cookie) {
        return String(cookie).split(';').map(trim)
      }));
    }

    
    
    
    
    
    
    if ((value instanceof Array) && (name !== 'cookie')) {
      value = value.join('\0');
    }

    if (value instanceof Array) {
      for (var i = 0; i < value.length; i++) {
        compressor.write([name, String(value[i])]);
      }
    } else {
      compressor.write([name, String(value)]);
    }
  }
  compressor.end();

  var chunk, chunks = [];
  while (chunk = compressor.read()) {
    chunks.push(chunk);
  }
  return concat(chunks);
};


Compressor.prototype._transform = function _transform(frame, encoding, done) {
  
  
  
  
  
  
  
  if (frame.type === 'HEADERS' || frame.type === 'PUSH_PROMISE') {
    var buffer = this.compress(frame.headers);

    var chunks = cut(buffer, MAX_HTTP_PAYLOAD_SIZE);

    for (var i = 0; i < chunks.length; i++) {
      var chunkFrame;
      var first = (i === 0);
      var last = (i === chunks.length - 1);

      if (first) {
        chunkFrame = util._extend({}, frame);
        chunkFrame.flags = util._extend({}, frame.flags);
        chunkFrame.flags['END_' + frame.type] = last;
      } else {
        chunkFrame = {
          type: 'CONTINUATION',
          flags: { END_HEADERS: last },
          stream: frame.stream
        };
      }
      chunkFrame.data = chunks[i];

      this.push(chunkFrame);
    }
  }

  
  else {
    this.push(frame);
  }

  done();
};










util.inherits(Decompressor, TransformStream);
function Decompressor(log, type) {
  TransformStream.call(this, { objectMode: true });

  this._log = log.child({ component: 'compressor' });

  assert((type === 'REQUEST') || (type === 'RESPONSE'));
  this._table = new HeaderTable(this._log);

  this._inProgress = false;
  this._base = undefined;
}


Decompressor.prototype.setTableSizeLimit = function setTableSizeLimit(size) {
  this._table.setSizeLimit(size);
};




Decompressor.prototype.decompress = function decompress(block) {
  var decompressor = new HeaderSetDecompressor(this._log, this._table);
  decompressor.end(block);

  var headers = {};
  var pair;
  while (pair = decompressor.read()) {
    var name = pair[0];
    
    
    var values = pair[1].split('\0');
    for (var i = 0; i < values.length; i++) {
      var value = values[i];
      if (name in headers) {
        if (headers[name] instanceof Array) {
          headers[name].push(value);
        } else {
          headers[name] = [headers[name], value];
        }
      } else {
        headers[name] = value;
      }
    }
  }

  
  
  
  if (('cookie' in headers) && (headers['cookie'] instanceof Array)) {
    headers['cookie'] = headers['cookie'].join('; ')
  }

  return headers;
};


Decompressor.prototype._transform = function _transform(frame, encoding, done) {
  
  
  if (this._inProgress) {
    if ((frame.type !== 'CONTINUATION') || (frame.stream !== this._base.stream)) {
      this._log.error('A series of HEADER frames were not continuous');
      this.emit('error', 'PROTOCOL_ERROR');
      return;
    }
    this._frames.push(frame);
  }

  
  
  else if ((frame.type === 'HEADERS') || (frame.type === 'PUSH_PROMISE')) {
    this._inProgress = true;
    this._base = util._extend({}, frame);
    this._frames = [frame];
  }

  
  else {
    this.push(frame);
  }

  
  
  
  if (this._inProgress && (frame.flags.END_HEADERS || frame.flags.END_PUSH_PROMISE)) {
    var buffer = concat(this._frames.map(function(frame) {
      return frame.data;
    }));
    try {
      var headers = this.decompress(buffer);
    } catch(error) {
      this._log.error({ err: error }, 'Header decompression error');
      this.emit('error', 'COMPRESSION_ERROR');
      return;
    }
    this.push(util._extend(this._base, { headers: headers }));
    this._inProgress = false;
  }

  done();
};





function concat(buffers) {
  var size = 0;
  for (var i = 0; i < buffers.length; i++) {
    size += buffers[i].length;
  }

  var concatenated = new Buffer(size);
  for (var cursor = 0, j = 0; j < buffers.length; cursor += buffers[j].length, j++) {
    buffers[j].copy(concatenated, cursor);
  }

  return concatenated;
}


function cut(buffer, size) {
  var chunks = [];
  var cursor = 0;
  do {
    var chunkSize = Math.min(size, buffer.length - cursor);
    chunks.push(buffer.slice(cursor, cursor + chunkSize));
    cursor += chunkSize;
  } while(cursor < buffer.length);
  return chunks;
}

function trim(string) {
  return string.trim()
}
