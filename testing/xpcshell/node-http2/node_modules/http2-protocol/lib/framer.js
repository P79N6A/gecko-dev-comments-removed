



var assert = require('assert');

var Transform = require('stream').Transform;

exports.Serializer = Serializer;
exports.Deserializer = Deserializer;

var logData = Boolean(process.env.HTTP2_LOG_DATA);












function Serializer(log, sizeLimit) {
  this._log = log.child({ component: 'serializer' });
  this._sizeLimit = sizeLimit || MAX_PAYLOAD_SIZE;
  Transform.call(this, { objectMode: true });
}
Serializer.prototype = Object.create(Transform.prototype, { constructor: { value: Serializer } });




Serializer.prototype._transform = function _transform(frame, encoding, done) {
  this._log.trace({ frame: frame }, 'Outgoing frame');

  assert(frame.type in Serializer, 'Unknown frame type: ' + frame.type);

  var buffers = [];
  Serializer[frame.type](frame, buffers);
  Serializer.commonHeader(frame, buffers);

  assert(buffers[0].readUInt16BE(0) <= this._sizeLimit, 'Frame too large!');

  for (var i = 0; i < buffers.length; i++) {
    if (logData) {
      this._log.trace({ data: buffers[i] }, 'Outgoing data');
    }
    this.push(buffers[i]);
  }

  done();
};












function Deserializer(log, sizeLimit) {
  this._log = log.child({ component: 'deserializer' });
  this._sizeLimit = sizeLimit || MAX_PAYLOAD_SIZE;
  Transform.call(this, { objectMode: true });
  this._next(COMMON_HEADER_SIZE);
}
Deserializer.prototype = Object.create(Transform.prototype, { constructor: { value: Deserializer } });






Deserializer.prototype._next = function(size) {
  this._cursor = 0;
  this._buffer = new Buffer(size);
  this._waitingForHeader = !this._waitingForHeader;
  if (this._waitingForHeader) {
    this._frame = {};
  }
};



Deserializer.prototype._transform = function _transform(chunk, encoding, done) {
  var cursor = 0;

  if (logData) {
    this._log.trace({ data: chunk }, 'Incoming data');
  }

  while(cursor < chunk.length) {
    
    
    var toCopy = Math.min(chunk.length - cursor, this._buffer.length - this._cursor);
    chunk.copy(this._buffer, this._cursor, cursor, cursor + toCopy);
    this._cursor += toCopy;
    cursor += toCopy;

    
    

    
    
    if ((this._cursor === this._buffer.length) && this._waitingForHeader) {
      var payloadSize = Deserializer.commonHeader(this._buffer, this._frame);
      if (payloadSize <= this._sizeLimit) {
        this._next(payloadSize);
      } else {
        this.emit('error', 'FRAME_SIZE_ERROR');
        return;
      }
    }

    
    
    
    
    
    if ((this._cursor === this._buffer.length) && !this._waitingForHeader) {
      if (this._frame.type) {
        var error = Deserializer[this._frame.type](this._buffer, this._frame);
        if (error) {
          this._log.error('Incoming frame parsing error: ' + error);
          this.emit('error', 'PROTOCOL_ERROR');
        } else {
          this._log.trace({ frame: this._frame }, 'Incoming frame');
          this.push(this._frame);
        }
      } else {
        this._log.warn({ frame: this._frame }, 'Unknown type incoming frame');
      }
      this._next(COMMON_HEADER_SIZE);
    }
  }

  done();
};


















































var COMMON_HEADER_SIZE = 8;
var MAX_PAYLOAD_SIZE = 16383;

var frameTypes = [];

var frameFlags = {};

var genericAttributes = ['type', 'flags', 'stream'];

var typeSpecificAttributes = {};

Serializer.commonHeader = function writeCommonHeader(frame, buffers) {
  var headerBuffer = new Buffer(COMMON_HEADER_SIZE);

  var size = 0;
  for (var i = 0; i < buffers.length; i++) {
    size += buffers[i].length;
  }
  assert(size <= MAX_PAYLOAD_SIZE, size);
  headerBuffer.writeUInt16BE(size, 0);

  var typeId = frameTypes.indexOf(frame.type);  
  headerBuffer.writeUInt8(typeId, 2);

  var flagByte = 0;
  for (var flag in frame.flags) {
    var position = frameFlags[frame.type].indexOf(flag);
    assert(position !== -1, 'Unknown flag for frame type ' + frame.type + ': ' + flag);
    if (frame.flags[flag]) {
      flagByte |= (1 << position);
    }
  }
  headerBuffer.writeUInt8(flagByte, 3);

  assert((0 <= frame.stream) && (frame.stream < 0x7fffffff), frame.stream);
  headerBuffer.writeUInt32BE(frame.stream || 0, 4);

  buffers.unshift(headerBuffer);
};

Deserializer.commonHeader = function readCommonHeader(buffer, frame) {
  var length = buffer.readUInt16BE(0);

  frame.type = frameTypes[buffer.readUInt8(2)];

  frame.flags = {};
  var flagByte = buffer.readUInt8(3);
  var definedFlags = frameFlags[frame.type];
  for (var i = 0; i < definedFlags.length; i++) {
    frame.flags[definedFlags[i]] = Boolean(flagByte & (1 << i));
  }

  frame.stream = buffer.readUInt32BE(4) & 0x7fffffff;

  return length;
};

























frameTypes[0x0] = 'DATA';

frameFlags.DATA = ['END_STREAM', 'RESERVED'];

typeSpecificAttributes.DATA = ['data'];

Serializer.DATA = function writeData(frame, buffers) {
  buffers.push(frame.data);
};

Deserializer.DATA = function readData(buffer, frame) {
  frame.data = buffer;
};




















frameTypes[0x1] = 'HEADERS';

frameFlags.HEADERS = ['END_STREAM', 'RESERVED', 'END_HEADERS', 'PRIORITY'];

typeSpecificAttributes.HEADERS = ['priority', 'headers', 'data'];











Serializer.HEADERS = function writeHeadersPriority(frame, buffers) {
  if (frame.flags.PRIORITY) {
    var buffer = new Buffer(4);
    assert((0 <= frame.priority) && (frame.priority <= 0xffffffff), frame.priority);
    buffer.writeUInt32BE(frame.priority, 0);
    buffers.push(buffer);
  }
  buffers.push(frame.data);
};

Deserializer.HEADERS = function readHeadersPriority(buffer, frame) {
  if (frame.flags.PRIORITY) {
    frame.priority = buffer.readUInt32BE(0) & 0x7fffffff;
    frame.data = buffer.slice(4);
  } else {
    frame.data = buffer;
  }
};








frameTypes[0x2] = 'PRIORITY';

frameFlags.PRIORITY = [];

typeSpecificAttributes.PRIORITY = ['priority'];









Serializer.PRIORITY = function writePriority(frame, buffers) {
  var buffer = new Buffer(4);
  buffer.writeUInt32BE(frame.priority, 0);
  buffers.push(buffer);
};

Deserializer.PRIORITY = function readPriority(buffer, frame) {
  frame.priority = buffer.readUInt32BE(0);
};








frameTypes[0x3] = 'RST_STREAM';

frameFlags.RST_STREAM = [];

typeSpecificAttributes.RST_STREAM = ['error'];










Serializer.RST_STREAM = function writeRstStream(frame, buffers) {
  var buffer = new Buffer(4);
  var code = errorCodes.indexOf(frame.error);
  assert((0 <= code) && (code <= 0xffffffff), code);
  buffer.writeUInt32BE(code, 0);
  buffers.push(buffer);
};

Deserializer.RST_STREAM = function readRstStream(buffer, frame) {
  frame.error = errorCodes[buffer.readUInt32BE(0)];
};












frameTypes[0x4] = 'SETTINGS';

frameFlags.SETTINGS = ['ACK'];

typeSpecificAttributes.SETTINGS = ['settings'];



















Serializer.SETTINGS = function writeSettings(frame, buffers) {
  var settings = [], settingsLeft = Object.keys(frame.settings);
  definedSettings.forEach(function(setting, id) {
    if (setting.name in frame.settings) {
      settingsLeft.splice(settingsLeft.indexOf(setting.name), 1);
      var value = frame.settings[setting.name];
      settings.push({ id: id, value: setting.flag ? Boolean(value) : value });
    }
  });
  assert(settingsLeft.length === 0, 'Unknown settings: ' + settingsLeft.join(', '));

  var buffer = new Buffer(settings.length * 8);
  for (var i = 0; i < settings.length; i++) {
    buffer.writeUInt32BE(settings[i].id & 0xffffff, i*8);
    buffer.writeUInt32BE(settings[i].value, i*8 + 4);
  }

  buffers.push(buffer);
};

Deserializer.SETTINGS = function readSettings(buffer, frame) {
  frame.settings = {};

  if (buffer.length % 8 !== 0) {
    return 'Invalid SETTINGS frame';
  }
  for (var i = 0; i < buffer.length / 8; i++) {
    var id = buffer.readUInt32BE(i*8) & 0xffffff;
    var setting = definedSettings[id];
    if (setting) {
      var value = buffer.readUInt32BE(i*8 + 4);
      frame.settings[setting.name] = setting.flag ? Boolean(value & 0x1) : value;
    } else {
      
    }
  }
};


var definedSettings = [];




definedSettings[1] = { name: 'SETTINGS_HEADER_TABLE_SIZE', flag: false };





definedSettings[2] = { name: 'SETTINGS_ENABLE_PUSH', flag: true };



definedSettings[4] = { name: 'SETTINGS_MAX_CONCURRENT_STREAMS', flag: false };



definedSettings[7] = { name: 'SETTINGS_INITIAL_WINDOW_SIZE', flag: false };





definedSettings[10] = { name: 'SETTINGS_FLOW_CONTROL_OPTIONS', flag: true };













frameTypes[0x5] = 'PUSH_PROMISE';

frameFlags.PUSH_PROMISE = ['RESERVED1', 'RESERVED2', 'END_PUSH_PROMISE'];

typeSpecificAttributes.PUSH_PROMISE = ['promised_stream', 'headers', 'data'];













Serializer.PUSH_PROMISE = function writePushPromise(frame, buffers) {
  var buffer = new Buffer(4);

  var promised_stream = frame.promised_stream;
  assert((0 <= promised_stream) && (promised_stream <= 0x7fffffff), promised_stream);
  buffer.writeUInt32BE(promised_stream, 0);

  buffers.push(buffer);
  buffers.push(frame.data);
};

Deserializer.PUSH_PROMISE = function readPushPromise(buffer, frame) {
  frame.promised_stream = buffer.readUInt32BE(0) & 0x7fffffff;
  frame.data = buffer.slice(4);
};












frameTypes[0x6] = 'PING';

frameFlags.PING = ['ACK'];

typeSpecificAttributes.PING = ['data'];



Serializer.PING = function writePing(frame, buffers) {
  buffers.push(frame.data);
};

Deserializer.PING = function readPing(buffer, frame) {
  if (buffer.length !== 8) {
    return 'Invalid size PING frame';
  }
  frame.data = buffer;
};








frameTypes[0x7] = 'GOAWAY';

frameFlags.GOAWAY = [];

typeSpecificAttributes.GOAWAY = ['last_stream', 'error'];
















Serializer.GOAWAY = function writeGoaway(frame, buffers) {
  var buffer = new Buffer(8);

  var last_stream = frame.last_stream;
  assert((0 <= last_stream) && (last_stream <= 0x7fffffff), last_stream);
  buffer.writeUInt32BE(last_stream, 0);

  var code = errorCodes.indexOf(frame.error);
  assert((0 <= code) && (code <= 0xffffffff), code);
  buffer.writeUInt32BE(code, 4);

  buffers.push(buffer);
};

Deserializer.GOAWAY = function readGoaway(buffer, frame) {
  frame.last_stream = buffer.readUInt32BE(0) & 0x7fffffff;
  frame.error = errorCodes[buffer.readUInt32BE(4)];
};








frameTypes[0x9] = 'WINDOW_UPDATE';

frameFlags.WINDOW_UPDATE = [];

typeSpecificAttributes.WINDOW_UPDATE = ['window_size'];






Serializer.WINDOW_UPDATE = function writeWindowUpdate(frame, buffers) {
  var buffer = new Buffer(4);

  var window_size = frame.window_size;
  assert((0 <= window_size) && (window_size <= 0x7fffffff), window_size);
  buffer.writeUInt32BE(window_size, 0);

  buffers.push(buffer);
};

Deserializer.WINDOW_UPDATE = function readWindowUpdate(buffer, frame) {
  frame.window_size = buffer.readUInt32BE(0) & 0x7fffffff;
};












frameTypes[0xA] = 'CONTINUATION';

frameFlags.CONTINUATION = ['RESERVED1', 'RESERVED2', 'END_HEADERS'];

typeSpecificAttributes.CONTINUATION = ['headers', 'data'];

Serializer.CONTINUATION = function writeContinuation(frame, buffers) {
  buffers.push(frame.data);
};

Deserializer.CONTINUATION = function readContinuation(buffer, frame) {
  frame.data = buffer;
};




var errorCodes = [
  'NO_ERROR',
  'PROTOCOL_ERROR',
  'INTERNAL_ERROR',
  'FLOW_CONTROL_ERROR',
  'SETTINGS_TIMEOUT',
  'STREAM_CLOSED',
  'FRAME_SIZE_ERROR',
  'REFUSED_STREAM',
  'CANCEL',
  'COMPRESSION_ERROR',
  'CONNECT_ERROR'
];
errorCodes[420] = 'ENHANCE_YOUR_CALM';






exports.serializers = {};



var frameCounter = 0;
exports.serializers.frame = function(frame) {
  if (!frame) {
    return null;
  }

  if ('id' in frame) {
    return frame.id;
  }

  frame.id = frameCounter;
  frameCounter += 1;

  var logEntry = { id: frame.id };
  genericAttributes.concat(typeSpecificAttributes[frame.type]).forEach(function(name) {
    logEntry[name] = frame[name];
  });

  if (frame.data instanceof Buffer) {
    if (logEntry.data.length > 50) {
      logEntry.data = frame.data.slice(0, 47).toString('hex') + '...';
    } else {
      logEntry.data = frame.data.toString('hex');
    }

    if (!('length' in logEntry)) {
      logEntry.length = frame.data.length;
    }
  }

  if (frame.promised_stream instanceof Object) {
    logEntry.promised_stream = 'stream-' + frame.promised_stream.id;
  }

  logEntry.flags = Object.keys(frame.flags || {}).filter(function(name) {
    return frame.flags[name] === true;
  });

  return logEntry;
};


exports.serializers.data = function(data) {
  return data.toString('hex');
};
