












const Cc = Components.classes;
const Ci = Components.interfaces;
const Cu = Components.utils;

let gCertDB = Cc["@mozilla.org/security/x509certdb;1"]
                .getService(Ci.nsIX509CertDB);

let { NetUtil } = Cu.import("resource://gre/modules/NetUtil.jsm", {});

const HEADER = "// This Source Code Form is subject to the terms of the Mozilla Public\n" +
"// License, v. 2.0. If a copy of the MPL was not distributed with this\n" +
"// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n" +
"//\n" +
"//***************************************************************************\n" +
"// This file was automatically generated by makeCNNICHashes.js. It shouldn't\n" +
"// need to be manually edited.\n" +
"//***************************************************************************\n" +
"\n";

const PREAMBLE = "#define CNNIC_WHITELIST_HASH_LEN 32\n\n" +
"struct WhitelistedCNNICHash {\n" +
" const uint8_t hash[CNNIC_WHITELIST_HASH_LEN];\n" +
"};\n\n" +
"static const struct WhitelistedCNNICHash WhitelistedCNNICHashes[] = {\n";

const POSTAMBLE = "};\n";

function writeString(fos, string) {
  fos.write(string, string.length);
}


function hexSlice(fingerprint, start, end) {
  let hexBytes = fingerprint.split(":");
  let ret = "";
  for (let i = start; i < end; i++) {
    let hex = hexBytes[i];
    ret += "0x" + hex;
    if (i < end - 1) {
      ret += ", ";
    }
  }
  return ret;
}


function writeHashes(certs, lastValidTime, fos) {
  writeString(fos, HEADER);
  writeString(fos, `// This file may be removed after ${new Date(lastValidTime)}\n\n`);
  writeString(fos, PREAMBLE);

  certs.forEach(function(cert) {
    writeString(fos, "  {\n");
    writeString(fos, "    { " + hexSlice(cert.sha256Fingerprint, 0, 16) + ",\n");
    writeString(fos, "      " + hexSlice(cert.sha256Fingerprint, 16, 32) + " },\n");

    writeString(fos, "  },\n");
  });
  writeString(fos, POSTAMBLE);
}

function readFileContents(file) {
  let fstream = Cc["@mozilla.org/network/file-input-stream;1"]
                  .createInstance(Ci.nsIFileInputStream);
  fstream.init(file, -1, 0, 0);
  let data = NetUtil.readInputStreamToString(fstream, fstream.available());
  fstream.close();
  return data;
}

function relativePathToFile(path) {
  let currentDirectory = Cc["@mozilla.org/file/directory_service;1"]
                           .getService(Ci.nsIProperties)
                           .get("CurWorkD", Ci.nsILocalFile);
  let file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsILocalFile);
  file.initWithPath(currentDirectory.path + "/" + path);
  return file;
}

function pathToFile(path) {
  let file = relativePathToFile(path);
  if (!file.exists()) {
    
    file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsILocalFile);
    file.initWithPath(path);
  }
  return file;
}


const sixYearsInMilliseconds = 6 * 366 * 24 * 60 * 60 * 1000;

function loadCertificates(certFile) {
  let nowInMilliseconds = (new Date()).getTime();
  let latestNotAfter = nowInMilliseconds;
  let certs = [];
  let invalidCerts = [];
  let paths = readFileContents(certFile).split("\n");
  for (let path of paths) {
    if (!path) {
      continue;
    }
    let certData = readFileContents(pathToFile(path));
    let cert = null;
    try {
      cert = gCertDB.constructX509FromBase64(certData);
    } catch (e) {}
    if (!cert) {
      cert = gCertDB.constructX509(certData, certData.length);
    }
    let durationMilliseconds = (cert.validity.notAfter - cert.validity.notBefore) / 1000;
    let notAfterMilliseconds = cert.validity.notAfter / 1000;
    
    
    
    
    if (notAfterMilliseconds > nowInMilliseconds &&
        durationMilliseconds < sixYearsInMilliseconds) {
      certs.push(cert);
      if (notAfterMilliseconds > latestNotAfter) {
        latestNotAfter = notAfterMilliseconds;
      }
    }
    if (durationMilliseconds >= sixYearsInMilliseconds) {
      invalidCerts.push(cert);
    }
  }
  return { certs: certs,
           lastValidTime: latestNotAfter,
           invalidCerts: invalidCerts };
}


function hexToBinaryString(hexString) {
  let hexBytes = hexString.split(":");
  let result = "";
  for (let hexByte of hexBytes) {
    result += String.fromCharCode(parseInt(hexByte, 16));
  }
  return result;
}

function compareCertificatesByHash(certA, certB) {
  let aBin = hexToBinaryString(certA.sha256Fingerprint);
  let bBin = hexToBinaryString(certB.sha256Fingerprint);

  if (aBin < bBin) {
     return -1;
  }
  if (aBin > bBin) {
     return 1;
  }
 return 0;
}

function certToPEM(cert) {
  let der = cert.getRawDER({});
  let derString = '';
  for (let i = 0; i < der.length; i++) {
    derString += String.fromCharCode(der[i]);
  }
  let base64Lines = btoa(derString).replace(/(.{64})/g, "$1\n");
  let output = "-----BEGIN CERTIFICATE-----\n";
  for (let line of base64Lines.split("\n")) {
    if (line.length > 0) {
      output += line + "\n";
    }
  }
  output += "-----END CERTIFICATE-----";
  return output;
}





if (arguments.length != 1) {
  throw "Usage: makeCNNICHashes.js <path to list of certificates>";
}

let certFile = pathToFile(arguments[0]);
let { certs, lastValidTime, invalidCerts } = loadCertificates(certFile);

dump("The following certificates were not included due to overlong validity periods:\n");
for (let cert of invalidCerts) {
  dump(certToPEM(cert) + "\n");
}


certs.sort(compareCertificatesByHash);


let outFile = relativePathToFile("CNNICHashWhitelist.inc");
if (!outFile.exists()) {
  outFile.create(Ci.nsIFile.NORMAL_FILE_TYPE, 0644);
}
let outStream = Cc["@mozilla.org/network/file-output-stream;1"]
                  .createInstance(Ci.nsIFileOutputStream);
outStream.init(outFile, -1, 0, 0);
writeHashes(certs, lastValidTime, outStream);
outStream.close();
