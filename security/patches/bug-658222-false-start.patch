# HG changeset patch
# User Patrick McManus <mcmanus@ducksong.com>
# Date 1372453108 14400
# Node ID 7587e41b0d6760166e1ab7ec4737fa2523038281
# Parent  bd363921496c4a219851de041249455e91fe3147
bug 658222 - Enable TLS False Start (PSM) r=bsmith

diff --git a/netwerk/base/public/security-prefs.js b/netwerk/base/public/security-prefs.js
--- a/netwerk/base/public/security-prefs.js
+++ b/netwerk/base/public/security-prefs.js
@@ -7,18 +7,20 @@ pref("security.tls.version.max", 1);
 pref("security.enable_tls_session_tickets", true);
 pref("security.enable_md5_signatures", false);
 
 pref("security.ssl.allow_unrestricted_renego_everywhere__temporarily_available_pref", false);
 pref("security.ssl.renego_unrestricted_hosts", "");
 pref("security.ssl.treat_unsafe_negotiation_as_broken", false);
 pref("security.ssl.require_safe_negotiation",  false);
 pref("security.ssl.warn_missing_rfc5746",  1);
-pref("security.ssl.enable_false_start", false);
 pref("security.ssl.enable_ocsp_stapling", true);
+pref("security.ssl.enable_false_start", true);
+pref("security.ssl.false_start.require-npn", true);
+pref("security.ssl.false_start.require-forward-secrecy", false);
 
 pref("security.ssl3.rsa_rc4_128_md5", true);
 pref("security.ssl3.rsa_rc4_128_sha", true);
 pref("security.ssl3.rsa_fips_des_ede3_sha", true);
 pref("security.ssl3.rsa_des_ede3_sha", true);
 pref("security.ssl3.dhe_rsa_camellia_256_sha", true);
 pref("security.ssl3.dhe_dss_camellia_256_sha", true);
 pref("security.ssl3.rsa_camellia_256_sha", true);
diff --git a/netwerk/protocol/http/ConnectionDiagnostics.cpp b/netwerk/protocol/http/ConnectionDiagnostics.cpp
--- a/netwerk/protocol/http/ConnectionDiagnostics.cpp
+++ b/netwerk/protocol/http/ConnectionDiagnostics.cpp
@@ -122,18 +122,18 @@ nsHttpConnectionMgr::nsHalfOpenSocket::P
                    !!mSocketTransport.get(), !!mBackupTransport.get());
 }
 
 void
 nsHttpConnection::PrintDiagnostics(nsCString &log)
 {
   log.AppendPrintf("    CanDirectlyActivate = %d\n", CanDirectlyActivate());
 
-  log.AppendPrintf("    npncomplete = %d  setupNPNCalled = %d\n",
-                   mNPNComplete, mSetupNPNCalled);
+  log.AppendPrintf("    npncomplete = %d  setupSSLCalled = %d\n",
+                   mNPNComplete, mSetupSSLCalled);
 
   log.AppendPrintf("    spdyVersion = %d  reportedSpdy = %d everspdy = %d\n",
                    mUsingSpdyVersion, mReportedSpdy, mEverUsedSpdy);
 
   log.AppendPrintf("    iskeepalive = %d  dontReuse = %d isReused = %d\n",
                    IsKeepAlive(), mDontReuse, mIsReused);
 
   log.AppendPrintf("    mTransaction = %d mSpdySession = %d\n",
diff --git a/netwerk/protocol/http/nsHttp.h b/netwerk/protocol/http/nsHttp.h
--- a/netwerk/protocol/http/nsHttp.h
+++ b/netwerk/protocol/http/nsHttp.h
@@ -53,16 +53,21 @@ typedef uint8_t nsHttpVersion;
 // such as HTTP upgrade which are nonsensical for SPDY, it is not the
 // SPDY configuration variable.
 #define NS_HTTP_DISALLOW_SPDY        (1<<7)
 
 // a transaction with this flag loads without respect to whether the load
 // group is currently blocking on some resources
 #define NS_HTTP_LOAD_UNBLOCKED       (1<<8)
 
+// These flags allow a transaction to use TLS false start with
+// weaker security profiles based on past history
+#define NS_HTTP_ALLOW_RSA_FALSESTART (1<<9)
+#define NS_HTTP_ALLOW_RC4_FALSESTART (1<<10)
+
 //-----------------------------------------------------------------------------
 // some default values
 //-----------------------------------------------------------------------------
 
 #define NS_HTTP_DEFAULT_PORT  80
 #define NS_HTTPS_DEFAULT_PORT 443
 
 #define NS_HTTP_HEADER_SEPS ", \t"
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -34,16 +34,24 @@
 #include "nsError.h"
 #include "nsAlgorithm.h"
 #include "GeckoProfiler.h"
 #include "nsIConsoleService.h"
 #include "base/compiler_specific.h"
 #include "NullHttpTransaction.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/VisualEventTracer.h"
+#include "nsISSLSocketControl.h"
+#include "sslt.h"
+#include "nsContentUtils.h"
+#include "nsIPermissionManager.h"
+#include "nsIPrincipal.h"
+#include "nsIScriptSecurityManager.h"
+#include "nsISSLStatus.h"
+#include "nsISSLStatusProvider.h"
 
 namespace mozilla { namespace net {
 
 namespace {
 
 // Device IDs for various cache types
 const char kDiskDeviceID[] = "disk";
 const char kMemoryDeviceID[] = "memory";
@@ -385,16 +393,17 @@ nsHttpChannel::Connect()
         }
     }
 
     // ensure that we are using a valid hostname
     if (!net_IsValidHostName(nsDependentCString(mConnectionInfo->Host())))
         return NS_ERROR_UNKNOWN_HOST;
 
     // Consider opening a TCP connection right away
+    RetrieveSSLOptions();
     SpeculativeConnect();
 
     // Don't allow resuming when cache must be used
     if (mResuming && (mLoadFlags & LOAD_ONLY_FROM_CACHE)) {
         LOG(("Resuming from cache is not supported yet"));
         return NS_ERROR_DOCUMENT_NOT_CACHED;
     }
 
@@ -521,18 +530,19 @@ nsHttpChannel::SpeculativeConnect()
     nsCOMPtr<nsIInterfaceRequestor> callbacks;
     NS_NewNotificationCallbacksAggregation(mCallbacks, mLoadGroup,
                                            getter_AddRefs(callbacks));
     if (!callbacks)
         return;
 
     mConnectionInfo->SetAnonymous((mLoadFlags & LOAD_ANONYMOUS) != 0);
     mConnectionInfo->SetPrivate(mPrivateBrowsing);
-    gHttpHandler->SpeculativeConnect(mConnectionInfo,
-                                     callbacks);
+    gHttpHandler->SpeculativeConnect(
+        mConnectionInfo, callbacks,
+        mCaps & (NS_HTTP_ALLOW_RSA_FALSESTART | NS_HTTP_ALLOW_RC4_FALSESTART | NS_HTTP_DISALLOW_SPDY));
 }
 
 void
 nsHttpChannel::DoNotifyListenerCleanup()
 {
     // We don't need this info anymore
     CleanRedirectCacheChainIfNecessary();
 }
@@ -687,16 +697,47 @@ nsHttpChannel::SetupTransactionLoadGroup
 
     // Set the load group connection scope on the transaction
     nsCOMPtr<nsILoadGroupConnectionInfo> ci;
     rootLoadGroup->GetConnectionInfo(getter_AddRefs(ci));
     if (ci)
         mTransaction->SetLoadGroupConnectionInfo(ci);
 }
 
+void
+nsHttpChannel::RetrieveSSLOptions()
+{
+    if (!IsHTTPS() || mPrivateBrowsing)
+        return;
+
+    nsIPrincipal *principal = GetPrincipal();
+    if (!principal)
+        return;
+
+    nsCOMPtr<nsIPermissionManager> permMgr =
+        do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
+    if (!permMgr)
+        return;
+
+    uint32_t perm;
+    nsresult rv = permMgr->TestPermissionFromPrincipal(principal,
+                                                       "falsestart-rsa", &perm);
+    if (NS_SUCCEEDED(rv) && perm == nsIPermissionManager::ALLOW_ACTION) {
+        LOG(("nsHttpChannel::RetrieveSSLOptions [this=%p] "
+             "falsestart-rsa permission found\n", this));
+        mCaps |= NS_HTTP_ALLOW_RSA_FALSESTART;
+    }
+    rv = permMgr->TestPermissionFromPrincipal(principal, "falsestart-rc4", &perm);
+    if (NS_SUCCEEDED(rv) && perm == nsIPermissionManager::ALLOW_ACTION) {
+        LOG(("nsHttpChannel::RetrieveSSLOptions [this=%p] "
+             "falsestart-rc4 permission found\n", this));
+        mCaps |= NS_HTTP_ALLOW_RC4_FALSESTART;
+    }
+}
+
 nsresult
 nsHttpChannel::SetupTransaction()
 {
     LOG(("nsHttpChannel::SetupTransaction [this=%p]\n", this));
 
     NS_ENSURE_TRUE(!mTransaction, NS_ERROR_ALREADY_INITIALIZED);
 
     nsresult rv;
@@ -1154,16 +1195,99 @@ nsHttpChannel::ProcessSTSHeader()
     if (NS_FAILED(rv)) {
         LOG(("STS: Failed to parse STS header, continuing load.\n"));
         return NS_OK;
     }
 
     return NS_OK;
 }
 
+bool
+nsHttpChannel::IsHTTPS()
+{
+    bool isHttps;
+    if (NS_FAILED(mURI->SchemeIs("https", &isHttps)) || !isHttps)
+        return false;
+    return true;
+}
+
+void
+nsHttpChannel::ProcessSSLInformation()
+{
+    // If this is HTTPS, record any use of RSA so that Key Exchange Algorithm
+    // can be whitelisted for TLS False Start in future sessions. We could
+    // do the same for DH but its rarity doesn't justify the lookup.
+    // Also do the same for RC4 symmetric ciphers.
+
+    if (mCanceled || NS_FAILED(mStatus) || !mSecurityInfo ||
+        !IsHTTPS() || mPrivateBrowsing)
+        return;
+
+    nsCOMPtr<nsISSLSocketControl> ssl = do_QueryInterface(mSecurityInfo);
+    nsCOMPtr<nsISSLStatusProvider> statusProvider =
+        do_QueryInterface(mSecurityInfo);
+    if (!ssl || !statusProvider)
+        return;
+    nsCOMPtr<nsISSLStatus> sslstat;
+    statusProvider->GetSSLStatus(getter_AddRefs(sslstat));
+    if (!sslstat)
+        return;
+
+    // If certificate exceptions are being used don't record this information
+    // in the permission manager.
+    bool trustCheck;
+    if (NS_FAILED(sslstat->GetIsDomainMismatch(&trustCheck)) || trustCheck)
+        return;
+    if (NS_FAILED(sslstat->GetIsNotValidAtThisTime(&trustCheck)) || trustCheck)
+        return;
+    if (NS_FAILED(sslstat->GetIsUntrusted(&trustCheck)) || trustCheck)
+        return;
+
+    int16_t kea = ssl->GetKEAUsed();
+    int16_t symcipher = ssl->GetSymmetricCipherUsed();
+
+    nsIPrincipal *principal = GetPrincipal();
+    if (!principal)
+        return;
+
+    // set a permission manager flag that future transactions can
+    // use via RetrieveSSLOptions(()
+
+    nsCOMPtr<nsIPermissionManager> permMgr =
+        do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
+    if (!permMgr)
+        return;
+
+    // Allow this to stand for a week
+    int64_t expireTime = (PR_Now() / PR_USEC_PER_MSEC) +
+        (86400 * 7 * PR_MSEC_PER_SEC);
+
+    if (kea == ssl_kea_rsa) {
+        permMgr->AddFromPrincipal(principal, "falsestart-rsa",
+                                  nsIPermissionManager::ALLOW_ACTION,
+                                  nsIPermissionManager::EXPIRE_TIME,
+                                  expireTime);
+        LOG(("nsHttpChannel::ProcessSSLInformation [this=%p] "
+             "falsestart-rsa permission granted for this host\n", this));
+    } else {
+        permMgr->RemoveFromPrincipal(principal, "falsestart-rsa");
+    }
+
+    if (symcipher == ssl_calg_rc4) {
+        permMgr->AddFromPrincipal(principal, "falsestart-rc4",
+                                  nsIPermissionManager::ALLOW_ACTION,
+                                  nsIPermissionManager::EXPIRE_TIME,
+                                  expireTime);
+        LOG(("nsHttpChannel::ProcessSSLInformation [this=%p] "
+             "falsestart-rc4 permission granted for this host\n", this));
+    } else {
+        permMgr->RemoveFromPrincipal(principal, "falsestart-rc4");
+    }
+}
+
 nsresult
 nsHttpChannel::ProcessResponse()
 {
     nsresult rv;
     uint32_t httpStatus = mResponseHead->Status();
 
     // Gather data on whether the transaction and page (if this is
     // the initial page load) is being loaded with SSL.
@@ -1186,16 +1310,18 @@ nsHttpChannel::ProcessResponse()
     } else {
         // Given a successful connection, process any STS data that's relevant.
         rv = ProcessSTSHeader();
         MOZ_ASSERT(NS_SUCCEEDED(rv), "ProcessSTSHeader failed, continuing load.");
     }
 
     MOZ_ASSERT(!mCachedContentIsValid);
 
+    ProcessSSLInformation();
+
     // notify "http-on-examine-response" observers
     gHttpHandler->OnExamineResponse(this);
 
     SetCookie(mResponseHead->PeekHeader(nsHttp::Set_Cookie));
 
     // handle unused username and password in url (see bug 232567)
     if (httpStatus != 401 && httpStatus != 407) {
         if (!mAuthRetryPending)
@@ -6020,16 +6146,40 @@ nsHttpChannel::ShouldSkipCache()
 
     LOG(("Cache dampener installed because service lock held too long [%fms]\n",
          timeLocked));
     cacheSkippedUntil = TimeStamp::Now() + TimeDuration::FromSeconds(60);
     gHttpHandler->SetCacheSkippedUntil(cacheSkippedUntil);
     return true;
 }
 
+nsIPrincipal *
+nsHttpChannel::GetPrincipal()
+{
+    if (mPrincipal)
+        return mPrincipal;
+
+    nsIScriptSecurityManager *securityManager =
+        nsContentUtils::GetSecurityManager();
+
+    if (!securityManager)
+        return nullptr;
+
+    securityManager->GetChannelPrincipal(this, getter_AddRefs(mPrincipal));
+    if (!mPrincipal)
+        return nullptr;
+
+    // principals with unknown app ids do not work with the permission manager
+    if (mPrincipal->GetUnknownAppId())
+        mPrincipal = nullptr;
+
+    return mPrincipal;
+}
+
+
 NS_IMETHODIMP
 nsHttpChannel::SetLoadGroup(nsILoadGroup *aLoadGroup)
 {
     MOZ_ASSERT(NS_IsMainThread(), "Wrong thread.");
 
     nsresult rv = HttpBaseChannel::SetLoadGroup(aLoadGroup);
     if (NS_SUCCEEDED(rv)) {
         UpdateAggregateCallbacks();
diff --git a/netwerk/protocol/http/nsHttpChannel.h b/netwerk/protocol/http/nsHttpChannel.h
--- a/netwerk/protocol/http/nsHttpChannel.h
+++ b/netwerk/protocol/http/nsHttpChannel.h
@@ -29,16 +29,17 @@
 #include "nsITimedChannel.h"
 #include "nsIFile.h"
 #include "nsDNSPrefetch.h"
 #include "TimingStruct.h"
 #include "AutoClose.h"
 #include "mozilla/Telemetry.h"
 
 class nsAHttpConnection;
+class nsIPrincipal;
 
 namespace mozilla { namespace net {
 
 class HttpCacheQuery;
 
 //-----------------------------------------------------------------------------
 // nsHttpChannel
 //-----------------------------------------------------------------------------
@@ -169,16 +170,19 @@ private:
     nsresult AsyncProcessRedirection(uint32_t httpStatus);
     nsresult ContinueProcessRedirection(nsresult);
     nsresult ContinueProcessRedirectionAfterFallback(nsresult);
     nsresult ProcessFailedProxyConnect(uint32_t httpStatus);
     nsresult ProcessFallback(bool *waitingForRedirectCallback);
     nsresult ContinueProcessFallback(nsresult);
     void     HandleAsyncAbort();
     nsresult EnsureAssocReq();
+    void     ProcessSSLInformation();
+    bool     IsHTTPS();
+    void     RetrieveSSLOptions();
 
     nsresult ContinueOnStartRequest1(nsresult);
     nsresult ContinueOnStartRequest2(nsresult);
     nsresult ContinueOnStartRequest3(nsresult);
 
     // redirection specific methods
     void     HandleAsyncRedirect();
     void     HandleAsyncAPIRedirect();
@@ -368,13 +372,17 @@ private:
     void PushRedirectAsyncFunc(nsContinueRedirectionFunc func);
     void PopRedirectAsyncFunc(nsContinueRedirectionFunc func);
 
 protected:
     virtual void DoNotifyListenerCleanup();
 
 private: // cache telemetry
     bool mDidReval;
+
+private:
+    nsIPrincipal *GetPrincipal();
+    nsCOMPtr<nsIPrincipal> mPrincipal;
 };
 
 } } // namespace mozilla::net
 
 #endif // nsHttpChannel_h__
diff --git a/netwerk/protocol/http/nsHttpConnection.cpp b/netwerk/protocol/http/nsHttpConnection.cpp
--- a/netwerk/protocol/http/nsHttpConnection.cpp
+++ b/netwerk/protocol/http/nsHttpConnection.cpp
@@ -12,16 +12,17 @@
 #include "nsHttpRequestHead.h"
 #include "nsHttpResponseHead.h"
 #include "nsHttpHandler.h"
 #include "nsIOService.h"
 #include "nsISocketTransportService.h"
 #include "nsISocketTransport.h"
 #include "nsIServiceManager.h"
 #include "nsISSLSocketControl.h"
+#include "sslt.h"
 #include "nsStringStream.h"
 #include "netCore.h"
 #include "nsNetCID.h"
 #include "nsProxyRelease.h"
 #include "nsPreloadedStream.h"
 #include "ASpdySession.h"
 #include "mozilla/Telemetry.h"
 #include "nsISupportsPriority.h"
@@ -59,21 +60,22 @@ nsHttpConnection::nsHttpConnection()
     , mCompletedProxyConnect(false)
     , mLastTransactionExpectedNoContent(false)
     , mIdleMonitoring(false)
     , mProxyConnectInProgress(false)
     , mHttp1xTransactionCount(0)
     , mRemainingConnectionUses(0xffffffff)
     , mClassification(nsAHttpTransaction::CLASS_GENERAL)
     , mNPNComplete(false)
-    , mSetupNPNCalled(false)
+    , mSetupSSLCalled(false)
     , mUsingSpdyVersion(0)
     , mPriority(nsISupportsPriority::PRIORITY_NORMAL)
     , mReportedSpdy(false)
     , mEverUsedSpdy(false)
+    , mTransactionCaps(0)
 {
     LOG(("Creating nsHttpConnection @%x\n", this));
 
     // grab a reference to the handler to ensure that it doesn't go away.
     nsHttpHandler *handler = gHttpHandler;
     NS_ADDREF(handler);
 }
 
@@ -231,18 +233,16 @@ nsHttpConnection::StartSpdy(uint8_t spdy
     mSupportsPipelining = false; // dont use http/1 pipelines with spdy
     mTransaction = mSpdySession;
     mIdleTimeout = gHttpHandler->SpdyTimeout();
 }
 
 bool
 nsHttpConnection::EnsureNPNComplete()
 {
-    // NPN is only used by SPDY right now.
-    //
     // If for some reason the components to check on NPN aren't available,
     // this function will just return true to continue on and disable SPDY
 
     MOZ_ASSERT(mSocketTransport);
     if (!mSocketTransport) {
         // this cannot happen
         mNPNComplete = true;
         return true;
@@ -303,32 +303,33 @@ nsresult
 nsHttpConnection::Activate(nsAHttpTransaction *trans, uint32_t caps, int32_t pri)
 {
     nsresult rv;
 
     MOZ_ASSERT(PR_GetCurrentThread() == gSocketThread);
     LOG(("nsHttpConnection::Activate [this=%p trans=%x caps=%x]\n",
          this, trans, caps));
 
+    mTransactionCaps = caps;
     mPriority = pri;
     if (mTransaction && mUsingSpdyVersion)
         return AddTransaction(trans, pri);
 
     NS_ENSURE_ARG_POINTER(trans);
     NS_ENSURE_TRUE(!mTransaction, NS_ERROR_IN_PROGRESS);
 
     // reset the read timers to wash away any idle time
     mLastReadTime = PR_IntervalNow();
 
     // Update security callbacks
     nsCOMPtr<nsIInterfaceRequestor> callbacks;
     trans->GetSecurityCallbacks(getter_AddRefs(callbacks));
     SetSecurityCallbacks(callbacks);
 
-    SetupNPN(caps); // only for spdy
+    SetupSSL(caps);
 
     // take ownership of the transaction
     mTransaction = trans;
 
     MOZ_ASSERT(!mIdleMonitoring, "Activating a connection with an Idle Monitor");
     mIdleMonitoring = false;
 
     // set mKeepAlive according to what will be requested
@@ -355,65 +356,80 @@ failed_activation:
     if (NS_FAILED(rv)) {
         mTransaction = nullptr;
     }
 
     return rv;
 }
 
 void
-nsHttpConnection::SetupNPN(uint32_t caps)
+nsHttpConnection::SetupSSL(uint32_t caps)
 {
-    if (mSetupNPNCalled)                                /* do only once */
+    LOG(("nsHttpConnection::SetupSSL %p caps=0x%X\n", this, caps));
+
+    if (mSetupSSLCalled) // do only once
         return;
-    mSetupNPNCalled = true;
+    mSetupSSLCalled = true;
 
-    // Setup NPN Negotiation if necessary (only for SPDY)
-    if (!mNPNComplete) {
+    if (mNPNComplete)
+        return;
 
-        mNPNComplete = true;
+    // we flip this back to false if SetNPNList succeeds at the end
+    // of this function
+    mNPNComplete = true;
 
-        if (mConnInfo->UsingSSL()) {
-            LOG(("nsHttpConnection::SetupNPN Setting up "
-                 "Next Protocol Negotiation"));
-            nsCOMPtr<nsISupports> securityInfo;
-            nsresult rv =
-                mSocketTransport->GetSecurityInfo(getter_AddRefs(securityInfo));
-            if (NS_FAILED(rv))
-                return;
+    if (!mConnInfo->UsingSSL())
+        return;
 
-            nsCOMPtr<nsISSLSocketControl> ssl =
-                do_QueryInterface(securityInfo, &rv);
-            if (NS_FAILED(rv))
-                return;
+    LOG(("nsHttpConnection::SetupSSL Setting up "
+         "Next Protocol Negotiation"));
+    nsCOMPtr<nsISupports> securityInfo;
+    nsresult rv =
+        mSocketTransport->GetSecurityInfo(getter_AddRefs(securityInfo));
+    if (NS_FAILED(rv))
+        return;
 
-            nsTArray<nsCString> protocolArray;
+    nsCOMPtr<nsISSLSocketControl> ssl = do_QueryInterface(securityInfo, &rv);
+    if (NS_FAILED(rv))
+        return;
 
-            // The first protocol is used as the fallback if none of the
-            // protocols supported overlap with the server's list.
-            // In the case of overlap, matching priority is driven by
-            // the order of the server's advertisement.
-            protocolArray.AppendElement(NS_LITERAL_CSTRING("http/1.1"));
+    if (caps & NS_HTTP_ALLOW_RSA_FALSESTART) {
+        LOG(("nsHttpConnection::SetupSSL %p "
+             ">= RSA Key Exchange Expected\n", this));
+        ssl->SetKEAExpected(ssl_kea_rsa);
+    }
 
-            if (gHttpHandler->IsSpdyEnabled() &&
-                !(caps & NS_HTTP_DISALLOW_SPDY)) {
-                LOG(("nsHttpConnection::SetupNPN Allow SPDY NPN selection"));
-                if (gHttpHandler->SpdyInfo()->ProtocolEnabled(0))
-                    protocolArray.AppendElement(
-                        gHttpHandler->SpdyInfo()->VersionString[0]);
-                if (gHttpHandler->SpdyInfo()->ProtocolEnabled(1))
-                    protocolArray.AppendElement(
-                        gHttpHandler->SpdyInfo()->VersionString[1]);
-            }
+    if (caps & NS_HTTP_ALLOW_RC4_FALSESTART) {
+        LOG(("nsHttpConnection::SetupSSL %p "
+             ">= RC4 Key Exchange Expected\n", this));
+        ssl->SetSymmetricCipherExpected(ssl_calg_rc4);
+    }
 
-            if (NS_SUCCEEDED(ssl->SetNPNList(protocolArray))) {
-                LOG(("nsHttpConnection::Init Setting up SPDY Negotiation OK"));
-                mNPNComplete = false;
-            }
-        }
+    nsTArray<nsCString> protocolArray;
+
+    // The first protocol is used as the fallback if none of the
+    // protocols supported overlap with the server's list.
+    // In the case of overlap, matching priority is driven by
+    // the order of the server's advertisement.
+    protocolArray.AppendElement(NS_LITERAL_CSTRING("http/1.1"));
+
+    if (gHttpHandler->IsSpdyEnabled() &&
+        !(caps & NS_HTTP_DISALLOW_SPDY)) {
+        LOG(("nsHttpConnection::SetupSSL Allow SPDY NPN selection"));
+        if (gHttpHandler->SpdyInfo()->ProtocolEnabled(0))
+            protocolArray.AppendElement(
+                gHttpHandler->SpdyInfo()->VersionString[0]);
+        if (gHttpHandler->SpdyInfo()->ProtocolEnabled(1))
+            protocolArray.AppendElement(
+                gHttpHandler->SpdyInfo()->VersionString[1]);
+    }
+
+    if (NS_SUCCEEDED(ssl->SetNPNList(protocolArray))) {
+        LOG(("nsHttpConnection::Init Setting up SPDY Negotiation OK"));
+        mNPNComplete = false;
     }
 }
 
 nsresult
 nsHttpConnection::AddTransaction(nsAHttpTransaction *httpTransaction,
                                  int32_t priority)
 {
     LOG(("nsHttpConnection::AddTransaction for SPDY"));
@@ -591,17 +607,17 @@ nsHttpConnection::TimeToLive()
 bool
 nsHttpConnection::IsAlive()
 {
     if (!mSocketTransport)
         return false;
 
     // SocketTransport::IsAlive can run the SSL state machine, so make sure
     // the NPN options are set before that happens.
-    SetupNPN(0);
+    SetupSSL(mTransactionCaps);
 
     bool alive;
     nsresult rv = mSocketTransport->IsAlive(&alive);
     if (NS_FAILED(rv))
         alive = false;
 
 //#define TEST_RESTART_LOGIC
 #ifdef TEST_RESTART_LOGIC
diff --git a/netwerk/protocol/http/nsHttpConnection.h b/netwerk/protocol/http/nsHttpConnection.h
--- a/netwerk/protocol/http/nsHttpConnection.h
+++ b/netwerk/protocol/http/nsHttpConnection.h
@@ -153,16 +153,17 @@ public:
     // When the connection is active this is called every second
     void  ReadTimeoutTick();
 
     int64_t BytesWritten() { return mTotalBytesWritten; }
 
     void    SetSecurityCallbacks(nsIInterfaceRequestor* aCallbacks);
     void    PrintDiagnostics(nsCString &log);
 
+    void    SetTransactionCaps(uint32_t aCaps) { mTransactionCaps = aCaps; }
 private:
     // called to cause the underlying socket to start speaking SSL
     nsresult ProxyStartSSL();
 
     nsresult OnTransactionDone(nsresult reason);
     nsresult OnSocketWritable();
     nsresult OnSocketReadable();
 
@@ -170,17 +171,17 @@ private:
 
     PRIntervalTime IdleTime();
     bool     IsAlive();
     bool     SupportsPipelining(nsHttpResponseHead *);
 
     // Makes certain the SSL handshake is complete and NPN negotiation
     // has had a chance to happen
     bool     EnsureNPNComplete();
-    void     SetupNPN(uint32_t caps);
+    void     SetupSSL(uint32_t caps);
 
     // Start the Spdy transaction handler when NPN indicates spdy/*
     void     StartSpdy(uint8_t versionLevel);
 
     // Directly Add a transaction to an active connection for SPDY
     nsresult AddTransaction(nsAHttpTransaction *, int32_t);
 
 private:
@@ -235,22 +236,25 @@ private:
     // transactions (including the current one) that the server expects to allow
     // on this persistent connection.
     uint32_t                        mRemainingConnectionUses;
 
     nsAHttpTransaction::Classifier  mClassification;
 
     // SPDY related
     bool                            mNPNComplete;
-    bool                            mSetupNPNCalled;
+    bool                            mSetupSSLCalled;
 
     // version level in use, 0 if unused
     uint8_t                         mUsingSpdyVersion;
 
     nsRefPtr<mozilla::net::ASpdySession> mSpdySession;
     int32_t                         mPriority;
     bool                            mReportedSpdy;
 
     // mUsingSpdyVersion is cleared when mSpdySession is freed, this is permanent
     bool                            mEverUsedSpdy;
+
+    // The capabailities associated with the most recent transaction
+    uint32_t                        mTransactionCaps;
 };
 
 #endif // nsHttpConnection_h__
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.cpp b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
--- a/netwerk/protocol/http/nsHttpConnectionMgr.cpp
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.cpp
@@ -321,27 +321,28 @@ nsHttpConnectionMgr::DoShiftReloadConnec
                             0, connInfo);
     if (NS_SUCCEEDED(rv))
         connInfo.forget();
     return rv;
 }
 
 nsresult
 nsHttpConnectionMgr::SpeculativeConnect(nsHttpConnectionInfo *ci,
-                                        nsIInterfaceRequestor *callbacks)
+                                        nsIInterfaceRequestor *callbacks,
+                                        uint32_t caps)
 {
     LOG(("nsHttpConnectionMgr::SpeculativeConnect [ci=%s]\n",
          ci->HashKey().get()));
 
     // Wrap up the callbacks and the target to ensure they're released on the target
     // thread properly.
     nsCOMPtr<nsIInterfaceRequestor> wrappedCallbacks;
     NS_NewInterfaceRequestorAggregation(callbacks, nullptr, getter_AddRefs(wrappedCallbacks));
 
-    uint32_t caps = ci->GetAnonymous() ? NS_HTTP_LOAD_ANONYMOUS : 0;
+    caps |= ci->GetAnonymous() ? NS_HTTP_LOAD_ANONYMOUS : 0;
     nsRefPtr<NullHttpTransaction> trans =
         new NullHttpTransaction(ci, wrappedCallbacks, caps);
 
     nsresult rv =
         PostEvent(&nsHttpConnectionMgr::OnMsgSpeculativeConnect, 0, trans);
     if (NS_SUCCEEDED(rv))
         trans.forget();
     return rv;
@@ -2809,16 +2810,20 @@ nsHalfOpenSocket::OnOutputStreamReady(ns
 
     CancelBackupTimer();
 
     // assign the new socket to the http connection
     nsRefPtr<nsHttpConnection> conn = new nsHttpConnection();
     LOG(("nsHalfOpenSocket::OnOutputStreamReady "
          "Created new nshttpconnection %p\n", conn.get()));
 
+    // Some capabilities are needed before a transaciton actually gets
+    // scheduled (e.g. how to negotiate false start)
+    conn->SetTransactionCaps(mTransaction->Caps());
+
     NetAddr peeraddr;
     nsCOMPtr<nsIInterfaceRequestor> callbacks;
     mTransaction->GetSecurityCallbacks(getter_AddRefs(callbacks));
     if (out == mStreamOut) {
         TimeDuration rtt = TimeStamp::Now() - mPrimarySynStarted;
         rv = conn->Init(mEnt->mConnInfo,
                         gHttpHandler->ConnMgr()->mMaxRequestDelay,
                         mSocketTransport, mStreamIn, mStreamOut,
diff --git a/netwerk/protocol/http/nsHttpConnectionMgr.h b/netwerk/protocol/http/nsHttpConnectionMgr.h
--- a/netwerk/protocol/http/nsHttpConnectionMgr.h
+++ b/netwerk/protocol/http/nsHttpConnectionMgr.h
@@ -108,17 +108,18 @@ public:
 
     // called to indicate a transaction for the connectionInfo is likely coming
     // soon. The connection manager may use this information to start a TCP
     // and/or SSL level handshake for that resource immediately so that it is
     // ready when the transaction is submitted. No obligation is taken on by the
     // connection manager, nor is the submitter obligated to actually submit a
     // real transaction for this connectionInfo.
     nsresult SpeculativeConnect(nsHttpConnectionInfo *,
-                                nsIInterfaceRequestor *);
+                                nsIInterfaceRequestor *,
+                                uint32_t caps = 0);
 
     // called when a connection is done processing a transaction.  if the
     // connection can be reused then it will be added to the idle list, else
     // it will be closed.
     nsresult ReclaimConnection(nsHttpConnection *conn);
 
     // called by the main thread to execute the taketransport() logic on the
     // socket thread after a 101 response has been received and the socket
diff --git a/netwerk/protocol/http/nsHttpHandler.h b/netwerk/protocol/http/nsHttpHandler.h
--- a/netwerk/protocol/http/nsHttpHandler.h
+++ b/netwerk/protocol/http/nsHttpHandler.h
@@ -176,19 +176,20 @@ public:
     }
 
     nsresult GetSocketThreadTarget(nsIEventTarget **target)
     {
         return mConnMgr->GetSocketThreadTarget(target);
     }
 
     nsresult SpeculativeConnect(nsHttpConnectionInfo *ci,
-                                nsIInterfaceRequestor *callbacks)
+                                nsIInterfaceRequestor *callbacks,
+                                uint32_t caps = 0)
     {
-        return mConnMgr->SpeculativeConnect(ci, callbacks);
+        return mConnMgr->SpeculativeConnect(ci, callbacks, caps);
     }
 
     //
     // The HTTP handler caches pointers to specific XPCOM services, and
     // provides the following helper routines for accessing those services:
     //
     nsresult GetStreamConverterService(nsIStreamConverterService **);
     nsresult GetIOService(nsIIOService** service);
diff --git a/netwerk/socket/nsISSLSocketControl.idl b/netwerk/socket/nsISSLSocketControl.idl
--- a/netwerk/socket/nsISSLSocketControl.idl
+++ b/netwerk/socket/nsISSLSocketControl.idl
@@ -9,17 +9,17 @@
 interface nsIInterfaceRequestor;
 
 %{C++
 #include "nsTArray.h"
 class nsCString;
 %}
 [ref] native nsCStringTArrayRef(nsTArray<nsCString>);
 
-[scriptable, uuid(bb2bb490-3ba4-4254-b8f5-8b43c7b714ea)]
+[scriptable, builtinclass, uuid(c5eb9af4-238c-4fc6-bdec-d5ab5e7dce68)]
 interface nsISSLSocketControl : nsISupports {
     attribute nsIInterfaceRequestor     notificationCallbacks;
 
     void proxyStartSSL();
     void StartTLS();
 
     /* NPN (Next Protocol Negotiation) is a mechanism for
        negotiating the protocol to be spoken inside the SSL
@@ -47,14 +47,30 @@ interface nsISSLSocketControl : nsISuppo
      * a desired NPN negotiated protocol of npnProtocol can use the socket
      * associated with this object instead of making a new one.
      */
     boolean joinConnection(
       in ACString npnProtocol, /* e.g. "spdy/2" */
       in ACString hostname,
       in long port);
 
+    /* The Key Exchange Algorithm and Symmetric Cipher
+       is used when determining whether or not to do false start.
+       After a handshake is complete it can be read from *Used,
+       before a handshake is started it may be set through *Expected.
+       The values correspond to the SSLKEAType and SSLCipherAlgorithm
+       enums in NSS or the *_UNKNOWN constant defined below.
+    */
+
+    [infallible] readonly attribute short KEAUsed;
+    [infallible] attribute short KEAExpected;
+    [infallible] readonly attribute short SymmetricCipherUsed;
+    [infallible] attribute short SymmetricCipherExpected;
+
+    const short KEY_EXCHANGE_UNKNOWN = -1;
+    const short SYMMETRIC_CIPHER_UNKNOWN = -1;
+
     /*
      * The original flags from the socket provider.
      */
     readonly attribute uint32_t providerFlags;
 };
 
diff --git a/security/manager/ssl/src/nsNSSCallbacks.cpp b/security/manager/ssl/src/nsNSSCallbacks.cpp
--- a/security/manager/ssl/src/nsNSSCallbacks.cpp
+++ b/security/manager/ssl/src/nsNSSCallbacks.cpp
@@ -819,31 +819,214 @@ PK11PasswordPrompt(PK11SlotInfo* slot, P
 {
   RefPtr<PK11PasswordPromptRunnable> runnable(
     new PK11PasswordPromptRunnable(slot,
                                    static_cast<nsIInterfaceRequestor*>(arg)));
   runnable->DispatchToMainThreadAndWait();
   return runnable->mResult;
 }
 
+// call with shutdown prevention lock held
+static void
+PreliminaryHandshakeDone(PRFileDesc* fd)
+{
+  nsNSSSocketInfo* infoObject = (nsNSSSocketInfo*) fd->higher->secret;
+  if (!infoObject)
+    return;
+
+  if (infoObject->IsPreliminaryHandshakeDone())
+    return;
+
+  infoObject->SetPreliminaryHandshakeDone();
+  infoObject->SetFirstServerHelloReceived();
+
+  // Get the NPN value.
+  SSLNextProtoState state;
+  unsigned char npnbuf[256];
+  unsigned int npnlen;
+
+  if (SSL_GetNextProto(fd, &state, npnbuf, &npnlen, 256) == SECSuccess) {
+    if (state == SSL_NEXT_PROTO_NEGOTIATED) {
+      infoObject->SetNegotiatedNPN(reinterpret_cast<char *>(npnbuf), npnlen);
+    }
+    else {
+      infoObject->SetNegotiatedNPN(nullptr, 0);
+    }
+    mozilla::Telemetry::Accumulate(Telemetry::SSL_NPN_TYPE, state);
+  }
+  else {
+    infoObject->SetNegotiatedNPN(nullptr, 0);
+  }
+}
+
+SECStatus
+CanFalseStartCallback(PRFileDesc* fd, void* client_data, PRBool *canFalseStart)
+{
+  *canFalseStart = false;
+
+  nsNSSShutDownPreventionLock locker;
+
+  nsNSSSocketInfo* infoObject = (nsNSSSocketInfo*) fd->higher->secret;
+  if (!infoObject) {
+    PR_SetError(PR_INVALID_STATE_ERROR, 0);
+    return SECFailure;
+  }
+
+  if (infoObject->isAlreadyShutDown()) {
+    MOZ_NOT_REACHED("SSL socket used after NSS shut down");
+    PR_SetError(PR_INVALID_STATE_ERROR, 0);
+    return SECFailure;
+  }
+
+  PreliminaryHandshakeDone(fd);
+
+  SSLChannelInfo channelInfo;
+  if (SSL_GetChannelInfo(fd, &channelInfo, sizeof(channelInfo)) != SECSuccess) {
+    return SECSuccess;
+  }
+
+  SSLCipherSuiteInfo cipherInfo;
+  if (SSL_GetCipherSuiteInfo(channelInfo.cipherSuite, &cipherInfo,
+                             sizeof (cipherInfo)) != SECSuccess) {
+    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
+                                      " KEA %d\n", fd,
+                                      static_cast<int32_t>(cipherInfo.keaType)));
+    return SECSuccess;
+  }
+
+  if (channelInfo.protocolVersion < SSL_LIBRARY_VERSION_TLS_1_0) {
+    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
+                                      "SSL Version must be >= TLS1 %x\n", fd,
+                                      static_cast<int32_t>(channelInfo.protocolVersion)));
+    return SECSuccess;
+  }
+
+  // never do false start without one of these key exchange algorithms
+  if (cipherInfo.keaType != ssl_kea_rsa &&
+      cipherInfo.keaType != ssl_kea_dh &&
+      cipherInfo.keaType != ssl_kea_ecdh) {
+    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
+                                      "unsupported KEA %d\n", fd,
+                                      static_cast<int32_t>(cipherInfo.keaType)));
+    return SECSuccess;
+  }
+
+  // never do false start without at least 80 bits of key material. This should
+  // be redundant to an NSS precondition
+  if (cipherInfo.effectiveKeyBits < 80) {
+    MOZ_NOT_REACHED("NSS is not enforcing the precondition that the effective "
+                    "key size must be >= 80 bits for false start");
+    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
+                                      "key too small %d\n", fd,
+                                      static_cast<int32_t>(cipherInfo.effectiveKeyBits)));
+    PR_SetError(PR_INVALID_STATE_ERROR, 0);
+    return SECFailure;
+  }
+
+  // XXX: An attacker can choose which protocols are advertised in the
+  // NPN extension. TODO(Bug 861311): We should restrict the ability
+  // of an attacker leverage this capability by restricting false start
+  // to the same protocol we previously saw for the server, after the
+  // first successful connection to the server.
+
+  // Enforce NPN to do false start if policy requires it. Do this as an
+  // indicator if server compatibility.
+  nsSSLIOLayerHelpers& helpers = infoObject->SharedState().IOLayerHelpers();
+  if (helpers.mFalseStartRequireNPN) {
+    nsAutoCString negotiatedNPN;
+    if (NS_FAILED(infoObject->GetNegotiatedNPN(negotiatedNPN)) ||
+        !negotiatedNPN.Length()) {
+      PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
+                                        "NPN cannot be verified\n", fd));
+      return SECSuccess;
+    }
+  }
+
+  // If we're not using eliptical curve kea then make sure we've seen the
+  // same kea from this host in the past, to limit the potential for downgrade
+  // attacks.
+  if (cipherInfo.keaType != ssl_kea_ecdh) {
+
+    if (helpers.mFalseStartRequireForwardSecrecy) {
+      PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
+                                        "KEA used is %d, but "
+                                        "require-forward-secrecy configured.\n",
+                                        fd, static_cast<int32_t>(cipherInfo.keaType)));
+      return SECSuccess;
+    }
+
+    int16_t expected = infoObject->GetKEAExpected();
+    if (cipherInfo.keaType != expected) {
+      PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
+                                        "KEA used is %d, expected %d\n", fd,
+                                        static_cast<int32_t>(cipherInfo.keaType),
+                                        static_cast<int32_t>(expected)));
+      return SECSuccess;
+    }
+
+    // whitelist the expected key exchange algorithms that are
+    // acceptable for false start when seen before.
+    if (expected != ssl_kea_rsa && expected != ssl_kea_dh &&
+        expected != ssl_kea_ecdh) {
+      PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
+                                        "KEA used, %d, "
+                                        "is not supported with False Start.\n",
+                                        fd, static_cast<int32_t>(expected)));
+      return SECSuccess;
+    }
+  }
+
+  // If we're not using AES then verify that this is the historically expected
+  // symmetrical cipher for this host, to limit potential for downgrade attacks.
+  if (cipherInfo.symCipher != ssl_calg_aes) {
+    int16_t expected = infoObject->GetSymmetricCipherExpected();
+    if (cipherInfo.symCipher != expected) {
+      PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
+                                        "Symmetric cipher used is %d, expected %d\n",
+                                        fd, static_cast<int32_t>(cipherInfo.symCipher),
+                                        static_cast<int32_t>(expected)));
+      return SECSuccess;
+    }
+
+    // whitelist the expected ciphers that are
+    // acceptable for false start when seen before.
+    if ((expected != ssl_calg_rc4) && (expected != ssl_calg_3des) &&
+        (expected != ssl_calg_aes)) {
+      PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] failed - "
+                                        "Symmetric cipher used, %d, "
+                                        "is not supported with False Start.\n",
+                                        fd, static_cast<int32_t>(expected)));
+      return SECSuccess;
+    }
+  }
+
+  infoObject->NoteTimeUntilReady();
+  *canFalseStart = true;
+  PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CanFalseStartCallback [%p] ok\n", fd));
+  return SECSuccess;
+}
+
 void HandshakeCallback(PRFileDesc* fd, void* client_data) {
   nsNSSShutDownPreventionLock locker;
   int32_t sslStatus;
   char* cipherName = nullptr;
   int32_t keyLength;
   int32_t encryptBits;
 
   nsNSSSocketInfo* infoObject = (nsNSSSocketInfo*) fd->higher->secret;
 
   // certificate validation sets FirstServerHelloReceived, so if that flag
-  // is absent at handshake time we have a resumed session.
+  // is absent at handshake time we have a resumed session. Check this before
+  // PreliminaryHandshakeDone() because that function also sets that flag.
   bool isResumedSession = !(infoObject->GetFirstServerHelloReceived());
 
-  // This is the first callback on resumption handshakes
-  infoObject->SetFirstServerHelloReceived();
+  // Do the bookkeeping that needs to be done after the
+  // server's ServerHello...ServerHelloDone have been processed, but that doesn't
+  // need the handshake to be completed.
+  PreliminaryHandshakeDone(fd);
 
   // If the handshake completed, then we know the site is TLS tolerant (if this
   // was a TLS connection).
   nsSSLIOLayerHelpers& ioLayerHelpers = infoObject->SharedState().IOLayerHelpers();
   ioLayerHelpers.rememberTolerantSite(infoObject);
 
   if (SECSuccess != SSL_SecurityStatus(fd, &sslStatus, &cipherName, &keyLength,
                                        &encryptBits, nullptr, nullptr)) {
@@ -925,47 +1108,35 @@ void HandshakeCallback(PRFileDesc* fd, v
     }
   }
 
   status->mHaveKeyLengthAndCipher = true;
   status->mKeyLength = keyLength;
   status->mSecretKeyLength = encryptBits;
   status->mCipherName.Assign(cipherName);
 
-  // Get the NPN value.
-  SSLNextProtoState state;
-  unsigned char npnbuf[256];
-  unsigned int npnlen;
-    
-  if (SSL_GetNextProto(fd, &state, npnbuf, &npnlen, 256) == SECSuccess) {
-    if (state == SSL_NEXT_PROTO_NEGOTIATED)
-      infoObject->SetNegotiatedNPN(reinterpret_cast<char *>(npnbuf), npnlen);
-    else
-      infoObject->SetNegotiatedNPN(nullptr, 0);
-    mozilla::Telemetry::Accumulate(Telemetry::SSL_NPN_TYPE, state);
-  }
-  else
-    infoObject->SetNegotiatedNPN(nullptr, 0);
-
   SSLChannelInfo channelInfo;
   if (SSL_GetChannelInfo(fd, &channelInfo, sizeof(channelInfo)) == SECSuccess) {
     // Get the protocol version for telemetry
     // 0=ssl3, 1=tls1, 2=tls1.1, 3=tls1.2
     unsigned int versionEnum = channelInfo.protocolVersion & 0xFF;
     Telemetry::Accumulate(Telemetry::SSL_HANDSHAKE_VERSION, versionEnum);
 
     SSLCipherSuiteInfo cipherInfo;
     if (SSL_GetCipherSuiteInfo(channelInfo.cipherSuite, &cipherInfo,
-                                sizeof (cipherInfo)) == SECSuccess) {
+                               sizeof (cipherInfo)) == SECSuccess) {
       // keyExchange null=0, rsa=1, dh=2, fortezza=3, ecdh=4
       Telemetry::Accumulate(Telemetry::SSL_KEY_EXCHANGE_ALGORITHM,
                             cipherInfo.keaType);
+      infoObject->SetKEAUsed(cipherInfo.keaType);
+      infoObject->SetSymmetricCipherUsed(cipherInfo.symCipher);
     }
-      
   }
+
+  infoObject->NoteTimeUntilReady();
   infoObject->SetHandshakeCompleted(isResumedSession);
 
   PORT_Free(cipherName);
 }
 
 struct OCSPDefaultResponders {
     const char *issuerName_string;
     CERTName *issuerName;
diff --git a/security/manager/ssl/src/nsNSSCallbacks.h b/security/manager/ssl/src/nsNSSCallbacks.h
--- a/security/manager/ssl/src/nsNSSCallbacks.h
+++ b/security/manager/ssl/src/nsNSSCallbacks.h
@@ -18,16 +18,18 @@
 #include "nsString.h"
 
 class nsILoadGroup;
 
 char*
 PK11PasswordPrompt(PK11SlotInfo *slot, PRBool retry, void* arg);
 
 void HandshakeCallback(PRFileDesc *fd, void *client_data);
+SECStatus CanFalseStartCallback(PRFileDesc* fd, void* client_data,
+                                PRBool *canFalseStart);
 
 SECStatus RegisterMyOCSPAIAInfoCallback();
 SECStatus UnregisterMyOCSPAIAInfoCallback();
 
 class nsHTTPListener MOZ_FINAL : public nsIStreamLoaderObserver
 {
 private:
   // For XPCOM implementations that are not a base class for some other
diff --git a/security/manager/ssl/src/nsNSSIOLayer.cpp b/security/manager/ssl/src/nsNSSIOLayer.cpp
--- a/security/manager/ssl/src/nsNSSIOLayer.cpp
+++ b/security/manager/ssl/src/nsNSSIOLayer.cpp
@@ -78,22 +78,28 @@ nsNSSSocketInfo::nsNSSSocketInfo(SharedS
     mForSTARTTLS(false),
     mSSL3Enabled(false),
     mTLSEnabled(false),
     mHandshakePending(true),
     mHasCleartextPhase(false),
     mHandshakeInProgress(false),
     mAllowTLSIntoleranceTimeout(true),
     mRememberClientAuthCertificate(false),
+    mPreliminaryHandshakeDone(false),
     mHandshakeStartTime(0),
     mFirstServerHelloReceived(false),
     mNPNCompleted(false),
     mHandshakeCompleted(false),
     mJoined(false),
     mSentClientCert(false),
+    mNotedTimeUntilReady(false),
+    mKEAUsed(nsISSLSocketControl::KEY_EXCHANGE_UNKNOWN),
+    mKEAExpected(nsISSLSocketControl::KEY_EXCHANGE_UNKNOWN),
+    mSymmetricCipherUsed(nsISSLSocketControl::SYMMETRIC_CIPHER_UNKNOWN),
+    mSymmetricCipherExpected(nsISSLSocketControl::SYMMETRIC_CIPHER_UNKNOWN),
     mProviderFlags(providerFlags),
     mSocketCreationTimestamp(TimeStamp::Now()),
     mPlaintextBytesRead(0)
 {
 }
 
 NS_IMPL_ISUPPORTS_INHERITED2(nsNSSSocketInfo, TransportSecurityInfo,
                              nsISSLSocketControl,
@@ -101,16 +107,58 @@ NS_IMPL_ISUPPORTS_INHERITED2(nsNSSSocket
 
 NS_IMETHODIMP
 nsNSSSocketInfo::GetProviderFlags(uint32_t* aProviderFlags)
 {
   *aProviderFlags = mProviderFlags;
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsNSSSocketInfo::GetKEAUsed(int16_t *aKea)
+{
+  *aKea = mKEAUsed;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNSSSocketInfo::GetKEAExpected(int16_t *aKea)
+{
+  *aKea = mKEAExpected;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNSSSocketInfo::SetKEAExpected(int16_t aKea)
+{
+  mKEAExpected = aKea;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNSSSocketInfo::GetSymmetricCipherUsed(int16_t *aSymmetricCipher)
+{
+  *aSymmetricCipher = mSymmetricCipherUsed;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNSSSocketInfo::GetSymmetricCipherExpected(int16_t *aSymmetricCipher)
+{
+  *aSymmetricCipher = mSymmetricCipherExpected;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsNSSSocketInfo::SetSymmetricCipherExpected(int16_t aSymmetricCipher)
+{
+  mSymmetricCipherExpected = aSymmetricCipher;
+  return NS_OK;
+}
+
 nsresult
 nsNSSSocketInfo::GetHandshakePending(bool *aHandshakePending)
 {
   *aHandshakePending = mHandshakePending;
   return NS_OK;
 }
 
 nsresult
@@ -193,21 +241,36 @@ getSecureBrowserUI(nsIInterfaceRequestor
     if (docShell) {
       (void) docShell->GetSecurityUI(result);
     }
   }
 }
 #endif
 
 void
+nsNSSSocketInfo::NoteTimeUntilReady()
+{
+  if (mNotedTimeUntilReady)
+    return;
+
+  mNotedTimeUntilReady = true;
+
+  // This will include TCP and proxy tunnel wait time
+  Telemetry::AccumulateTimeDelta(Telemetry::SSL_TIME_UNTIL_READY,
+                                 mSocketCreationTimestamp, TimeStamp::Now());
+  PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
+         ("[%p] nsNSSSocketInfo::NoteTimeUntilReady\n", mFd));
+}
+
+void
 nsNSSSocketInfo::SetHandshakeCompleted(bool aResumedSession)
 {
   if (!mHandshakeCompleted) {
     // This will include TCP and proxy tunnel wait time
-    Telemetry::AccumulateTimeDelta(Telemetry::SSL_TIME_UNTIL_READY,
+    Telemetry::AccumulateTimeDelta(Telemetry::SSL_TIME_UNTIL_HANDSHAKE_FINISHED,
                                    mSocketCreationTimestamp, TimeStamp::Now());
 
     // If the handshake is completed for the first time from just 1 callback
     // that means that TLS session resumption must have been used.
     Telemetry::Accumulate(Telemetry::SSL_RESUMED_SESSION, aResumedSession);
 
     // Remove the plain text layer as it is not needed anymore.
     // The plain text layer is not always present - so its not a fatal error
@@ -215,16 +278,19 @@ nsNSSSocketInfo::SetHandshakeCompleted(b
     PRFileDesc* poppedPlaintext =
       PR_GetIdentitiesLayer(mFd, nsSSLIOLayerHelpers::nsSSLPlaintextLayerIdentity);
     if (poppedPlaintext) {
       PR_PopIOLayer(mFd, nsSSLIOLayerHelpers::nsSSLPlaintextLayerIdentity);
       poppedPlaintext->dtor(poppedPlaintext);
     }
 
     mHandshakeCompleted = true;
+
+    PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
+           ("[%p] nsNSSSocketInfo::SetHandshakeCompleted\n", (void*)mFd));
   }
 }
 
 void
 nsNSSSocketInfo::SetNegotiatedNPN(const char *value, uint32_t length)
 {
   if (!value)
     mNegotiatedNPN.Truncate();
@@ -1090,16 +1156,18 @@ nsSSLIOLayerPoll(PRFileDesc * fd, int16_
 
 nsSSLIOLayerHelpers::nsSSLIOLayerHelpers()
 : mutex(nullptr)
 , mTLSIntolerantSites(nullptr)
 , mTLSTolerantSites(nullptr)
 , mRenegoUnrestrictedSites(nullptr)
 , mTreatUnsafeNegotiationAsBroken(false)
 , mWarnLevelMissingRFC5746(1)
+, mFalseStartRequireNPN(true)
+, mFalseStartRequireForwardSecrecy(false)
 {
 }
 
 static int _PSM_InvalidInt(void)
 {
     PR_ASSERT(!"I/O method is invalid");
     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
     return -1;
@@ -1280,16 +1348,22 @@ PrefObserver::Observe(nsISupports *aSubj
     } else if (prefName.Equals("security.ssl.treat_unsafe_negotiation_as_broken")) {
       bool enabled;
       Preferences::GetBool("security.ssl.treat_unsafe_negotiation_as_broken", &enabled);
       mOwner->setTreatUnsafeNegotiationAsBroken(enabled);
     } else if (prefName.Equals("security.ssl.warn_missing_rfc5746")) {
       int32_t warnLevel = 1;
       Preferences::GetInt("security.ssl.warn_missing_rfc5746", &warnLevel);
       mOwner->setWarnLevelMissingRFC5746(warnLevel);
+    } else if (prefName.Equals("security.ssl.false_start.require-npn")) {
+      Preferences::GetBool("security.ssl.false_start.require-npn",
+                           &mOwner->mFalseStartRequireNPN);
+    } else if (prefName.Equals("security.ssl.false_start.require-forward-secrecy")) {
+      Preferences::GetBool("security.ssl.false_start.require-forward-secrecy",
+                           &mOwner->mFalseStartRequireForwardSecrecy);
     }
   }
   return NS_OK;
 }
 
 static int32_t PlaintextRecv(PRFileDesc *fd, void *buf, int32_t amount,
                              int flags, PRIntervalTime timeout)
 {
@@ -1307,16 +1381,18 @@ static int32_t PlaintextRecv(PRFileDesc 
   return bytesRead;
 }
 
 nsSSLIOLayerHelpers::~nsSSLIOLayerHelpers()
 {
   Preferences::RemoveObserver(mPrefObserver, "security.ssl.renego_unrestricted_hosts");
   Preferences::RemoveObserver(mPrefObserver, "security.ssl.treat_unsafe_negotiation_as_broken");
   Preferences::RemoveObserver(mPrefObserver, "security.ssl.warn_missing_rfc5746");
+  Preferences::RemoveObserver(mPrefObserver, "security.ssl.false_start.require-npn");
+  Preferences::RemoveObserver(mPrefObserver, "security.ssl.false_start.require-forward-secrecy");
 }
 
 nsresult nsSSLIOLayerHelpers::Init()
 {
   if (!nsSSLIOLayerInitialized) {
     nsSSLIOLayerInitialized = true;
     nsSSLIOLayerIdentity = PR_GetUniqueIdentity("NSS layer");
     nsSSLIOLayerMethods  = *PR_GetDefaultIOMethods();
@@ -1381,24 +1457,32 @@ nsresult nsSSLIOLayerHelpers::Init()
   bool enabled = false;
   Preferences::GetBool("security.ssl.treat_unsafe_negotiation_as_broken", &enabled);
   setTreatUnsafeNegotiationAsBroken(enabled);
 
   int32_t warnLevel = 1;
   Preferences::GetInt("security.ssl.warn_missing_rfc5746", &warnLevel);
   setWarnLevelMissingRFC5746(warnLevel);
 
+  Preferences::GetBool("security.ssl.false_start.require-npn",
+                       &mFalseStartRequireNPN);
+  Preferences::GetBool("security.ssl.false_start.require-forward-secrecy",
+                       &mFalseStartRequireForwardSecrecy);
+
   mPrefObserver = new PrefObserver(this);
   Preferences::AddStrongObserver(mPrefObserver,
                                  "security.ssl.renego_unrestricted_hosts");
   Preferences::AddStrongObserver(mPrefObserver,
                                  "security.ssl.treat_unsafe_negotiation_as_broken");
   Preferences::AddStrongObserver(mPrefObserver,
                                  "security.ssl.warn_missing_rfc5746");
-
+  Preferences::AddStrongObserver(mPrefObserver,
+                                 "security.ssl.false_start.require-npn");
+  Preferences::AddStrongObserver(mPrefObserver,
+                                 "security.ssl.false_start.require-forward-secrecy");
   return NS_OK;
 }
 
 void nsSSLIOLayerHelpers::clearStoredData()
 {
   mRenegoUnrestrictedSites->Clear();
   mTLSTolerantSites->Clear();
   mTLSIntolerantSites->Clear();
@@ -2474,16 +2558,17 @@ nsSSLIOLayerImportFD(PRFileDesc *fd,
   nsNSSShutDownPreventionLock locker;
   PRFileDesc* sslSock = SSL_ImportFD(nullptr, fd);
   if (!sslSock) {
     NS_ASSERTION(false, "NSS: Error importing socket");
     return nullptr;
   }
   SSL_SetPKCS11PinArg(sslSock, (nsIInterfaceRequestor*)infoObject);
   SSL_HandshakeCallback(sslSock, HandshakeCallback, infoObject);
+  SSL_SetCanFalseStartCallback(sslSock, CanFalseStartCallback, infoObject);
 
   // Disable this hook if we connect anonymously. See bug 466080.
   uint32_t flags = 0;
   infoObject->GetProviderFlags(&flags);
   if (flags & nsISocketProvider::ANONYMOUS_CONNECT) {
       SSL_GetClientAuthDataHook(sslSock, nullptr, infoObject);
   } else {
       SSL_GetClientAuthDataHook(sslSock, 
diff --git a/security/manager/ssl/src/nsNSSIOLayer.h b/security/manager/ssl/src/nsNSSIOLayer.h
--- a/security/manager/ssl/src/nsNSSIOLayer.h
+++ b/security/manager/ssl/src/nsNSSIOLayer.h
@@ -56,16 +56,17 @@ public:
 
   void SetAllowTLSIntoleranceTimeout(bool aAllow);
 
   PRStatus CloseSocketAndDestroy(
                 const nsNSSShutDownPreventionLock & proofOfLock);
   
   void SetNegotiatedNPN(const char *value, uint32_t length);
   void SetHandshakeCompleted(bool aResumedSession);
+  void NoteTimeUntilReady();
 
   bool GetJoined() { return mJoined; }
   void SetSentClientCert() { mSentClientCert = true; }
 
   uint32_t GetProviderFlags() const { return mProviderFlags; }
 
   mozilla::psm::SharedSSLState& SharedState();
 
@@ -88,40 +89,73 @@ public:
   }
 
   bool IsSSL3Enabled() const { return mSSL3Enabled; }
   void SetSSL3Enabled(bool enabled) { mSSL3Enabled = enabled; }
   bool IsTLSEnabled() const { return mTLSEnabled; }
   void SetTLSEnabled(bool enabled) { mTLSEnabled = enabled; }
 
   void AddPlaintextBytesRead(uint64_t val) { mPlaintextBytesRead += val; }
+
+  bool IsPreliminaryHandshakeDone() const { return mPreliminaryHandshakeDone; }
+  void SetPreliminaryHandshakeDone() { mPreliminaryHandshakeDone = true; }
+
+  void SetKEAUsed(PRUint16 kea) { mKEAUsed = kea; }
+  inline int16_t GetKEAExpected() // infallible in nsISSLSocketControl
+  {
+    int16_t result;
+    mozilla::DebugOnly<nsresult> rv = GetKEAExpected(&result);
+    MOZ_ASSERT(NS_SUCCEEDED(rv));
+    return result;
+  }
+  void SetSymmetricCipherUsed(PRUint16 symmetricCipher)
+  {
+    mSymmetricCipherUsed = symmetricCipher;
+  }
+  inline int16_t GetSymmetricCipherExpected() // infallible in nsISSLSocketControl
+  {
+    int16_t result;
+    mozilla::DebugOnly<nsresult> rv = GetSymmetricCipherExpected(&result);
+    MOZ_ASSERT(NS_SUCCEEDED(rv));
+    return result;
+  }
+
 private:
   PRFileDesc* mFd;
 
   CertVerificationState mCertVerificationState;
 
   mozilla::psm::SharedSSLState& mSharedState;
   bool mForSTARTTLS;
   bool mSSL3Enabled;
   bool mTLSEnabled;
   bool mHandshakePending;
   bool mHasCleartextPhase;
   bool mHandshakeInProgress;
   bool mAllowTLSIntoleranceTimeout;
   bool mRememberClientAuthCertificate;
+  bool mPreliminaryHandshakeDone; // after false start items are complete
   PRIntervalTime mHandshakeStartTime;
   bool mFirstServerHelloReceived;
 
   nsresult ActivateSSL();
 
   nsCString mNegotiatedNPN;
   bool      mNPNCompleted;
   bool      mHandshakeCompleted;
   bool      mJoined;
   bool      mSentClientCert;
+  bool      mNotedTimeUntilReady;
+
+  // mKEA* and mSymmetricCipher* are used in false start detetermination
+  // values are from nsISSLSocketControl
+  PRInt16 mKEAUsed;
+  PRInt16 mKEAExpected;
+  PRInt16 mSymmetricCipherUsed;
+  PRInt16 mSymmetricCipherExpected;
 
   uint32_t mProviderFlags;
   mozilla::TimeStamp mSocketCreationTimestamp;
   uint64_t mPlaintextBytesRead;
 };
 
 class nsSSLIOLayerHelpers
 {
@@ -159,16 +193,19 @@ public:
   void addIntolerantSite(const nsCString &str);
   void removeIntolerantSite(const nsCString &str);
   bool isKnownAsIntolerantSite(const nsCString &str);
 
   void setRenegoUnrestrictedSites(const nsCString &str);
   bool isRenegoUnrestrictedSite(const nsCString &str);
 
   void clearStoredData();
+
+  bool mFalseStartRequireNPN;
+  bool mFalseStartRequireForwardSecrecy;
 private:
   nsCOMPtr<nsIObserver> mPrefObserver;
 };
 
 nsresult nsSSLIOLayerNewSocket(int32_t family,
                                const char *host,
                                int32_t port,
                                const char *proxyHost,
diff --git a/toolkit/components/telemetry/Histograms.json b/toolkit/components/telemetry/Histograms.json
--- a/toolkit/components/telemetry/Histograms.json
+++ b/toolkit/components/telemetry/Histograms.json
@@ -838,16 +838,22 @@
   },
   "SSL_TIME_UNTIL_READY": {
     "kind": "exponential",
     "high": "60000",
     "n_buckets": 200,
     "extended_statistics_ok": true,
     "description": "ms of SSL wait time including TCP and proxy tunneling"
   },
+  "SSL_TIME_UNTIL_HANDSHAKE_FINISHED": {
+    "kind": "exponential",
+    "high": "60000",
+    "n_buckets": 200,
+    "description": "ms of SSL wait time for full handshake including TCP and proxy tunneling"
+  },
   "SSL_BYTES_BEFORE_CERT_CALLBACK": {
     "kind": "exponential",
     "high": "32000",
     "n_buckets": 64,
     "extended_statistics_ok": true,
     "description": "plaintext bytes read before a server certificate authenticated"
   },
   "SSL_NPN_TYPE": {
