<html>
  <head>
    <title>Automated RTL/LTR Text Selection tests for Input elements</title>
    <meta name="viewport" content="initial-scale=1.0"/>
    <script type="application/javascript"
      src="chrome://mochikit/content/tests/SimpleTest/EventUtils.js"></script>
    <script type="application/javascript">

// Used to create handle movement events for SelectionHandler.
const ANCHOR = "ANCHOR";
const FOCUS = "FOCUS";

// Types of DOM nodes that serve as Selection Anchor/Focus nodes.
const DIV_NODE = "DIV";
const TEXT_NODE = "#text";

// Used to create test scenarios, and verify results.
const LTR_INPUT_TEXT_VALUE = "This input text is one character short of it's maxmimum.";
const RTL_INPUT_TEXT_VALUE = "טקסט קלט זה קצר תו אחד של זה גדול.";


const { classes: Cc, interfaces: Ci, results: Cr, utils: Cu } = Components;
Cu.import("resource://gre/modules/Messaging.jsm");
Cu.import("resource://gre/modules/Services.jsm");
Cu.import('resource://gre/modules/Geometry.jsm');

/* =================================================================================
 *
 * Start of all text selection tests, check initialization state.
 */
function startTests() {
  testLTR_selectAll().
    then(testRTL_selectAll).

    then(finishTests, function(err) {
      ok(false, "Error in selection test " + err);
      finishTests();
    });
}

/* =================================================================================
 *
 * LTR selectAll() test selects the entire single-line <input> element and ensures:
 *    ) The Selection exists.
 *    ) The Selection text matches an expected value.
 *
 *    ) Assumptions about the DOM Selection Anchor node are correct.
 *    ) Assumptions about the DOM Selection Focus node are correct.
 *
 *    ) The UI Selection anchor handle is aligned vertically with the focus handle.
 *    ) The UI Selection anchor handle is left of the focus handle.
 */
function testLTR_selectAll() {
  // Select entire LTR Input element.
  var sh = getSelectionHandler();
  var element = document.getElementById("LTRInput");
  element.value = LTR_INPUT_TEXT_VALUE;
  sh.startSelection(element);

  var selection = sh._getSelection();

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var anchorPt = new Point(sh._cache.anchorPt.x, sh._cache.anchorPt.y);
  var focusPt = new Point(sh._cache.focusPt.x, sh._cache.focusPt.y);

  return Promise.all([
    ok(sh.isSelectionActive(),
      "testLTR_selectAll starts, selection should be active."),
    is(sh._targetElement, element,
      "LTR SelectionHandler reference is the node we provided."),
    is(sh._getSelectedText(), LTR_INPUT_TEXT_VALUE,
      "LTR Selection text should match expected value."),

    isNot(anchorNode, element,
      "LTR Selection Anchor isn't the LTRInput node."),
    is(anchorNode.nodeName, DIV_NODE, "LTR Anchor node is a DIV node."),
    ok(!document.contains(anchorNode), "LTR Anchor node is an anonymous DIV node."),
    is(anchorNode.parentNode, element, "LTR Anchor node is a child of the LTRInput node."),
    is(anchorOffset, 0,
      "LTR Selection starts at Anchor node with offset 0."),

    isNot(focusNode, element,
      "LTR Selection Focus isn't the LTRInput node."),
    is(focusNode.nodeName, TEXT_NODE, "LTR Focus node is a TEXT node."),
    ok(!document.contains(focusNode), "LTR Focus node is an anonymous TEXT node."),
    is(focusNode.parentNode, anchorNode, "LTR Focus node is a child of the Anchor DIV node."),
    is(focusOffset, LTR_INPUT_TEXT_VALUE.length,
      "LTR Selection ends at Focus node with offset of the LTRInput node length."),

    is(anchorPt.y, focusPt.y,
      "LTR UI Selection anchor should match focus vertically."),
    lessThan(anchorPt.x, focusPt.x,
      "LTR UI Selection anchor should be to the left of focus."),

  ]).then(function() {
    // Close selection and complete test.
    sh.observe(null, "TextSelection:End", {});

    return Promise.all([
      ok(!sh.isSelectionActive(),
        "testLTR_selectAll finishes, selection should not be active."),
    ]);
  });
}

/* =================================================================================
 *
 * RTL selectAll() test selects the entire single-line <input> element and ensures:
 *    ) The Selection exists.
 *    ) The Selection text matches an expected value.
 *
 *    ) Assumptions about the DOM Selection Anchor node are correct.
 *    ) Assumptions about the DOM Selection Focus node are correct.
 *
 *    ) The UI Selection anchor handle is aligned vertically with the focus handle.
 *    ) The UI Selection anchor handle is right of the focus handle.
 */
function testRTL_selectAll() {
  // Select entire RTL Input element.
  var sh = getSelectionHandler();
  var element = document.getElementById("RTLInput");
  element.value = RTL_INPUT_TEXT_VALUE;
  sh.startSelection(element);

  var selection = sh._getSelection();

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var anchorPt = new Point(sh._cache.anchorPt.x, sh._cache.anchorPt.y);
  var focusPt = new Point(sh._cache.focusPt.x, sh._cache.focusPt.y);

  return Promise.all([
    ok(sh.isSelectionActive(),
      "testRTL_selectAll starts, selection should be active."),
    is(sh._targetElement, element,
      "RTL SelectionHandler reference is the node we provided."),
    is(sh._getSelectedText(), RTL_INPUT_TEXT_VALUE,
      "RTL Selection text should match expected value."),

    isNot(anchorNode, element,
      "RTL Selection Anchor isn't the RTLInput node."),
    is(anchorNode.nodeName, DIV_NODE, "RTL Anchor node is a DIV node."),
    ok(!document.contains(anchorNode), "RTL Anchor node is an anonymous DIV node."),
    is(anchorNode.parentNode, element, "RTL Anchor node is a child of the RTLInput node."),
    is(anchorOffset, 0,
      "RTL Selection starts at Anchor node with offset 0."),

    isNot(focusNode, element,
      "RTL Selection Focus isn't the RTLInput node."),
    is(focusNode.nodeName, TEXT_NODE, "RTL Focus node is a TEXT node."),
    ok(!document.contains(focusNode), "RTL Focus node is an anonymous TEXT node."),
    is(focusNode.parentNode, anchorNode, "RTL Focus node is a child of the Anchor DIV node."),
    is(focusOffset, RTL_INPUT_TEXT_VALUE.length,
      "RTL Selection ends at Focus node with offset of the RTLInput node length."),

    is(anchorPt.y, focusPt.y,
      "RTL UI Selection anchor should match focus vertically."),
    greaterThan(anchorPt.x, focusPt.x,
      "RTL UI Selection anchor should be to the right of focus."),

  ]).then(function() {
    // Close selection and complete test.
    sh.observe(null, "TextSelection:End", {});

    return Promise.all([
      ok(!sh.isSelectionActive(),
        "testRTL_selectAll finishes, selection should not be active."),
    ]);
  });
}

/* =================================================================================
 *
 * After finish of all selection tests, wrap up and go home.
 *
 */
function finishTests() {
  Messaging.sendRequest({
    type: "Robocop:testInputSelections",
    result: true,
    msg: "Done!",
    done: true
  });
}

/* ============================== Utility functions ======================
 *
 * Common functions available to all tests.
 *
 */
function getSelectionHandler() {
  return (!this._selectionHandler) ?
    this._selectionHandler = Services.wm.getMostRecentWindow("navigator:browser").SelectionHandler :
    this._selectionHandler;
}

function todo(result, msg) {
  return Messaging.sendRequestForResult({
    type: "Robocop:testInputSelections",
    todo: result,
    msg: msg
  });
}

function ok(result, msg) {
  return Messaging.sendRequestForResult({
    type: "Robocop:testInputSelections",
    result: result,
    msg: msg
  });
}

function is(one, two, msg) {
  return Messaging.sendRequestForResult({
    type: "Robocop:testInputSelections",
    result: one === two,
    msg: msg + " : " + one + " === " + two
  });
}

function isNot(one, two, msg) {
  return Messaging.sendRequestForResult({
    type: "Robocop:testInputSelections",
    result: one !== two,
    msg: msg + " : " + one + " !== " + two
  });
}

function lessThan(n1, n2, msg) {
  return Messaging.sendRequestForResult({
    type: "Robocop:testInputSelections",
    result: n1 < n2,
    msg: msg + " : " + n1 + " < " + n2
  });
}

function greaterThan(n1, n2, msg) {
  return Messaging.sendRequestForResult({
    type: "Robocop:testInputSelections",
    result: n1 > n2,
    msg: msg + " : " + n1 + " > " + n2
  });
}

function pointEquals(p1, p2, msg) {
  return Messaging.sendRequestForResult({
    type: "Robocop:testInputSelections",
    result: p1.equals(p2),
    msg: msg + " : " + p1.toString() + " == " + p2.toString()
  });
}

function pointNotEquals(p1, p2, msg) {
  return Messaging.sendRequestForResult({
    type: "Robocop:testInputSelections",
    result: !p1.equals(p2),
    msg: msg + " : " + p1.toString() + " == " + p2.toString()
  });
}

function selectionExists(selection, msg) {
  return Messaging.sendRequestForResult({
    type: "Robocop:testInputSelections",
    result: !selection.anchorPt.equals(selection.focusPt),
    msg: msg + " : anchor:" + selection.anchorPt.toString() +
      " focus:" + selection.focusPt.toString()
  });
}

/* =================================================================================
 *
 * Page definition for all tests.
 *
 */
    </script>
  </head>

  <body onload="startTests();">
    <input id="LTRInput" dir="ltr" type="text" maxlength="57" size="57" value="">
    <br>
    <input id="RTLInput" dir="rtl" type="text" maxlength="35" size="35" value="">
  </body>

</html>
