<!DOCTYPE HTML>
<html>

















<head>
  <meta charset="utf-8">
  <title>Test for css3-animations running on the compositor thread (Bug
         964646)</title>
  <script type="application/javascript"
    src="/tests/SimpleTest/SimpleTest.js"></script>
  <script type="application/javascript"
    src="/tests/SimpleTest/paint_listener.js"></script>
  <script type="application/javascript" src="animation_utils.js"></script>
  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
  <style type="text/css">
    @keyframes transform-anim {
      to {
        transform: translate(100px);
      }
    }
    @keyframes anim1 {
       0% { transform: translate(0px) }
       50% { transform: translate(80px) }
       100% { transform: translate(100px) }
    }
    .target {
      /* The animation target needs geometry in order to qualify for OMTA */
      width: 100px;
      height: 100px;
      background-color: white;
    }
  </style>
</head>
<body>
<a target="_blank"
  href="https://bugzilla.mozilla.org/show_bug.cgi?id=964646">Mozilla Bug
  964646</a>
<div id="display"></div>
<pre id="test">
<script type="application/javascript">
"use strict";

/** Test for css3-animations running on the compositor thread (Bug 964646) **/
 
// Global state
var gAsyncTests     = [],
    gDisplay        = document.getElementById("display"),
    gDiv            = null,
    gEventsReceived = [];

SimpleTest.waitForExplicitFinish();
runOMTATest(function() {
  // The async test runner returns a Promise that is resolved when the
  // test is finished so we can chain them together
  gAsyncTests.reduce(function(sequence, test) {
    return sequence.then(function() { return runAsyncTest(test); });
  }, Promise.resolve() /* the start of the sequence */)
  // Final step in the sequence
  .then(function() {
    SimpleTest.finish();
  });
}, SimpleTest.finish);

// Takes a generator function that represents a test case. Each point in the
// test case that waits asynchronously for some result yields a Promise that is
// resolved when the asychronous action has completed. By chaining these
// intermediate results together we run the test to completion.
//
// This method itself returns a Promise that is resolved when the generator
// function has completed.
//
// This arrangement is based on add_task() which is currently only available
// in mochitest-chrome (bug 872229). Once add_task is available in
// mochitest-plain we can remove this function and use add_task instead.
function runAsyncTest(test) {
  var generator;

  function step(arg) {
    var next;
    try {
      next = generator.next(arg);
    } catch (e) {
      return Promise.reject(e);
    }
    if (next.done) {
      return Promise.resolve(next.value);
    } else {
      return Promise.resolve(next.value)
             .then(step, function(err) { throw err; });
    }
  }

  // Put refresh driver under test control
  advance_clock(0);

  // Run test
  generator = test();
  return step()
  .catch(function(err) {
    ok(false, err.message);
    // Clear up the test div in case we aborted the test before doing clean-up
    if (gDiv) {
      done_div();
    }
  }).then(function() {
    // Restore clock
    SpecialPowers.DOMWindowUtils.restoreNormalRefresh();
  });
}

function addAsyncTest(generator) {
  gAsyncTests.push(generator);
}

//----------------------------------------------------------------------
//
// Test cases
//
//----------------------------------------------------------------------

// This test is not in test_animations.html but is here to test that
// transform animations are actually run on the compositor thread as expected.
addAsyncTest(function *() {
  new_div("animation: transform-anim linear 300s");

  yield waitForPaints();

  advance_clock(200000);
  compareTransform(gDiv, { tx: 100 * 2 / 3 }, RunningOn.Compositor,
                   "OMTA animation is animating as expected");
  done_div();
});

function *testFillMode(fillMode, fillsBackwards, fillsForwards)
{
  var style = "transform: translate(30px); animation: 10s 3s anim1 linear";
  var desc;
  if (fillMode.length > 0) {
    style += " " + fillMode;
    desc = "fill mode " + fillMode + ": ";
  } else {
    desc = "default fill mode: ";
  }
  new_div(style);
  listen();

  // Currently backwards fill is not performed on the compositor thread but we
  // should wait for paints so we can test that transform values are *not* being
  // set on the compositor thread.
  yield waitForPaints();

  if (fillsBackwards)
    compareTransform(gDiv, { tx: 0 }, RunningOn.MainThread,
                     desc + "does affect value during delay (0s)");
  else
    compareTransform(gDiv, { tx: 30 }, RunningOn.MainThread,
                     desc + "doesn't affect value during delay (0s)");

  advance_clock(2000);
  if (fillsBackwards)
    compareTransform(gDiv, { tx: 0 }, RunningOn.MainThead,
                     desc + "does affect value during delay (0s)");
  else
    compareTransform(gDiv, { tx: 30 }, RunningOn.MainThread,
                     desc + "does affect value during delay (0s)");

  check_events([], "before start in testFillMode");
  advance_clock(1000);
  check_events([{ type: "animationstart", target: gDiv,
                  bubbles: true, cancelable: false,
                  animationName: "anim1", elapsedTime: 0.0,
                  pseudoElement: "" }],
               "right after start in testFillMode");

  // If we have a backwards fill then at the start of the animation we will end
  // up applying the same value as the fill value. Various optimizations in
  // RestyleManager may filter out this meaning that the animation doesn't get
  // added to the compositor thread until the first time the value changes.
  //
  // As a result we look for this first sample on either the compositor or the
  // computed style
  yield waitForPaints();
  compareTransform(gDiv, { tx: 0 }, RunningOn.Either,
                   desc + "affects value at start of animation");
  advance_clock(125);
  // We might not add the animation to compositor until the second sample (due
  // to the optimizations mentioned above) so we should wait for paints before
  // proceeding
  yield waitForPaints();
  compareTransform(gDiv, { tx: 2 }, RunningOn.Compositor,
                   desc + "affects value during animation");
  advance_clock(2375);
  compareTransform(gDiv, { tx: 40 }, RunningOn.Compositor,
                   desc + "affects value during animation");
  advance_clock(2500);
  compareTransform(gDiv, { tx: 80 }, RunningOn.Compositor,
                   desc + "affects value during animation");
  advance_clock(2500);
  compareTransform(gDiv, { tx: 90 }, RunningOn.Compositor,
                   desc + "affects value during animation");
  advance_clock(2375);
  compareTransform(gDiv, { tx: 99.5 }, RunningOn.Compositor,
                   desc + "affects value during animation");
  check_events([], "before end in testFillMode");
  advance_clock(125);
  check_events([{ type: "animationend", target: gDiv,
                  bubbles: true, cancelable: false,
                  animationName: "anim1", elapsedTime: 10.0,
                  pseudoElement: "" }],
               "right after end in testFillMode");
  
  // Currently the compositor will apply a forwards fill until it gets told by
  // the main thread to clear the animation. As a result we should wait for
  // paints to be flushed before checking that the animated value does *not*
  // appear on the compositor thread.
  yield waitForPaints();
  if (fillsForwards)
    compareTransform(gDiv, { tx: 100 }, RunningOn.MainThread,
                     desc + "affects value at end of animation");
  advance_clock(10);
  if (fillsForwards)
    compareTransform(gDiv, { tx: 100 }, RunningOn.MainThread,
                     desc + "affects value after animation");
  else
    compareTransform(gDiv, { tx: 30 }, RunningOn.MainThread,
                     desc + "does not affect value after animation");

  done_div();
}

addAsyncTest(function() { return testFillMode("", false, false); });
addAsyncTest(function() { return testFillMode("none", false, false); });
addAsyncTest(function() { return testFillMode("forwards", false, true); });
addAsyncTest(function() { return testFillMode("backwards", true, false); });
addAsyncTest(function() { return testFillMode("both", true, true); });

//----------------------------------------------------------------------
//
// Helper functions from test_animations.html
//
//----------------------------------------------------------------------

function new_div(style) {
  if (gDiv !== null) {
    ok(false, "test author forgot to call done_div");
  }
  if (typeof(style) != "string") {
    ok(false, "test author forgot to pass style argument");
  }
  gDiv = document.createElement("div");
  gDiv.classList.add("target");
  gDiv.setAttribute("style", style);
  gDisplay.appendChild(gDiv);
  gDiv.clientTop;
}

function done_div() {
  if (gDiv === null) {
    ok(false, "test author forgot to call new_div");
  }
  gDisplay.removeChild(gDiv);
  gDiv = null;
}

function listen() {
  gEventsReceived = [];
  function listener(event) {
    gEventsReceived.push(event);
  }
  gDiv.addEventListener("animationstart", listener, false);
  gDiv.addEventListener("animationiteration", listener, false);
  gDiv.addEventListener("animationend", listener, false);
}

function check_events(events_expected, desc) {
  // This function checks that the list of events_expected matches
  // the received events -- but it only checks the properties that
  // are present on events_expected.
  is(gEventsReceived.length, events_expected.length,
     "number of events received for " + desc);
  for (var i = 0,
       i_end = Math.min(events_expected.length, gEventsReceived.length);
       i != i_end; ++i) {
    var exp = events_expected[i];
    var rec = gEventsReceived[i];
    for (var prop in exp) {
      if (prop == "elapsedTime") {
        // Allow floating point error.
        ok(Math.abs(rec.elapsedTime - exp.elapsedTime) < 0.000002,
           "events[" + i + "]." + prop + " for " + desc +
           " received=" + rec.elapsedTime + " expected=" + exp.elapsedTime);
      } else {
        is(rec[prop], exp[prop], "events[" + i + "]." + prop + " for " + desc);
      }
    }
  }
  for (i = events_expected.length; i < gEventsReceived.length; ++i) {
    ok(false, "unexpected " + gEventsReceived[i].type + " event for " + desc);
  }
  gEventsReceived = [];
}

function advance_clock(milliseconds) {
  SpecialPowers.DOMWindowUtils.advanceTimeAndRefresh(milliseconds);
}

//----------------------------------------------------------------------
//
// Helper functions for querying the compositor thread
//
//----------------------------------------------------------------------

// Returns a Promise that resolves once all paints have completed
function waitForPaints() {
  return new Promise(function(resolve, reject) {
    waitForAllPaints(resolve);
  });
}

//----------------------------------------------------------------------
//
// Helper functions for working with transform values
//
//----------------------------------------------------------------------

const RunningOn = {
  MainThread: 0,
  Compositor: 1,
  Either: 2
};

function compareTransform(elem, expected, runningOn, desc) {
  // Get actual values
  var compositorTransform =
    SpecialPowers.DOMWindowUtils.getOMTAStyle(elem, "transform");
  var computedTransform = window.getComputedStyle(elem).transform;

  // Prepare expected value
  var expectedMatrix = convertTo3dMatrix(expected);
  if (!expectedMatrix) {
    ok(false, desc + ": test author should provide a valid 'expected' value" +
              " - got " + expected.toString());
    return;
  }

  // Check expected value appears in the right place
  var actualTransform;
  switch (runningOn) {
    case RunningOn.Either:
      runningOn = compositorTransform ?
                  RunningOn.Compositor :
                  RunningOn.MainThread;
      actualTransform = compositorTransform || computedTransform;
      break;

    case RunningOn.Compositor:
      if (!compositorTransform) {
        ok(false, desc + ": should be animating on compositor");
        return;
      }
      actualTransform = compositorTransform;
      break;

    default:
      if (compositorTransform) {
        ok(false, desc + ": should NOT be animating on compositor");
        return;
      }
      actualTransform = computedTransform;
      break;
  }

  // Compare animated matrix with expected
  var actualMatrix = convertTo3dMatrix(actualTransform);
  if (!actualMatrix) {
    ok(false, desc + ": should return a valid transform spec"
       + " - got " + actualTransform);
    return;
  }
  ok(matricesRoughlyEqual(expectedMatrix, actualMatrix),
     desc + " - got " + actualTransform + ", expected " +
     convert3dMatrixToString(expectedMatrix));

  // For compositor animations do an additional check that they roughly match
  // the value calculated on the main thread
  if (runningOn === RunningOn.Compositor) {
    var computedMatrix = convertTo3dMatrix(computedTransform);
    if (!computedMatrix) {
      ok(false, desc + ": test framework should parse computed style" +
                " - got " + computedTransform);
      return;
    }
    ok(matricesRoughlyEqual(computedMatrix, actualMatrix),
       desc + ": OMTA style and computed style should be roughly equal" +
       " - OMTA " + actualTransform + ", computed " + computedTransform);
  }
}

function matricesRoughlyEqual(a, b) {
  const epsilon = 0.0001;
  for (var i = 0; i < 4; i++) {
    for (var j = 0; j < 4; j++) {
      if (Math.abs(a[i][j] - b[i][j]) > epsilon)
        return false;
    }
  }
  return true;
}

// Converts something representing an transform into a 3d matrix in column-major
// order.
// The following are supported:
//  "matrix(...)"
//  "matrix3d(...)"
//  [ 1, 0, 0, ... ]
//  { a: 1, ty: 23 } etc.
function convertTo3dMatrix(matrixLike) {
  if (typeof(matrixLike) == "string") {
    return convertStringTo3dMatrix(matrixLike);
  } else if (Array.isArray(matrixLike)) {
    return convertArrayTo3dMatrix(matrixLike);
  } else if (typeof(matrixLike) == "object") {
    return convertObjectTo3dMatrix(matrixLike);
  } else {
    return null;
  }
}

// Converts strings of the format "matrix(...)" and "matrix3d(...)" to a 3d
// matrix
function convertStringTo3dMatrix(str) {
  var result = str.match("^matrix(3d)?\\(");
  if (result === null)
    return null;

  return convertArrayTo3dMatrix(
      str.substring(result[0].length, str.length-1)
         .split(",")
         .map(function(component) {
           return Number(component);
         })
    );
}

// Takes an array of numbers of length 6 (2d matrix) or 16 (3d matrix)
// representing a matrix specified in column-major order and returns a 3d matrix
// represented as an array of arrays
function convertArrayTo3dMatrix(array) {
  if (array.length == 6) {
    return convertObjectTo3dMatrix(
      { a: array[0], b: array[1],
        c: array[2], d: array[3],
        e: array[4], f: array[5] } );
  } else if (array.length == 16) {
    return [
      array.slice(0, 3),
      array.slice(4, 7),
      array.slice(8, 11),
      array.slice(12, 15)
    ];
  } else {
    return null;
  }
}

// Takes an object of the form { a: 1.1, e: 23 } and builds up a 3d matrix
// with unspecified values filled in with identity values.
function convertObjectTo3dMatrix(obj) {
  return [
    [
      obj.a || obj.sx || obj.m11 || 1,
      obj.b || obj.m12 || 0,
      obj.m13 || 0,
      obj.m14 || 0
    ], [
      obj.c || obj.m21 || 0,
      obj.d || obj.sy || obj.m22 || 1,
      obj.m23 || 0,
      obj.m24 || 0
    ], [
      obj.m31 || 0,
      obj.m32 || 0,
      obj.sz || obj.m33 || 1,
      obj.m34 || 0
    ], [
      obj.e || obj.tx || obj.m41 || 0,
      obj.f || obj.ty || obj.m42 || 0,
      obj.tz || obj.m43 || 0,
      obj.m44 || 1
    ]
  ];
}

function convert3dMatrixToString(matrix) {
  if (is2d(matrix)) {
    return "matrix(" +
           [ matrix[0][0], matrix[0][1],
             matrix[1][0], matrix[1][1],
             matrix[3][0], matrix[3][1] ].join(", ") + ")";
  } else {
    return "matrix3d(" +
            matrix.reduce(function(outer, inner) {
                return outer.concat(inner);
            }).join(", ") + ")";
  }
}

function is2d(matrix) {
  return matrix[0][2] === 0 && matrix[0][3] === 0 &&
         matrix[1][2] === 0 && matrix[1][3] === 0 &&
         matrix[2][0] === 0 && matrix[2][1] === 0 &&
         matrix[2][2] === 1 && matrix[2][3] === 0 &&
         matrix[3][2] === 0 && matrix[3][3] === 1;
}
</script>
</html>
