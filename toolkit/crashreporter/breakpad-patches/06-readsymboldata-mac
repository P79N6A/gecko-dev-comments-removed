# HG changeset patch
# Parent 5f4e1d84f6c317595060aa200adb5aef7e53079d
Provide a ReadSymbolData API for Mac dump_syms

diff --git a/src/common/mac/dump_syms.h b/src/common/mac/dump_syms.h
--- a/src/common/mac/dump_syms.h
+++ b/src/common/mac/dump_syms.h
@@ -111,16 +111,21 @@
     return NULL;
   }
 
   // Read the selected object file's debugging information, and write it out to
   // |stream|. Return true on success; if an error occurs, report it and
   // return false.
   bool WriteSymbolFile(std::ostream &stream);
 
+  // As above, but simply return the debugging information in module
+  // instead of writing it to a stream. The caller owns the resulting
+  // module object and must delete it when finished.
+  bool ReadSymbolData(Module** module);
+
  private:
   // Used internally.
   class DumperLineToModule;
   class LoadCommandDumper;
 
   // Return an identifier string for the file this DumpSymbols is dumping.
   std::string Identifier();
 
diff --git a/src/common/mac/dump_syms.mm b/src/common/mac/dump_syms.mm
--- a/src/common/mac/dump_syms.mm
+++ b/src/common/mac/dump_syms.mm
@@ -48,34 +48,37 @@
 #include "common/dwarf/dwarf2reader.h"
 #include "common/dwarf_cfi_to_module.h"
 #include "common/dwarf_cu_to_module.h"
 #include "common/dwarf_line_to_module.h"
 #include "common/mac/file_id.h"
 #include "common/mac/arch_utilities.h"
 #include "common/mac/macho_reader.h"
 #include "common/module.h"
+#include "common/scoped_ptr.h"
 #include "common/stabs_reader.h"
 #include "common/stabs_to_module.h"
 #include "common/symbol_data.h"
+#include "common/unique_string.h"
 
 #ifndef CPU_TYPE_ARM
 #define CPU_TYPE_ARM (static_cast<cpu_type_t>(12))
 #endif //  CPU_TYPE_ARM
 
 using dwarf2reader::ByteReader;
 using google_breakpad::DwarfCUToModule;
 using google_breakpad::DwarfLineToModule;
 using google_breakpad::FileID;
 using google_breakpad::mach_o::FatReader;
 using google_breakpad::mach_o::Section;
 using google_breakpad::mach_o::Segment;
 using google_breakpad::Module;
 using google_breakpad::StabsReader;
 using google_breakpad::StabsToModule;
+using google_breakpad::scoped_ptr;
 using std::make_pair;
 using std::pair;
 using std::string;
 using std::vector;
 
 namespace google_breakpad {
 
 bool DumpSymbols::Read(NSString *filename) {
@@ -305,17 +308,17 @@
 }
 
 bool DumpSymbols::ReadCFI(google_breakpad::Module *module,
                           const mach_o::Reader &macho_reader,
                           const mach_o::Section &section,
                           bool eh_frame) const {
   // Find the appropriate set of register names for this file's
   // architecture.
-  vector<string> register_names;
+  vector<const UniqueString*> register_names;
   switch (macho_reader.cpu_type()) {
     case CPU_TYPE_X86:
       register_names = DwarfCFIToModule::RegisterNames::I386();
       break;
     case CPU_TYPE_X86_64:
       register_names = DwarfCFIToModule::RegisterNames::X86_64();
       break;
     case CPU_TYPE_ARM:
@@ -434,17 +437,17 @@
                            true,
                            &stabs_to_module);
   if (!stabs_reader.Process())
     return false;
   stabs_to_module.Finalize();
   return true;
 }
 
-bool DumpSymbols::WriteSymbolFile(std::ostream &stream) {
+bool DumpSymbols::ReadSymbolData(Module** out_module) {
   // Select an object file, if SetArchitecture hasn't been called to set one
   // explicitly.
   if (!selected_object_file_) {
     // If there's only one architecture, that's the one.
     if (object_files_.size() == 1)
       selected_object_file_ = &object_files_[0];
     else {
       // Look for an object file whose architecture matches our own.
@@ -485,30 +488,47 @@
 
   // Choose an identifier string, to appear in the MODULE record.
   string identifier = Identifier();
   if (identifier.empty())
     return false;
   identifier += "0";
 
   // Create a module to hold the debugging information.
-  Module module([module_name UTF8String], "mac", selected_arch_name,
-                identifier);
+  scoped_ptr<Module> module = new Module([module_name UTF8String],
+                                         "mac",
+                                         selected_arch_name,
+                                         identifier);
 
   // Parse the selected object file.
   mach_o::Reader::Reporter reporter(selected_object_name_);
   mach_o::Reader reader(&reporter);
   if (!reader.Read(reinterpret_cast<const uint8_t *>([contents_ bytes])
                    + selected_object_file_->offset,
                    selected_object_file_->size,
                    selected_object_file_->cputype,
                    selected_object_file_->cpusubtype))
     return false;
 
   // Walk its load commands, and deal with whatever is there.
-  LoadCommandDumper load_command_dumper(*this, &module, reader, symbol_data_);
+  LoadCommandDumper load_command_dumper(*this, module.get(), reader,
+                                        symbol_data_);
   if (!reader.WalkLoadCommands(&load_command_dumper))
     return false;
 
-  return module.Write(stream, symbol_data_);
+  *out_module = module.release();
+
+  return true;
+}
+
+bool DumpSymbols::WriteSymbolFile(std::ostream &stream, bool cfi) {
+  Module* module = NULL;
+
+  if (ReadSymbolData(&module) && module) {
+    bool res = module->Write(stream, cfi);
+    delete module;
+    return res;
+  }
+
+  return false;
 }
 
 }  // namespace google_breakpad
