Use stdint types everywhere

diff --git a/src/client/linux/crash_generation/crash_generation_server.cc b/src/client/linux/crash_generation/crash_generation_server.cc
--- a/src/client/linux/crash_generation/crash_generation_server.cc
+++ b/src/client/linux/crash_generation/crash_generation_server.cc
@@ -85,17 +85,17 @@
     return false;
   }
 
   if (0 != memcmp(kSocketLinkPrefix, buf, sizeof(kSocketLinkPrefix) - 1)) {
     return false;
   }
 
   char* endptr;
-  const u_int64_t inode_ul =
+  const uint64_t inode_ul =
       strtoull(buf + sizeof(kSocketLinkPrefix) - 1, &endptr, 10);
   if (*endptr != ']')
     return false;
 
   if (inode_ul == ULLONG_MAX) {
     return false;
   }
 
diff --git a/src/client/linux/handler/exception_handler.cc b/src/client/linux/handler/exception_handler.cc
--- a/src/client/linux/handler/exception_handler.cc
+++ b/src/client/linux/handler/exception_handler.cc
@@ -592,17 +592,17 @@
 #else
 #error "This code has not been ported to your platform yet."
 #endif
 
   return GenerateDump(&context);
 }
 
 void ExceptionHandler::AddMappingInfo(const string& name,
-                                      const u_int8_t identifier[sizeof(MDGUID)],
+                                      const uint8_t identifier[sizeof(MDGUID)],
                                       uintptr_t start_address,
                                       size_t mapping_size,
                                       size_t file_offset) {
   MappingInfo info;
   info.start_addr = start_address;
   info.size = mapping_size;
   info.offset = file_offset;
   strncpy(info.name, name.c_str(), sizeof(info.name) - 1);
diff --git a/src/client/linux/handler/exception_handler.h b/src/client/linux/handler/exception_handler.h
--- a/src/client/linux/handler/exception_handler.h
+++ b/src/client/linux/handler/exception_handler.h
@@ -200,17 +200,17 @@
   bool IsOutOfProcess() const {
       return crash_generation_client_.get() != NULL;
   }
 
   // Add information about a memory mapping. This can be used if
   // a custom library loader is used that maps things in a way
   // that the linux dumper can't handle by reading the maps file.
   void AddMappingInfo(const string& name,
-                      const u_int8_t identifier[sizeof(MDGUID)],
+                      const uint8_t identifier[sizeof(MDGUID)],
                       uintptr_t start_address,
                       size_t mapping_size,
                       size_t file_offset);
 
   // Register a block of memory of length bytes starting at address ptr
   // to be copied to the minidump when a crash happens.
   void RegisterAppMemory(void* ptr, size_t length);
 
diff --git a/src/client/linux/handler/exception_handler_unittest.cc b/src/client/linux/handler/exception_handler_unittest.cc
--- a/src/client/linux/handler/exception_handler_unittest.cc
+++ b/src/client/linux/handler/exception_handler_unittest.cc
@@ -418,17 +418,17 @@
 // to the dump as a MinidumpMemoryRegion.
 TEST(ExceptionHandlerTest, InstructionPointerMemory) {
   AutoTempDir temp_dir;
   int fds[2];
   ASSERT_NE(pipe(fds), -1);
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  const u_int32_t kMemorySize = 256;  // bytes
+  const uint32_t kMemorySize = 256;  // bytes
   const int kOffset = kMemorySize / 2;
   // This crashes with SIGILL on x86/x86-64/arm.
   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
 
   const pid_t child = fork();
   if (child == 0) {
     close(fds[0]);
     ExceptionHandler handler(MinidumpDescriptor(temp_dir.path()), NULL,
@@ -478,29 +478,29 @@
   MinidumpMemoryList* memory_list = minidump.GetMemoryList();
   ASSERT_TRUE(exception);
   ASSERT_TRUE(memory_list);
   ASSERT_LT(0U, memory_list->region_count());
 
   MinidumpContext* context = exception->GetContext();
   ASSERT_TRUE(context);
 
-  u_int64_t instruction_pointer;
+  uint64_t instruction_pointer;
   ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 
   MinidumpMemoryRegion* region =
       memory_list->GetMemoryRegionForAddress(instruction_pointer);
   ASSERT_TRUE(region);
 
   EXPECT_EQ(kMemorySize, region->GetSize());
-  const u_int8_t* bytes = region->GetMemory();
+  const uint8_t* bytes = region->GetMemory();
   ASSERT_TRUE(bytes);
 
-  u_int8_t prefix_bytes[kOffset];
-  u_int8_t suffix_bytes[kMemorySize - kOffset - sizeof(instructions)];
+  uint8_t prefix_bytes[kOffset];
+  uint8_t suffix_bytes[kMemorySize - kOffset - sizeof(instructions)];
   memset(prefix_bytes, 0, sizeof(prefix_bytes));
   memset(suffix_bytes, 0, sizeof(suffix_bytes));
   EXPECT_TRUE(memcmp(bytes, prefix_bytes, sizeof(prefix_bytes)) == 0);
   EXPECT_TRUE(memcmp(bytes + kOffset, instructions, sizeof(instructions)) == 0);
   EXPECT_TRUE(memcmp(bytes + kOffset + sizeof(instructions),
                      suffix_bytes, sizeof(suffix_bytes)) == 0);
 
   unlink(minidump_path.c_str());
@@ -510,17 +510,17 @@
 // bounded correctly on the low end.
 TEST(ExceptionHandlerTest, InstructionPointerMemoryMinBound) {
   AutoTempDir temp_dir;
   int fds[2];
   ASSERT_NE(pipe(fds), -1);
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  const u_int32_t kMemorySize = 256;  // bytes
+  const uint32_t kMemorySize = 256;  // bytes
   const int kOffset = 0;
   // This crashes with SIGILL on x86/x86-64/arm.
   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
 
   const pid_t child = fork();
   if (child == 0) {
     close(fds[0]);
     ExceptionHandler handler(MinidumpDescriptor(temp_dir.path()), NULL,
@@ -570,28 +570,28 @@
   MinidumpMemoryList* memory_list = minidump.GetMemoryList();
   ASSERT_TRUE(exception);
   ASSERT_TRUE(memory_list);
   ASSERT_LT(0U, memory_list->region_count());
 
   MinidumpContext* context = exception->GetContext();
   ASSERT_TRUE(context);
 
-  u_int64_t instruction_pointer;
+  uint64_t instruction_pointer;
   ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 
   MinidumpMemoryRegion* region =
       memory_list->GetMemoryRegionForAddress(instruction_pointer);
   ASSERT_TRUE(region);
 
   EXPECT_EQ(kMemorySize / 2, region->GetSize());
-  const u_int8_t* bytes = region->GetMemory();
+  const uint8_t* bytes = region->GetMemory();
   ASSERT_TRUE(bytes);
 
-  u_int8_t suffix_bytes[kMemorySize / 2 - sizeof(instructions)];
+  uint8_t suffix_bytes[kMemorySize / 2 - sizeof(instructions)];
   memset(suffix_bytes, 0, sizeof(suffix_bytes));
   EXPECT_TRUE(memcmp(bytes + kOffset, instructions, sizeof(instructions)) == 0);
   EXPECT_TRUE(memcmp(bytes + kOffset + sizeof(instructions),
                      suffix_bytes, sizeof(suffix_bytes)) == 0);
   unlink(minidump_path.c_str());
 }
 
 // Test that the memory region around the instruction pointer is
@@ -601,17 +601,17 @@
   int fds[2];
   ASSERT_NE(pipe(fds), -1);
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
   // Use 4k here because the OS will hand out a single page even
   // if a smaller size is requested, and this test wants to
   // test the upper bound of the memory range.
-  const u_int32_t kMemorySize = 4096;  // bytes
+  const uint32_t kMemorySize = 4096;  // bytes
   // This crashes with SIGILL on x86/x86-64/arm.
   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
   const int kOffset = kMemorySize - sizeof(instructions);
 
   const pid_t child = fork();
   if (child == 0) {
     close(fds[0]);
     ExceptionHandler handler(MinidumpDescriptor(temp_dir.path()), NULL,
@@ -660,29 +660,29 @@
   MinidumpMemoryList* memory_list = minidump.GetMemoryList();
   ASSERT_TRUE(exception);
   ASSERT_TRUE(memory_list);
   ASSERT_LT(0U, memory_list->region_count());
 
   MinidumpContext* context = exception->GetContext();
   ASSERT_TRUE(context);
 
-  u_int64_t instruction_pointer;
+  uint64_t instruction_pointer;
   ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 
   MinidumpMemoryRegion* region =
       memory_list->GetMemoryRegionForAddress(instruction_pointer);
   ASSERT_TRUE(region);
 
   const size_t kPrefixSize = 128;  // bytes
   EXPECT_EQ(kPrefixSize + sizeof(instructions), region->GetSize());
-  const u_int8_t* bytes = region->GetMemory();
+  const uint8_t* bytes = region->GetMemory();
   ASSERT_TRUE(bytes);
 
-  u_int8_t prefix_bytes[kPrefixSize];
+  uint8_t prefix_bytes[kPrefixSize];
   memset(prefix_bytes, 0, sizeof(prefix_bytes));
   EXPECT_TRUE(memcmp(bytes, prefix_bytes, sizeof(prefix_bytes)) == 0);
   EXPECT_TRUE(memcmp(bytes + kPrefixSize,
                      instructions, sizeof(instructions)) == 0);
 
   unlink(minidump_path.c_str());
 }
 
@@ -737,19 +737,19 @@
   unlink(minidump_path.c_str());
 }
 #endif // !ADDRESS_SANITIZER
 
 // Test that anonymous memory maps can be annotated with names and IDs.
 TEST(ExceptionHandlerTest, ModuleInfo) {
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  const u_int32_t kMemorySize = sysconf(_SC_PAGESIZE);
+  const uint32_t kMemorySize = sysconf(_SC_PAGESIZE);
   const char* kMemoryName = "a fake module";
-  const u_int8_t kModuleGUID[sizeof(MDGUID)] = {
+  const uint8_t kModuleGUID[sizeof(MDGUID)] = {
     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
     0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
   };
   char module_identifier_buffer[kGUIDStringSize];
   FileID::ConvertIdentifierToString(kModuleGUID,
                                     module_identifier_buffer,
                                     sizeof(module_identifier_buffer));
   string module_identifier(module_identifier_buffer);
@@ -993,25 +993,25 @@
   unlink(minidump_2.path());
 
   // 2 distinct files should be produced.
   ASSERT_STRNE(minidump_1_path.c_str(), minidump_2_path.c_str());
 }
 
 // Test that an additional memory region can be added to the minidump.
 TEST(ExceptionHandlerTest, AdditionalMemory) {
-  const u_int32_t kMemorySize = sysconf(_SC_PAGESIZE);
+  const uint32_t kMemorySize = sysconf(_SC_PAGESIZE);
 
   // Get some heap memory.
-  u_int8_t* memory = new u_int8_t[kMemorySize];
+  uint8_t* memory = new uint8_t[kMemorySize];
   const uintptr_t kMemoryAddress = reinterpret_cast<uintptr_t>(memory);
   ASSERT_TRUE(memory);
 
   // Stick some data into the memory so the contents can be verified.
-  for (u_int32_t i = 0; i < kMemorySize; ++i) {
+  for (uint32_t i = 0; i < kMemorySize; ++i) {
     memory[i] = i % 255;
   }
 
   AutoTempDir temp_dir;
   ExceptionHandler handler(
       MinidumpDescriptor(temp_dir.path()), NULL, NULL, NULL, true, -1);
 
   // Add the memory region to the list of memory to be included.
@@ -1037,20 +1037,20 @@
   EXPECT_EQ(0, memcmp(region->GetMemory(), memory, kMemorySize));
 
   delete[] memory;
 }
 
 // Test that a memory region that was previously registered
 // can be unregistered.
 TEST(ExceptionHandlerTest, AdditionalMemoryRemove) {
-  const u_int32_t kMemorySize = sysconf(_SC_PAGESIZE);
+  const uint32_t kMemorySize = sysconf(_SC_PAGESIZE);
 
   // Get some heap memory.
-  u_int8_t* memory = new u_int8_t[kMemorySize];
+  uint8_t* memory = new uint8_t[kMemorySize];
   const uintptr_t kMemoryAddress = reinterpret_cast<uintptr_t>(memory);
   ASSERT_TRUE(memory);
 
   AutoTempDir temp_dir;
   ExceptionHandler handler(
       MinidumpDescriptor(temp_dir.path()), NULL, NULL, NULL, true, -1);
 
   // Add the memory region to the list of memory to be included.
@@ -1104,17 +1104,17 @@
                                             temp_dir.path(), SimpleCallback,
                                             (void*)&minidump_filename));
 
   Minidump minidump(minidump_filename);
   ASSERT_TRUE(minidump.Read());
   // Check that the crashing thread is the main thread of |child|
   MinidumpException* exception = minidump.GetException();
   ASSERT_TRUE(exception);
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(exception->GetThreadID(&thread_id));
   EXPECT_EQ(child, static_cast<int32_t>(thread_id));
 
   const MDRawExceptionStream* raw = exception->exception();
   ASSERT_TRUE(raw);
   EXPECT_EQ(MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED,
             raw->exception_record.exception_code);
 
diff --git a/src/client/linux/minidump_writer/minidump_writer.cc b/src/client/linux/minidump_writer/minidump_writer.cc
--- a/src/client/linux/minidump_writer/minidump_writer.cc
+++ b/src/client/linux/minidump_writer/minidump_writer.cc
@@ -328,17 +328,17 @@
   out->context_flags = MD_CONTEXT_ARM_FULL;
 
   for (int i = 0; i < MD_CONTEXT_ARM_GPR_COUNT; ++i)
     out->iregs[i] = info.regs.uregs[i];
   // No CPSR register in ThreadInfo(it's not accessible via ptrace)
   out->cpsr = 0;
 #if !defined(__ANDROID__)
   out->float_save.fpscr = info.fpregs.fpsr |
-    (static_cast<u_int64_t>(info.fpregs.fpcr) << 32);
+    (static_cast<uint64_t>(info.fpregs.fpcr) << 32);
   // TODO: sort this out, actually collect floating point registers
   my_memset(&out->float_save.regs, 0, sizeof(out->float_save.regs));
   my_memset(&out->float_save.extra, 0, sizeof(out->float_save.extra));
 #endif
 }
 
 void CPUFillFromUContext(MDRawContextARM* out, const ucontext* uc,
                          const struct _libc_fpstate* fpregs) {
@@ -530,28 +530,28 @@
   }
 
   // Check if the top of the stack is part of a system call that has been
   // redirected by the seccomp sandbox. If so, try to pop the stack frames
   // all the way back to the point where the interception happened.
   void PopSeccompStackFrame(RawContextCPU* cpu, const MDRawThread& thread,
                             uint8_t* stack_copy) {
 #if defined(__x86_64)
-    u_int64_t bp = cpu->rbp;
-    u_int64_t top = thread.stack.start_of_memory_range;
+    uint64_t bp = cpu->rbp;
+    uint64_t top = thread.stack.start_of_memory_range;
     for (int i = 4; i--; ) {
       if (bp < top ||
           bp + sizeof(bp) > thread.stack.start_of_memory_range +
           thread.stack.memory.data_size ||
           bp & 1) {
         break;
       }
       uint64_t old_top = top;
       top = bp;
-      u_int8_t* bp_addr = stack_copy + bp - thread.stack.start_of_memory_range;
+      uint8_t* bp_addr = stack_copy + bp - thread.stack.start_of_memory_range;
       my_memcpy(&bp, bp_addr, sizeof(bp));
       if (bp == 0xDEADBEEFDEADBEEFull) {
         struct {
           uint64_t r15;
           uint64_t r14;
           uint64_t r13;
           uint64_t r12;
           uint64_t r11;
@@ -593,28 +593,28 @@
         cpu->r13 = seccomp_stackframe.r13;
         cpu->r14 = seccomp_stackframe.r14;
         cpu->r15 = seccomp_stackframe.r15;
         cpu->rip = seccomp_stackframe.fakeret;
         return;
       }
     }
 #elif defined(__i386)
-    u_int32_t bp = cpu->ebp;
-    u_int32_t top = thread.stack.start_of_memory_range;
+    uint32_t bp = cpu->ebp;
+    uint32_t top = thread.stack.start_of_memory_range;
     for (int i = 4; i--; ) {
       if (bp < top ||
           bp + sizeof(bp) > thread.stack.start_of_memory_range +
           thread.stack.memory.data_size ||
           bp & 1) {
         break;
       }
       uint32_t old_top = top;
       top = bp;
-      u_int8_t* bp_addr = stack_copy + bp - thread.stack.start_of_memory_range;
+      uint8_t* bp_addr = stack_copy + bp - thread.stack.start_of_memory_range;
       my_memcpy(&bp, bp_addr, sizeof(bp));
       if (bp == 0xDEADBEEFu) {
         struct {
           uint32_t edi;
           uint32_t esi;
           uint32_t edx;
           uint32_t ecx;
           uint32_t ebx;
@@ -716,17 +716,17 @@
           ucontext_ &&
           !dumper_->IsPostMortem()) {
         uint8_t* stack_copy;
         if (!FillThreadStack(&thread, GetStackPointer(), -1, &stack_copy))
           return false;
 
         // Copy 256 bytes around crashing instruction pointer to minidump.
         const size_t kIPMemorySize = 256;
-        u_int64_t ip = GetInstructionPointer();
+        uint64_t ip = GetInstructionPointer();
         // Bound it to the upper and lower bounds of the memory map
         // it's contained within. If it's not in mapped memory,
         // don't bother trying to write it.
         bool ip_is_mapped = false;
         MDMemoryDescriptor ip_memory_d;
         for (unsigned j = 0; j < dumper_->mappings().size(); ++j) {
           const MappingInfo& mapping = *dumper_->mappings()[j];
           if (ip >= mapping.start_addr &&
@@ -916,17 +916,17 @@
 
   // Fill the MDRawModule |mod| with information about the provided
   // |mapping|. If |identifier| is non-NULL, use it instead of calculating
   // a file ID from the mapping.
   bool FillRawModule(const MappingInfo& mapping,
                      bool member,
                      unsigned int mapping_id,
                      MDRawModule& mod,
-                     const u_int8_t* identifier) {
+                     const uint8_t* identifier) {
     my_memset(&mod, 0, MD_MODULE_SIZE);
 
     mod.base_of_image = mapping.start_addr;
     mod.size_of_image = mapping.size;
     const size_t filepath_len = my_strlen(mapping.name);
 
     // Figure out file name from path
     const char* filename_ptr = mapping.name + filepath_len - 1;
diff --git a/src/client/linux/minidump_writer/minidump_writer.h b/src/client/linux/minidump_writer/minidump_writer.h
--- a/src/client/linux/minidump_writer/minidump_writer.h
+++ b/src/client/linux/minidump_writer/minidump_writer.h
@@ -41,17 +41,17 @@
 #include "google_breakpad/common/minidump_format.h"
 
 namespace google_breakpad {
 
 class ExceptionHandler;
 
 struct MappingEntry {
   MappingInfo first;
-  u_int8_t second[sizeof(MDGUID)];
+  uint8_t second[sizeof(MDGUID)];
 };
 
 // A list of <MappingInfo, GUID>
 typedef std::list<MappingEntry> MappingList;
 
 // These entries store a list of memory regions that the client wants included
 // in the minidump.
 struct AppMemory {
diff --git a/src/client/linux/minidump_writer/minidump_writer_unittest.cc b/src/client/linux/minidump_writer/minidump_writer_unittest.cc
--- a/src/client/linux/minidump_writer/minidump_writer_unittest.cc
+++ b/src/client/linux/minidump_writer/minidump_writer_unittest.cc
@@ -126,19 +126,19 @@
 // Test that mapping info can be specified when writing a minidump,
 // and that it ends up in the module list of the minidump.
 TEST(MinidumpWriterTest, MappingInfo) {
   int fds[2];
   ASSERT_NE(-1, pipe(fds));
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  const u_int32_t memory_size = sysconf(_SC_PAGESIZE);
+  const uint32_t memory_size = sysconf(_SC_PAGESIZE);
   const char* kMemoryName = "a fake module";
-  const u_int8_t kModuleGUID[sizeof(MDGUID)] = {
+  const uint8_t kModuleGUID[sizeof(MDGUID)] = {
     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
     0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
   };
   char module_identifier_buffer[kGUIDStringSize];
   FileID::ConvertIdentifierToString(kModuleGUID,
                                     module_identifier_buffer,
                                     sizeof(module_identifier_buffer));
   string module_identifier(module_identifier_buffer);
@@ -208,17 +208,17 @@
     module_list->GetModuleForAddress(kMemoryAddress);
   ASSERT_TRUE(module);
 
   EXPECT_EQ(kMemoryAddress, module->base_address());
   EXPECT_EQ(memory_size, module->size());
   EXPECT_EQ(kMemoryName, module->code_file());
   EXPECT_EQ(module_identifier, module->debug_identifier());
 
-  u_int32_t len;
+  uint32_t len;
   // These streams are expected to be there
   EXPECT_TRUE(minidump.SeekToStreamType(MD_THREAD_LIST_STREAM, &len));
   EXPECT_TRUE(minidump.SeekToStreamType(MD_MEMORY_LIST_STREAM, &len));
   EXPECT_TRUE(minidump.SeekToStreamType(MD_EXCEPTION_STREAM, &len));
   EXPECT_TRUE(minidump.SeekToStreamType(MD_SYSTEM_INFO_STREAM, &len));
   EXPECT_TRUE(minidump.SeekToStreamType(MD_LINUX_CPU_INFO, &len));
   EXPECT_TRUE(minidump.SeekToStreamType(MD_LINUX_PROC_STATUS, &len));
   EXPECT_TRUE(minidump.SeekToStreamType(MD_LINUX_CMD_LINE, &len));
@@ -236,17 +236,17 @@
 TEST(MinidumpWriterTest, MappingInfoContained) {
   int fds[2];
   ASSERT_NE(-1, pipe(fds));
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
   const int32_t memory_size = sysconf(_SC_PAGESIZE);
   const char* kMemoryName = "a fake module";
-  const u_int8_t kModuleGUID[sizeof(MDGUID)] = {
+  const uint8_t kModuleGUID[sizeof(MDGUID)] = {
     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
     0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
   };
   char module_identifier_buffer[kGUIDStringSize];
   FileID::ConvertIdentifierToString(kModuleGUID,
                                     module_identifier_buffer,
                                     sizeof(module_identifier_buffer));
   string module_identifier(module_identifier_buffer);
@@ -430,25 +430,25 @@
 
 // Test that an additional memory region can be added to the minidump.
 TEST(MinidumpWriterTest, AdditionalMemory) {
   int fds[2];
   ASSERT_NE(-1, pipe(fds));
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  const u_int32_t kMemorySize = sysconf(_SC_PAGESIZE);
+  const uint32_t kMemorySize = sysconf(_SC_PAGESIZE);
 
   // Get some heap memory.
-  u_int8_t* memory = new u_int8_t[kMemorySize];
+  uint8_t* memory = new uint8_t[kMemorySize];
   const uintptr_t kMemoryAddress = reinterpret_cast<uintptr_t>(memory);
   ASSERT_TRUE(memory);
 
   // Stick some data into the memory so the contents can be verified.
-  for (u_int32_t i = 0; i < kMemorySize; ++i) {
+  for (uint32_t i = 0; i < kMemorySize; ++i) {
     memory[i] = i % 255;
   }
 
   const pid_t child = fork();
   if (child == 0) {
     close(fds[1]);
     char b;
     HANDLE_EINTR(read(fds[0], &b, sizeof(b)));
diff --git a/src/client/mac/handler/minidump_generator.cc b/src/client/mac/handler/minidump_generator.cc
--- a/src/client/mac/handler/minidump_generator.cc
+++ b/src/client/mac/handler/minidump_generator.cc
@@ -405,17 +405,17 @@
     case CPU_TYPE_X86_64:
       return WriteContextX86_64(state, register_location);
 #endif
     default:
       return false;
   }
 }
 
-u_int64_t MinidumpGenerator::CurrentPCForStack(
+uint64_t MinidumpGenerator::CurrentPCForStack(
     breakpad_thread_state_data_t state) {
   switch (cpu_type_) {
 #ifdef HAS_ARM_SUPPORT
     case CPU_TYPE_ARM:
       return CurrentPCForStackARM(state);
 #endif
 #ifdef HAS_PPC_SUPPORT
     case CPU_TYPE_POWERPC:
@@ -439,17 +439,17 @@
 bool MinidumpGenerator::WriteStackARM(breakpad_thread_state_data_t state,
                                       MDMemoryDescriptor *stack_location) {
   arm_thread_state_t *machine_state =
       reinterpret_cast<arm_thread_state_t *>(state);
   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, sp);
   return WriteStackFromStartAddress(start_addr, stack_location);
 }
 
-u_int64_t
+uint64_t
 MinidumpGenerator::CurrentPCForStackARM(breakpad_thread_state_data_t state) {
   arm_thread_state_t *machine_state =
       reinterpret_cast<arm_thread_state_t *>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, pc);
 }
 
 bool MinidumpGenerator::WriteContextARM(breakpad_thread_state_data_t state,
@@ -505,25 +505,25 @@
 bool MinidumpGenerator::WriteStackPPC64(breakpad_thread_state_data_t state,
                                         MDMemoryDescriptor *stack_location) {
   ppc_thread_state64_t *machine_state =
       reinterpret_cast<ppc_thread_state64_t *>(state);
   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, r1);
   return WriteStackFromStartAddress(start_addr, stack_location);
 }
 
-u_int64_t
+uint64_t
 MinidumpGenerator::CurrentPCForStackPPC(breakpad_thread_state_data_t state) {
   ppc_thread_state_t *machine_state =
       reinterpret_cast<ppc_thread_state_t *>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, srr0);
 }
 
-u_int64_t
+uint64_t
 MinidumpGenerator::CurrentPCForStackPPC64(breakpad_thread_state_data_t state) {
   ppc_thread_state64_t *machine_state =
       reinterpret_cast<ppc_thread_state64_t *>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, srr0);
 }
 
 bool MinidumpGenerator::WriteContextPPC(breakpad_thread_state_data_t state,
@@ -667,25 +667,25 @@
                                          MDMemoryDescriptor *stack_location) {
   x86_thread_state64_t *machine_state =
       reinterpret_cast<x86_thread_state64_t *>(state);
 
   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, rsp);
   return WriteStackFromStartAddress(start_addr, stack_location);
 }
 
-u_int64_t
+uint64_t
 MinidumpGenerator::CurrentPCForStackX86(breakpad_thread_state_data_t state) {
   i386_thread_state_t *machine_state =
       reinterpret_cast<i386_thread_state_t *>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, eip);
 }
 
-u_int64_t
+uint64_t
 MinidumpGenerator::CurrentPCForStackX86_64(breakpad_thread_state_data_t state) {
   x86_thread_state64_t *machine_state =
       reinterpret_cast<x86_thread_state64_t *>(state);
 
   return REGISTER_FROM_THREADSTATE(machine_state, rip);
 }
 
 bool MinidumpGenerator::WriteContextX86(breakpad_thread_state_data_t state,
@@ -759,17 +759,17 @@
   AddReg(r13);
   AddReg(r14);
   AddReg(r15);
   AddReg(rip);
   // according to AMD's software developer guide, bits above 18 are
   // not used in the flags register.  Since the minidump format
   // specifies 32 bits for the flags register, we can truncate safely
   // with no loss.
-  context_ptr->eflags = static_cast<u_int32_t>(REGISTER_FROM_THREADSTATE(machine_state, rflags));
+  context_ptr->eflags = static_cast<uint32_t>(REGISTER_FROM_THREADSTATE(machine_state, rflags));
   AddReg(cs);
   AddReg(fs);
   AddReg(gs);
 #undef AddReg
 
   return true;
 }
 #endif
@@ -894,17 +894,17 @@
   bool have_ip_memory = false;
   MDMemoryDescriptor ip_memory_d;
   if (exception_thread_ && exception_type_) {
     breakpad_thread_state_data_t state;
     mach_msg_type_number_t stateCount
       = static_cast<mach_msg_type_number_t>(sizeof(state));
 
     if (GetThreadState(exception_thread_, state, &stateCount)) {
-      u_int64_t ip = CurrentPCForStack(state);
+      uint64_t ip = CurrentPCForStack(state);
       // Bound it to the upper and lower bounds of the region
       // it's contained within. If it's not in a known memory region,
       // don't bother trying to write it.
       mach_vm_address_t addr = static_cast<vm_address_t>(ip);
       mach_vm_size_t size;
       natural_t nesting_level = 0;
       vm_region_submap_info_64 info;
       mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;
@@ -1157,17 +1157,17 @@
 
     MDLocationDescriptor string_location;
 
     string name = image->GetFilePath();
     if (!writer_.WriteString(name.c_str(), 0, &string_location))
       return false;
 
     module->base_of_image = image->GetVMAddr() + image->GetVMAddrSlide();
-    module->size_of_image = static_cast<u_int32_t>(image->GetVMSize());
+    module->size_of_image = static_cast<uint32_t>(image->GetVMSize());
     module->module_name_rva = string_location.rva;
 
     // We'll skip the executable module, because they don't have
     // LC_ID_DYLIB load commands, and the crash processing server gets
     // version information from the Plist file, anyway.
     if (index != static_cast<uint32_t>(FindExecutableModule())) {
       module->version_info.signature = MD_VSFIXEDFILEINFO_SIGNATURE;
       module->version_info.struct_version |= MD_VSFIXEDFILEINFO_VERSION;
@@ -1223,17 +1223,17 @@
 
         if (!strcmp(seg->segname, "__TEXT")) {
           MDLocationDescriptor string_location;
 
           if (!writer_.WriteString(name, 0, &string_location))
             return false;
 
           module->base_of_image = seg->vmaddr + slide;
-          module->size_of_image = static_cast<u_int32_t>(seg->vmsize);
+          module->size_of_image = static_cast<uint32_t>(seg->vmsize);
           module->module_name_rva = string_location.rva;
 
           bool in_memory = false;
 #if TARGET_OS_IPHONE
           in_memory = true;
 #endif
           if (!WriteCVRecord(module, cpu_type, name, in_memory))
             return false;
@@ -1282,17 +1282,17 @@
   // Increment past the slash
   if (module_name)
     ++module_name;
   else
     module_name = "<Unknown>";
 
   size_t module_name_length = strlen(module_name);
 
-  if (!cv.AllocateObjectAndArray(module_name_length + 1, sizeof(u_int8_t)))
+  if (!cv.AllocateObjectAndArray(module_name_length + 1, sizeof(uint8_t)))
     return false;
 
   if (!cv.CopyIndexAfterObject(0, module_name, module_name_length))
     return false;
 
   module->cv_record = cv.location();
   MDCVInfoPDB70 *cv_ptr = cv.get();
   cv_ptr->cv_signature = MD_CVINFOPDB70_SIGNATURE;
@@ -1383,53 +1383,53 @@
 
   if (!info.Allocate())
     return false;
 
   misc_info_stream->stream_type = MD_MISC_INFO_STREAM;
   misc_info_stream->location = info.location();
 
   MDRawMiscInfo *info_ptr = info.get();
-  info_ptr->size_of_info = static_cast<u_int32_t>(sizeof(MDRawMiscInfo));
+  info_ptr->size_of_info = static_cast<uint32_t>(sizeof(MDRawMiscInfo));
   info_ptr->flags1 = MD_MISCINFO_FLAGS1_PROCESS_ID |
     MD_MISCINFO_FLAGS1_PROCESS_TIMES |
     MD_MISCINFO_FLAGS1_PROCESSOR_POWER_INFO;
 
   // Process ID
   info_ptr->process_id = getpid();
 
   // Times
   struct rusage usage;
   if (getrusage(RUSAGE_SELF, &usage) != -1) {
     // Omit the fractional time since the MDRawMiscInfo only wants seconds
     info_ptr->process_user_time =
-        static_cast<u_int32_t>(usage.ru_utime.tv_sec);
+        static_cast<uint32_t>(usage.ru_utime.tv_sec);
     info_ptr->process_kernel_time =
-        static_cast<u_int32_t>(usage.ru_stime.tv_sec);
+        static_cast<uint32_t>(usage.ru_stime.tv_sec);
   }
   int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PID,
                  static_cast<int>(info_ptr->process_id) };
-  u_int mibsize = static_cast<u_int>(sizeof(mib) / sizeof(mib[0]));
+  uint mibsize = static_cast<uint>(sizeof(mib) / sizeof(mib[0]));
   struct kinfo_proc proc;
   size_t size = sizeof(proc);
   if (sysctl(mib, mibsize, &proc, &size, NULL, 0) == 0) {
     info_ptr->process_create_time =
-        static_cast<u_int32_t>(proc.kp_proc.p_starttime.tv_sec);
+        static_cast<uint32_t>(proc.kp_proc.p_starttime.tv_sec);
   }
 
   // Speed
   uint64_t speed;
   const uint64_t kOneMillion = 1000 * 1000;
   size = sizeof(speed);
   sysctlbyname("hw.cpufrequency_max", &speed, &size, NULL, 0);
-  info_ptr->processor_max_mhz = static_cast<u_int32_t>(speed / kOneMillion);
-  info_ptr->processor_mhz_limit = static_cast<u_int32_t>(speed / kOneMillion);
+  info_ptr->processor_max_mhz = static_cast<uint32_t>(speed / kOneMillion);
+  info_ptr->processor_mhz_limit = static_cast<uint32_t>(speed / kOneMillion);
   size = sizeof(speed);
   sysctlbyname("hw.cpufrequency", &speed, &size, NULL, 0);
-  info_ptr->processor_current_mhz = static_cast<u_int32_t>(speed / kOneMillion);
+  info_ptr->processor_current_mhz = static_cast<uint32_t>(speed / kOneMillion);
 
   return true;
 }
 
 bool MinidumpGenerator::WriteBreakpadInfoStream(
     MDRawDirectory *breakpad_info_stream) {
   TypedMDRVA<MDRawBreakpadInfo> info(&writer_);
 
diff --git a/src/client/mac/handler/minidump_generator.h b/src/client/mac/handler/minidump_generator.h
--- a/src/client/mac/handler/minidump_generator.h
+++ b/src/client/mac/handler/minidump_generator.h
@@ -125,17 +125,17 @@
   bool WriteThreadListStream(MDRawDirectory *thread_list_stream);
   bool WriteMemoryListStream(MDRawDirectory *memory_list_stream);
   bool WriteSystemInfoStream(MDRawDirectory *system_info_stream);
   bool WriteModuleListStream(MDRawDirectory *module_list_stream);
   bool WriteMiscInfoStream(MDRawDirectory *misc_info_stream);
   bool WriteBreakpadInfoStream(MDRawDirectory *breakpad_info_stream);
 
   // Helpers
-  u_int64_t CurrentPCForStack(breakpad_thread_state_data_t state);
+  uint64_t CurrentPCForStack(breakpad_thread_state_data_t state);
   bool GetThreadState(thread_act_t target_thread, thread_state_t state,
                       mach_msg_type_number_t *count);
   bool WriteStackFromStartAddress(mach_vm_address_t start_addr,
                                   MDMemoryDescriptor *stack_location);
   bool WriteStack(breakpad_thread_state_data_t state,
                   MDMemoryDescriptor *stack_location);
   bool WriteContext(breakpad_thread_state_data_t state,
                     MDLocationDescriptor *register_location);
@@ -146,41 +146,41 @@
   int  FindExecutableModule();
 
   // Per-CPU implementations of these methods
 #ifdef HAS_ARM_SUPPORT
   bool WriteStackARM(breakpad_thread_state_data_t state,
                      MDMemoryDescriptor *stack_location);
   bool WriteContextARM(breakpad_thread_state_data_t state,
                        MDLocationDescriptor *register_location);
-  u_int64_t CurrentPCForStackARM(breakpad_thread_state_data_t state);
+  uint64_t CurrentPCForStackARM(breakpad_thread_state_data_t state);
 #endif
 #ifdef HAS_PPC_SUPPORT
   bool WriteStackPPC(breakpad_thread_state_data_t state,
                      MDMemoryDescriptor *stack_location);
   bool WriteContextPPC(breakpad_thread_state_data_t state,
                        MDLocationDescriptor *register_location);
-  u_int64_t CurrentPCForStackPPC(breakpad_thread_state_data_t state);
+  uint64_t CurrentPCForStackPPC(breakpad_thread_state_data_t state);
   bool WriteStackPPC64(breakpad_thread_state_data_t state,
                        MDMemoryDescriptor *stack_location);
   bool WriteContextPPC64(breakpad_thread_state_data_t state,
                        MDLocationDescriptor *register_location);
-  u_int64_t CurrentPCForStackPPC64(breakpad_thread_state_data_t state);
+  uint64_t CurrentPCForStackPPC64(breakpad_thread_state_data_t state);
 #endif
 #ifdef HAS_X86_SUPPORT
   bool WriteStackX86(breakpad_thread_state_data_t state,
                        MDMemoryDescriptor *stack_location);
   bool WriteContextX86(breakpad_thread_state_data_t state,
                        MDLocationDescriptor *register_location);
-  u_int64_t CurrentPCForStackX86(breakpad_thread_state_data_t state);
+  uint64_t CurrentPCForStackX86(breakpad_thread_state_data_t state);
   bool WriteStackX86_64(breakpad_thread_state_data_t state,
                         MDMemoryDescriptor *stack_location);
   bool WriteContextX86_64(breakpad_thread_state_data_t state,
                           MDLocationDescriptor *register_location);
-  u_int64_t CurrentPCForStackX86_64(breakpad_thread_state_data_t state);
+  uint64_t CurrentPCForStackX86_64(breakpad_thread_state_data_t state);
 #endif
 
   // disallow copy ctor and operator=
   explicit MinidumpGenerator(const MinidumpGenerator &);
   void operator=(const MinidumpGenerator &);
 
  protected:
   // Use this writer to put the data to disk
diff --git a/src/client/mac/tests/crash_generation_server_test.cc b/src/client/mac/tests/crash_generation_server_test.cc
--- a/src/client/mac/tests/crash_generation_server_test.cc
+++ b/src/client/mac/tests/crash_generation_server_test.cc
@@ -313,17 +313,17 @@
 
 const MDCPUArchitecture kExpectedArchitecture =
 #if defined(__x86_64__)
   MD_CPU_ARCHITECTURE_X86
 #elif defined(__i386__)
   MD_CPU_ARCHITECTURE_AMD64
 #endif
   ;
-const u_int32_t kExpectedContext =
+const uint32_t kExpectedContext =
 #if defined(__i386__)
   MD_CONTEXT_AMD64
 #elif defined(__x86_64__)
   MD_CONTEXT_X86
 #endif
   ;
 
   // Read the minidump, sanity check some data.
diff --git a/src/client/mac/tests/exception_handler_test.cc b/src/client/mac/tests/exception_handler_test.cc
--- a/src/client/mac/tests/exception_handler_test.cc
+++ b/src/client/mac/tests/exception_handler_test.cc
@@ -272,17 +272,17 @@
 // to the dump as a MinidumpMemoryRegion.
 TEST_F(ExceptionHandlerTest, InstructionPointerMemory) {
   // Give the child process a pipe to report back on.
   int fds[2];
   ASSERT_EQ(0, pipe(fds));
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  const u_int32_t kMemorySize = 256;  // bytes
+  const uint32_t kMemorySize = 256;  // bytes
   const int kOffset = kMemorySize / 2;
   // This crashes with SIGILL on x86/x86-64/arm.
   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
 
   pid_t pid = fork();
   if (pid == 0) {
     close(fds[0]);
     ExceptionHandler eh(tempDir.path(), NULL, MDCallback, &fds[1], true, NULL);
@@ -341,29 +341,29 @@
   MinidumpMemoryList* memory_list = minidump.GetMemoryList();
   ASSERT_TRUE(exception);
   ASSERT_TRUE(memory_list);
   ASSERT_NE((unsigned int)0, memory_list->region_count());
 
   MinidumpContext* context = exception->GetContext();
   ASSERT_TRUE(context);
 
-  u_int64_t instruction_pointer;
+  uint64_t instruction_pointer;
   ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 
   MinidumpMemoryRegion* region =
     memory_list->GetMemoryRegionForAddress(instruction_pointer);
   EXPECT_TRUE(region);
 
   EXPECT_EQ(kMemorySize, region->GetSize());
-  const u_int8_t* bytes = region->GetMemory();
+  const uint8_t* bytes = region->GetMemory();
   ASSERT_TRUE(bytes);
 
-  u_int8_t prefix_bytes[kOffset];
-  u_int8_t suffix_bytes[kMemorySize - kOffset - sizeof(instructions)];
+  uint8_t prefix_bytes[kOffset];
+  uint8_t suffix_bytes[kMemorySize - kOffset - sizeof(instructions)];
   memset(prefix_bytes, 0, sizeof(prefix_bytes));
   memset(suffix_bytes, 0, sizeof(suffix_bytes));
   EXPECT_TRUE(memcmp(bytes, prefix_bytes, sizeof(prefix_bytes)) == 0);
   EXPECT_TRUE(memcmp(bytes + kOffset, instructions, sizeof(instructions)) == 0);
   EXPECT_TRUE(memcmp(bytes + kOffset + sizeof(instructions),
                      suffix_bytes, sizeof(suffix_bytes)) == 0);
 }
 
@@ -371,17 +371,17 @@
 // bounded correctly on the low end.
 TEST_F(ExceptionHandlerTest, InstructionPointerMemoryMinBound) {
   // Give the child process a pipe to report back on.
   int fds[2];
   ASSERT_EQ(0, pipe(fds));
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  const u_int32_t kMemorySize = 256;  // bytes
+  const uint32_t kMemorySize = 256;  // bytes
   const int kOffset = 0;
   // This crashes with SIGILL on x86/x86-64/arm.
   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
 
   pid_t pid = fork();
   if (pid == 0) {
     close(fds[0]);
     ExceptionHandler eh(tempDir.path(), NULL, MDCallback, &fds[1], true, NULL);
@@ -440,28 +440,28 @@
   MinidumpMemoryList* memory_list = minidump.GetMemoryList();
   ASSERT_TRUE(exception);
   ASSERT_TRUE(memory_list);
   ASSERT_NE((unsigned int)0, memory_list->region_count());
 
   MinidumpContext* context = exception->GetContext();
   ASSERT_TRUE(context);
 
-  u_int64_t instruction_pointer;
+  uint64_t instruction_pointer;
   ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 
   MinidumpMemoryRegion* region =
     memory_list->GetMemoryRegionForAddress(instruction_pointer);
   EXPECT_TRUE(region);
 
   EXPECT_EQ(kMemorySize / 2, region->GetSize());
-  const u_int8_t* bytes = region->GetMemory();
+  const uint8_t* bytes = region->GetMemory();
   ASSERT_TRUE(bytes);
 
-  u_int8_t suffix_bytes[kMemorySize / 2 - sizeof(instructions)];
+  uint8_t suffix_bytes[kMemorySize / 2 - sizeof(instructions)];
   memset(suffix_bytes, 0, sizeof(suffix_bytes));
   EXPECT_TRUE(memcmp(bytes + kOffset, instructions, sizeof(instructions)) == 0);
   EXPECT_TRUE(memcmp(bytes + kOffset + sizeof(instructions),
                      suffix_bytes, sizeof(suffix_bytes)) == 0);
 }
 
 // Test that the memory region around the instruction pointer is
 // bounded correctly on the high end.
@@ -470,17 +470,17 @@
   int fds[2];
   ASSERT_EQ(0, pipe(fds));
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
   // Use 4k here because the OS will hand out a single page even
   // if a smaller size is requested, and this test wants to
   // test the upper bound of the memory range.
-  const u_int32_t kMemorySize = 4096;  // bytes
+  const uint32_t kMemorySize = 4096;  // bytes
   // This crashes with SIGILL on x86/x86-64/arm.
   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
   const int kOffset = kMemorySize - sizeof(instructions);
 
   pid_t pid = fork();
   if (pid == 0) {
     close(fds[0]);
     ExceptionHandler eh(tempDir.path(), NULL, MDCallback, &fds[1], true, NULL);
@@ -539,29 +539,29 @@
   MinidumpMemoryList* memory_list = minidump.GetMemoryList();
   ASSERT_TRUE(exception);
   ASSERT_TRUE(memory_list);
   ASSERT_NE((unsigned int)0, memory_list->region_count());
 
   MinidumpContext* context = exception->GetContext();
   ASSERT_TRUE(context);
 
-  u_int64_t instruction_pointer;
+  uint64_t instruction_pointer;
   ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 
   MinidumpMemoryRegion* region =
     memory_list->GetMemoryRegionForAddress(instruction_pointer);
   EXPECT_TRUE(region);
 
   const size_t kPrefixSize = 128;  // bytes
   EXPECT_EQ(kPrefixSize + sizeof(instructions), region->GetSize());
-  const u_int8_t* bytes = region->GetMemory();
+  const uint8_t* bytes = region->GetMemory();
   ASSERT_TRUE(bytes);
 
-  u_int8_t prefix_bytes[kPrefixSize];
+  uint8_t prefix_bytes[kPrefixSize];
   memset(prefix_bytes, 0, sizeof(prefix_bytes));
   EXPECT_TRUE(memcmp(bytes, prefix_bytes, sizeof(prefix_bytes)) == 0);
   EXPECT_TRUE(memcmp(bytes + kPrefixSize,
                      instructions, sizeof(instructions)) == 0);
 }
 
 // Ensure that an extra memory block doesn't get added when the
 // instruction pointer is not in mapped memory.
diff --git a/src/client/mac/tests/minidump_generator_test.cc b/src/client/mac/tests/minidump_generator_test.cc
--- a/src/client/mac/tests/minidump_generator_test.cc
+++ b/src/client/mac/tests/minidump_generator_test.cc
@@ -275,17 +275,17 @@
 
 const MDCPUArchitecture kExpectedArchitecture =
 #if defined(__x86_64__)
   MD_CPU_ARCHITECTURE_X86
 #elif defined(__i386__)
   MD_CPU_ARCHITECTURE_AMD64
 #endif
   ;
-const u_int32_t kExpectedContext =
+const uint32_t kExpectedContext =
 #if defined(__i386__)
   MD_CONTEXT_AMD64
 #elif defined(__x86_64__)
   MD_CONTEXT_X86
 #endif
   ;
 
   // Read the minidump, sanity check some data.
diff --git a/src/client/mac/tests/spawn_child_process.h b/src/client/mac/tests/spawn_child_process.h
--- a/src/client/mac/tests/spawn_child_process.h
+++ b/src/client/mac/tests/spawn_child_process.h
@@ -60,17 +60,17 @@
   MD_CPU_ARCHITECTURE_AMD64
 #elif defined(__ppc__) || defined(__ppc64__)
   MD_CPU_ARCHITECTURE_PPC
 #else
 #error "This file has not been ported to this CPU architecture."
 #endif
   ;
 
-const u_int32_t kNativeContext =
+const uint32_t kNativeContext =
 #if defined(__i386__)
   MD_CONTEXT_X86
 #elif defined(__x86_64__)
   MD_CONTEXT_AMD64
 #elif defined(__ppc__) || defined(__ppc64__)
   MD_CONTEXT_PPC
 #else
 #error "This file has not been ported to this CPU architecture."
diff --git a/src/client/minidump_file_writer.cc b/src/client/minidump_file_writer.cc
--- a/src/client/minidump_file_writer.cc
+++ b/src/client/minidump_file_writer.cc
@@ -94,65 +94,65 @@
 
   return result;
 }
 
 bool MinidumpFileWriter::CopyStringToMDString(const wchar_t *str,
                                               unsigned int length,
                                               TypedMDRVA<MDString> *mdstring) {
   bool result = true;
-  if (sizeof(wchar_t) == sizeof(u_int16_t)) {
+  if (sizeof(wchar_t) == sizeof(uint16_t)) {
     // Shortcut if wchar_t is the same size as MDString's buffer
     result = mdstring->Copy(str, mdstring->get()->length);
   } else {
-    u_int16_t out[2];
+    uint16_t out[2];
     int out_idx = 0;
 
     // Copy the string character by character
     while (length && result) {
       UTF32ToUTF16Char(*str, out);
       if (!out[0])
         return false;
 
       // Process one character at a time
       --length;
       ++str;
 
       // Append the one or two UTF-16 characters.  The first one will be non-
       // zero, but the second one may be zero, depending on the conversion from
       // UTF-32.
       int out_count = out[1] ? 2 : 1;
-      size_t out_size = sizeof(u_int16_t) * out_count;
+      size_t out_size = sizeof(uint16_t) * out_count;
       result = mdstring->CopyIndexAfterObject(out_idx, out, out_size);
       out_idx += out_count;
     }
   }
   return result;
 }
 
 bool MinidumpFileWriter::CopyStringToMDString(const char *str,
                                               unsigned int length,
                                               TypedMDRVA<MDString> *mdstring) {
   bool result = true;
-  u_int16_t out[2];
+  uint16_t out[2];
   int out_idx = 0;
 
   // Copy the string character by character
   while (length && result) {
     int conversion_count = UTF8ToUTF16Char(str, length, out);
     if (!conversion_count)
       return false;
 
     // Move the pointer along based on the nubmer of converted characters
     length -= conversion_count;
     str += conversion_count;
 
     // Append the one or two UTF-16 characters
     int out_count = out[1] ? 2 : 1;
-    size_t out_size = sizeof(u_int16_t) * out_count;
+    size_t out_size = sizeof(uint16_t) * out_count;
     result = mdstring->CopyIndexAfterObject(out_idx, out, out_size);
     out_idx += out_count;
   }
   return result;
 }
 
 template <typename CharType>
 bool MinidumpFileWriter::WriteStringCore(const CharType *str,
@@ -165,27 +165,27 @@
   unsigned int mdstring_length = 0;
   if (!length)
     length = INT_MAX;
   for (; mdstring_length < length && str[mdstring_length]; ++mdstring_length)
     ;
 
   // Allocate the string buffer
   TypedMDRVA<MDString> mdstring(this);
-  if (!mdstring.AllocateObjectAndArray(mdstring_length + 1, sizeof(u_int16_t)))
+  if (!mdstring.AllocateObjectAndArray(mdstring_length + 1, sizeof(uint16_t)))
     return false;
 
   // Set length excluding the NULL and copy the string
   mdstring.get()->length =
-      static_cast<u_int32_t>(mdstring_length * sizeof(u_int16_t));
+      static_cast<uint32_t>(mdstring_length * sizeof(uint16_t));
   bool result = CopyStringToMDString(str, mdstring_length, &mdstring);
 
   // NULL terminate
   if (result) {
-    u_int16_t ch = 0;
+    uint16_t ch = 0;
     result = mdstring.CopyIndexAfterObject(mdstring_length, &ch, sizeof(ch));
 
     if (result)
       *location = mdstring.location();
   }
 
   return result;
 }
@@ -206,17 +206,17 @@
   assert(output);
   UntypedMDRVA mem(this);
 
   if (!mem.Allocate(size))
     return false;
   if (!mem.Copy(src, mem.size()))
     return false;
 
-  output->start_of_memory_range = reinterpret_cast<u_int64_t>(src);
+  output->start_of_memory_range = reinterpret_cast<uint64_t>(src);
   output->memory = mem.location();
 
   return true;
 }
 
 MDRVA MinidumpFileWriter::Allocate(size_t size) {
   assert(size);
   assert(file_ != -1);
diff --git a/src/client/minidump_file_writer.h b/src/client/minidump_file_writer.h
--- a/src/client/minidump_file_writer.h
+++ b/src/client/minidump_file_writer.h
@@ -167,17 +167,17 @@
   // Returns the current position or kInvalidMDRVA if allocation failed
   inline MDRVA position() const { return position_; }
 
   // Number of bytes allocated
   inline size_t size() const { return size_; }
 
   // Return size and position
   inline MDLocationDescriptor location() const {
-    MDLocationDescriptor location = { static_cast<u_int32_t>(size_),
+    MDLocationDescriptor location = { static_cast<uint32_t>(size_),
                                       position_ };
     return location;
   }
 
   // Copy |size| bytes starting at |src| into the minidump at |position|
   // Return true on success, or false on failure
   bool Copy(MDRVA position, const void *src, size_t size);
 
diff --git a/src/client/solaris/handler/minidump_generator.cc b/src/client/solaris/handler/minidump_generator.cc
--- a/src/client/solaris/handler/minidump_generator.cc
+++ b/src/client/solaris/handler/minidump_generator.cc
@@ -450,17 +450,17 @@
                    char *realname) {
   TypedMDRVA<MDCVInfoPDB70> cv(minidump_writer);
 
   char path[PATH_MAX];
   const char *module_name = module_path ? module_path : "<Unknown>";
   snprintf(path, sizeof(path), "/proc/self/object/%s", module_name);
 
   size_t module_name_length = strlen(realname);
-  if (!cv.AllocateObjectAndArray(module_name_length + 1, sizeof(u_int8_t)))
+  if (!cv.AllocateObjectAndArray(module_name_length + 1, sizeof(uint8_t)))
     return false;
   if (!cv.CopyIndexAfterObject(0, realname, module_name_length))
     return false;
 
   module->cv_record = cv.location();
   MDCVInfoPDB70 *cv_ptr = cv.get();
   memset(cv_ptr, 0, sizeof(MDCVInfoPDB70));
   cv_ptr->cv_signature = MD_CVINFOPDB70_SIGNATURE;
@@ -517,17 +517,17 @@
 
   if ((realname = strrchr(buf, '/')) == NULL)
     return false;
   realname++;
 
   if (!callback_context->minidump_writer->WriteString(realname, 0, &loc))
     return false;
 
-  module.base_of_image = (u_int64_t)module_info.start_addr;
+  module.base_of_image = (uint64_t)module_info.start_addr;
   module.size_of_image = module_info.size;
   module.module_name_rva = loc.rva;
 
   if (!WriteCVRecord(callback_context->minidump_writer, &module,
                      module_info.name, realname))
     return false;
 
   callback_context->list->CopyIndexAfterObject(
diff --git a/src/client/windows/crash_generation/minidump_generator.h b/src/client/windows/crash_generation/minidump_generator.h
old mode 100644
new mode 100755
--- a/src/client/windows/crash_generation/minidump_generator.h
+++ b/src/client/windows/crash_generation/minidump_generator.h
@@ -27,16 +27,17 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #ifndef CLIENT_WINDOWS_CRASH_GENERATION_MINIDUMP_GENERATOR_H_
 #define CLIENT_WINDOWS_CRASH_GENERATION_MINIDUMP_GENERATOR_H_
 
 #include <windows.h>
 #include <dbghelp.h>
+#include <rpc.h>
 #include <list>
 #include "google_breakpad/common/minidump_format.h"
 
 namespace google_breakpad {
 
 // Abstraction for various objects and operations needed to generate
 // minidump on Windows. This abstraction is useful to hide all the gory
 // details for minidump generation and provide a clean interface to
diff --git a/src/client/windows/unittests/exception_handler_death_test.cc b/src/client/windows/unittests/exception_handler_death_test.cc
--- a/src/client/windows/unittests/exception_handler_death_test.cc
+++ b/src/client/windows/unittests/exception_handler_death_test.cc
@@ -260,17 +260,17 @@
       new google_breakpad::ExceptionHandler(
           temp_path_, NULL, NULL, NULL,
           google_breakpad::ExceptionHandler::HANDLER_ALL);
 
   // Disable GTest SEH handler
   testing::DisableExceptionHandlerInScope disable_exception_handler;
 
   // Get some executable memory.
-  const u_int32_t kMemorySize = 256;  // bytes
+  const uint32_t kMemorySize = 256;  // bytes
   const int kOffset = kMemorySize / 2;
   // This crashes with SIGILL on x86/x86-64/arm.
   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
   char* memory = reinterpret_cast<char*>(VirtualAlloc(NULL,
                                                       kMemorySize,
                                                       MEM_COMMIT | MEM_RESERVE,
                                                       PAGE_EXECUTE_READWRITE));
   ASSERT_TRUE(memory);
@@ -309,29 +309,29 @@
     MinidumpMemoryList* memory_list = minidump.GetMemoryList();
     ASSERT_TRUE(exception);
     ASSERT_TRUE(memory_list);
     ASSERT_LT((unsigned)0, memory_list->region_count());
 
     MinidumpContext* context = exception->GetContext();
     ASSERT_TRUE(context);
 
-    u_int64_t instruction_pointer;
+    uint64_t instruction_pointer;
     ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 
     MinidumpMemoryRegion* region =
         memory_list->GetMemoryRegionForAddress(instruction_pointer);
     ASSERT_TRUE(region);
 
     EXPECT_EQ(kMemorySize, region->GetSize());
-    const u_int8_t* bytes = region->GetMemory();
+    const uint8_t* bytes = region->GetMemory();
     ASSERT_TRUE(bytes);
 
-    u_int8_t prefix_bytes[kOffset];
-    u_int8_t suffix_bytes[kMemorySize - kOffset - sizeof(instructions)];
+    uint8_t prefix_bytes[kOffset];
+    uint8_t suffix_bytes[kMemorySize - kOffset - sizeof(instructions)];
     memset(prefix_bytes, 0, sizeof(prefix_bytes));
     memset(suffix_bytes, 0, sizeof(suffix_bytes));
     EXPECT_TRUE(memcmp(bytes, prefix_bytes, sizeof(prefix_bytes)) == 0);
     EXPECT_TRUE(memcmp(bytes + kOffset, instructions,
                        sizeof(instructions)) == 0);
     EXPECT_TRUE(memcmp(bytes + kOffset + sizeof(instructions),
                        suffix_bytes, sizeof(suffix_bytes)) == 0);
   }
@@ -347,17 +347,17 @@
           google_breakpad::ExceptionHandler::HANDLER_ALL);
 
   // Disable GTest SEH handler
   testing::DisableExceptionHandlerInScope disable_exception_handler;
 
   SYSTEM_INFO sSysInfo;         // Useful information about the system
   GetSystemInfo(&sSysInfo);     // Initialize the structure.
 
-  const u_int32_t kMemorySize = 256;  // bytes
+  const uint32_t kMemorySize = 256;  // bytes
   const DWORD kPageSize = sSysInfo.dwPageSize;
   const int kOffset = 0;
   // This crashes with SIGILL on x86/x86-64/arm.
   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
   // Get some executable memory. Specifically, reserve two pages,
   // but only commit the second.
   char* all_memory = reinterpret_cast<char*>(VirtualAlloc(NULL,
                                                           kPageSize * 2,
@@ -402,28 +402,28 @@
     MinidumpMemoryList* memory_list = minidump.GetMemoryList();
     ASSERT_TRUE(exception);
     ASSERT_TRUE(memory_list);
     ASSERT_LT((unsigned)0, memory_list->region_count());
 
     MinidumpContext* context = exception->GetContext();
     ASSERT_TRUE(context);
 
-    u_int64_t instruction_pointer;
+    uint64_t instruction_pointer;
     ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 
     MinidumpMemoryRegion* region =
         memory_list->GetMemoryRegionForAddress(instruction_pointer);
     ASSERT_TRUE(region);
 
     EXPECT_EQ(kMemorySize / 2, region->GetSize());
-    const u_int8_t* bytes = region->GetMemory();
+    const uint8_t* bytes = region->GetMemory();
     ASSERT_TRUE(bytes);
 
-    u_int8_t suffix_bytes[kMemorySize / 2 - sizeof(instructions)];
+    uint8_t suffix_bytes[kMemorySize / 2 - sizeof(instructions)];
     memset(suffix_bytes, 0, sizeof(suffix_bytes));
     EXPECT_TRUE(memcmp(bytes + kOffset,
                        instructions, sizeof(instructions)) == 0);
     EXPECT_TRUE(memcmp(bytes + kOffset + sizeof(instructions),
                        suffix_bytes, sizeof(suffix_bytes)) == 0);
   }
 
   DeleteFileW(minidump_filename_wide.c_str());
@@ -487,29 +487,29 @@
     MinidumpMemoryList* memory_list = minidump.GetMemoryList();
     ASSERT_TRUE(exception);
     ASSERT_TRUE(memory_list);
     ASSERT_LT((unsigned)0, memory_list->region_count());
 
     MinidumpContext* context = exception->GetContext();
     ASSERT_TRUE(context);
 
-    u_int64_t instruction_pointer;
+    uint64_t instruction_pointer;
     ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 
     MinidumpMemoryRegion* region =
         memory_list->GetMemoryRegionForAddress(instruction_pointer);
     ASSERT_TRUE(region);
 
     const size_t kPrefixSize = 128;  // bytes
     EXPECT_EQ(kPrefixSize + sizeof(instructions), region->GetSize());
-    const u_int8_t* bytes = region->GetMemory();
+    const uint8_t* bytes = region->GetMemory();
     ASSERT_TRUE(bytes);
 
-    u_int8_t prefix_bytes[kPrefixSize];
+    uint8_t prefix_bytes[kPrefixSize];
     memset(prefix_bytes, 0, sizeof(prefix_bytes));
     EXPECT_TRUE(memcmp(bytes, prefix_bytes, sizeof(prefix_bytes)) == 0);
     EXPECT_TRUE(memcmp(bytes + kPrefixSize,
                        instructions, sizeof(instructions)) == 0);
   }
 
   DeleteFileW(minidump_filename_wide.c_str());
 }
diff --git a/src/client/windows/unittests/exception_handler_test.cc b/src/client/windows/unittests/exception_handler_test.cc
--- a/src/client/windows/unittests/exception_handler_test.cc
+++ b/src/client/windows/unittests/exception_handler_test.cc
@@ -392,25 +392,25 @@
   ASSERT_TRUE(minidump.Read());
   //TODO(ted): more comprehensive tests...
 }
 
 // Test that an additional memory region can be included in the minidump.
 TEST_F(ExceptionHandlerTest, AdditionalMemory) {
   SYSTEM_INFO si;
   GetSystemInfo(&si);
-  const u_int32_t kMemorySize = si.dwPageSize;
+  const uint32_t kMemorySize = si.dwPageSize;
 
   // Get some heap memory.
-  u_int8_t* memory = new u_int8_t[kMemorySize];
+  uint8_t* memory = new uint8_t[kMemorySize];
   const uintptr_t kMemoryAddress = reinterpret_cast<uintptr_t>(memory);
   ASSERT_TRUE(memory);
 
   // Stick some data into the memory so the contents can be verified.
-  for (u_int32_t i = 0; i < kMemorySize; ++i) {
+  for (uint32_t i = 0; i < kMemorySize; ++i) {
     memory[i] = i % 255;
   }
 
   ExceptionHandler handler(temp_path_,
                            NULL,
                            DumpCallback,
                            NULL,
                            ExceptionHandler::HANDLER_ALL);
@@ -446,25 +446,25 @@
   delete[] memory;
 }
 
 // Test that a memory region that was previously registered
 // can be unregistered.
 TEST_F(ExceptionHandlerTest, AdditionalMemoryRemove) {
   SYSTEM_INFO si;
   GetSystemInfo(&si);
-  const u_int32_t kMemorySize = si.dwPageSize;
+  const uint32_t kMemorySize = si.dwPageSize;
 
   // Get some heap memory.
-  u_int8_t* memory = new u_int8_t[kMemorySize];
+  uint8_t* memory = new uint8_t[kMemorySize];
   const uintptr_t kMemoryAddress = reinterpret_cast<uintptr_t>(memory);
   ASSERT_TRUE(memory);
 
   // Stick some data into the memory so the contents can be verified.
-  for (u_int32_t i = 0; i < kMemorySize; ++i) {
+  for (uint32_t i = 0; i < kMemorySize; ++i) {
     memory[i] = i % 255;
   }
 
   ExceptionHandler handler(temp_path_,
                            NULL,
                            DumpCallback,
                            NULL,
                            ExceptionHandler::HANDLER_ALL);
diff --git a/src/common/dwarf/cfi_assembler.cc b/src/common/dwarf/cfi_assembler.cc
--- a/src/common/dwarf/cfi_assembler.cc
+++ b/src/common/dwarf/cfi_assembler.cc
@@ -36,20 +36,20 @@
 
 #include <assert.h>
 #include <stdlib.h>
 
 namespace google_breakpad {
 
 using dwarf2reader::DwarfPointerEncoding;
   
-CFISection &CFISection::CIEHeader(u_int64_t code_alignment_factor,
+CFISection &CFISection::CIEHeader(uint64_t code_alignment_factor,
                                   int data_alignment_factor,
                                   unsigned return_address_register,
-                                  u_int8_t version,
+                                  uint8_t version,
                                   const string &augmentation,
                                   bool dwarf64) {
   assert(!entry_length_);
   entry_length_ = new PendingLength();
   in_fde_ = false;
 
   if (dwarf64) {
     D32(kDwarf64InitialLengthMarker);
@@ -68,18 +68,18 @@
   if (version == 1)
     D8(return_address_register);
   else
     ULEB128(return_address_register);
   return *this;
 }
 
 CFISection &CFISection::FDEHeader(Label cie_pointer,
-                                  u_int64_t initial_location,
-                                  u_int64_t address_range,
+                                  uint64_t initial_location,
+                                  uint64_t address_range,
                                   bool dwarf64) {
   assert(!entry_length_);
   entry_length_ = new PendingLength();
   in_fde_ = true;
   fde_start_address_ = initial_location;
 
   if (dwarf64) {
     D32(0xffffffff);
@@ -112,31 +112,31 @@
   Align(address_size_, dwarf2reader::DW_CFA_nop);
   entry_length_->length = Here() - entry_length_->start;
   delete entry_length_;
   entry_length_ = NULL;
   in_fde_ = false;
   return *this;
 }
 
-CFISection &CFISection::EncodedPointer(u_int64_t address,
+CFISection &CFISection::EncodedPointer(uint64_t address,
                                        DwarfPointerEncoding encoding,
                                        const EncodedPointerBases &bases) {
   // Omitted data is extremely easy to emit.
   if (encoding == dwarf2reader::DW_EH_PE_omit)
     return *this;
 
   // If (encoding & dwarf2reader::DW_EH_PE_indirect) != 0, then we assume
   // that ADDRESS is the address at which the pointer is stored --- in
   // other words, that bit has no effect on how we write the pointer.
   encoding = DwarfPointerEncoding(encoding & ~dwarf2reader::DW_EH_PE_indirect);
 
   // Find the base address to which this pointer is relative. The upper
   // nybble of the encoding specifies this.
-  u_int64_t base;
+  uint64_t base;
   switch (encoding & 0xf0) {
     case dwarf2reader::DW_EH_PE_absptr:  base = 0;                  break;
     case dwarf2reader::DW_EH_PE_pcrel:   base = bases.cfi + Size(); break;
     case dwarf2reader::DW_EH_PE_textrel: base = bases.text;         break;
     case dwarf2reader::DW_EH_PE_datarel: base = bases.data;         break;
     case dwarf2reader::DW_EH_PE_funcrel: base = fde_start_address_; break;
     case dwarf2reader::DW_EH_PE_aligned: base = 0;                  break;
     default: abort();
@@ -184,15 +184,15 @@
 
     default:
       abort();
   }
 
   return *this;
 };
 
-const u_int32_t CFISection::kDwarf64InitialLengthMarker;
-const u_int32_t CFISection::kDwarf32CIEIdentifier;
-const u_int64_t CFISection::kDwarf64CIEIdentifier;
-const u_int32_t CFISection::kEHFrame32CIEIdentifier;
-const u_int64_t CFISection::kEHFrame64CIEIdentifier;
+const uint32_t CFISection::kDwarf64InitialLengthMarker;
+const uint32_t CFISection::kDwarf32CIEIdentifier;
+const uint64_t CFISection::kDwarf64CIEIdentifier;
+const uint32_t CFISection::kEHFrame32CIEIdentifier;
+const uint64_t CFISection::kEHFrame64CIEIdentifier;
 
 } // namespace google_breakpad
diff --git a/src/common/dwarf/cfi_assembler.h b/src/common/dwarf/cfi_assembler.h
--- a/src/common/dwarf/cfi_assembler.h
+++ b/src/common/dwarf/cfi_assembler.h
@@ -75,24 +75,24 @@
   // addresses it should use; you can establish a default for all encoded
   // pointers appended to this section with SetEncodedPointerBases.
   struct EncodedPointerBases {
     EncodedPointerBases() : cfi(), text(), data() { }
 
     // The starting address of this CFI section in memory, for
     // DW_EH_PE_pcrel. DW_EH_PE_pcrel pointers may only be used in data
     // that has is loaded into the program's address space.
-    u_int64_t cfi;
+    uint64_t cfi;
 
     // The starting address of this file's .text section, for DW_EH_PE_textrel.
-    u_int64_t text;
+    uint64_t text;
 
     // The starting address of this file's .got or .eh_frame_hdr section,
     // for DW_EH_PE_datarel.
-    u_int64_t data;
+    uint64_t data;
   };
 
   // Create a CFISection whose endianness is ENDIANNESS, and where
   // machine addresses are ADDRESS_SIZE bytes long. If EH_FRAME is
   // true, use the .eh_frame format, as described by the Linux
   // Standards Base Core Specification, instead of the DWARF CFI
   // format.
   CFISection(Endianness endianness, size_t address_size,
@@ -128,36 +128,36 @@
   // given values. If dwarf64 is true, use the 64-bit DWARF initial
   // length format for the CIE's initial length. Return a reference to
   // this section. You should call FinishEntry after writing the last
   // instruction for the CIE.
   //
   // Before calling this function, you will typically want to use Mark
   // or Here to make a label to pass to FDEHeader that refers to this
   // CIE's position in the section.
-  CFISection &CIEHeader(u_int64_t code_alignment_factor,
+  CFISection &CIEHeader(uint64_t code_alignment_factor,
                         int data_alignment_factor,
                         unsigned return_address_register,
-                        u_int8_t version = 3,
+                        uint8_t version = 3,
                         const string &augmentation = "",
                         bool dwarf64 = false);
 
   // Append a Frame Description Entry header to this section with the
   // given values. If dwarf64 is true, use the 64-bit DWARF initial
   // length format for the CIE's initial length. Return a reference to
   // this section. You should call FinishEntry after writing the last
   // instruction for the CIE.
   //
   // This function doesn't support entries that are longer than
   // 0xffffff00 bytes. (The "initial length" is always a 32-bit
   // value.) Nor does it support .debug_frame sections longer than
   // 0xffffff00 bytes.
   CFISection &FDEHeader(Label cie_pointer,
-                        u_int64_t initial_location,
-                        u_int64_t address_range,
+                        uint64_t initial_location,
+                        uint64_t address_range,
                         bool dwarf64 = false);
 
   // Note the current position as the end of the last CIE or FDE we
   // started, after padding with DW_CFA_nops for alignment. This
   // defines the label representing the entry's length, cited in the
   // entry's header. Return a reference to this section.
   CFISection &FinishEntry();
 
@@ -166,17 +166,17 @@
   CFISection &Block(const string &block) {
     ULEB128(block.size());
     Append(block);
     return *this;
   }
 
   // Append ADDRESS to this section, in the appropriate size and
   // endianness. Return a reference to this section.
-  CFISection &Address(u_int64_t address) {
+  CFISection &Address(uint64_t address) {
     Section::Append(endianness(), address_size_, address);
     return *this;
   }
   CFISection &Address(Label address) {
     Section::Append(endianness(), address_size_, address);
     return *this;
   }
 
@@ -184,58 +184,58 @@
   // defaults to this section's default encoding, established by
   // SetPointerEncoding. BASES defaults to this section's bases, set by
   // SetEncodedPointerBases. If the DW_EH_PE_indirect bit is set in the
   // encoding, assume that ADDRESS is where the true address is stored.
   // Return a reference to this section.
   // 
   // (C++ doesn't let me use default arguments here, because I want to
   // refer to members of *this in the default argument expression.)
-  CFISection &EncodedPointer(u_int64_t address) {
+  CFISection &EncodedPointer(uint64_t address) {
     return EncodedPointer(address, pointer_encoding_, encoded_pointer_bases_);
   }
-  CFISection &EncodedPointer(u_int64_t address, DwarfPointerEncoding encoding) {
+  CFISection &EncodedPointer(uint64_t address, DwarfPointerEncoding encoding) {
     return EncodedPointer(address, encoding, encoded_pointer_bases_);
   }
-  CFISection &EncodedPointer(u_int64_t address, DwarfPointerEncoding encoding,
+  CFISection &EncodedPointer(uint64_t address, DwarfPointerEncoding encoding,
                              const EncodedPointerBases &bases);
 
   // Restate some member functions, to keep chaining working nicely.
   CFISection &Mark(Label *label)   { Section::Mark(label); return *this; }
-  CFISection &D8(u_int8_t v)       { Section::D8(v);       return *this; }
-  CFISection &D16(u_int16_t v)     { Section::D16(v);      return *this; }
+  CFISection &D8(uint8_t v)       { Section::D8(v);       return *this; }
+  CFISection &D16(uint16_t v)     { Section::D16(v);      return *this; }
   CFISection &D16(Label v)         { Section::D16(v);      return *this; }
-  CFISection &D32(u_int32_t v)     { Section::D32(v);      return *this; }
+  CFISection &D32(uint32_t v)     { Section::D32(v);      return *this; }
   CFISection &D32(const Label &v)  { Section::D32(v);      return *this; }
-  CFISection &D64(u_int64_t v)     { Section::D64(v);      return *this; }
+  CFISection &D64(uint64_t v)     { Section::D64(v);      return *this; }
   CFISection &D64(const Label &v)  { Section::D64(v);      return *this; }
   CFISection &LEB128(long long v)  { Section::LEB128(v);   return *this; }
-  CFISection &ULEB128(u_int64_t v) { Section::ULEB128(v);  return *this; }
+  CFISection &ULEB128(uint64_t v) { Section::ULEB128(v);  return *this; }
 
  private:
   // A length value that we've appended to the section, but is not yet
   // known. LENGTH is the appended value; START is a label referring
   // to the start of the data whose length was cited.
   struct PendingLength {
     Label length;
     Label start;
   };
 
   // Constants used in CFI/.eh_frame data:
 
   // If the first four bytes of an "initial length" are this constant, then
   // the data uses the 64-bit DWARF format, and the length itself is the
   // subsequent eight bytes.
-  static const u_int32_t kDwarf64InitialLengthMarker = 0xffffffffU;
+  static const uint32_t kDwarf64InitialLengthMarker = 0xffffffffU;
 
   // The CIE identifier for 32- and 64-bit DWARF CFI and .eh_frame data.
-  static const u_int32_t kDwarf32CIEIdentifier = ~(u_int32_t)0;
-  static const u_int64_t kDwarf64CIEIdentifier = ~(u_int64_t)0;
-  static const u_int32_t kEHFrame32CIEIdentifier = 0;
-  static const u_int64_t kEHFrame64CIEIdentifier = 0;
+  static const uint32_t kDwarf32CIEIdentifier = ~(uint32_t)0;
+  static const uint64_t kDwarf64CIEIdentifier = ~(uint64_t)0;
+  static const uint32_t kEHFrame32CIEIdentifier = 0;
+  static const uint64_t kEHFrame64CIEIdentifier = 0;
 
   // The size of a machine address for the data in this section.
   size_t address_size_;
 
   // If true, we are generating a Linux .eh_frame section, instead of
   // a standard DWARF .debug_frame section.
   bool eh_frame_;
 
@@ -256,14 +256,14 @@
   PendingLength *entry_length_;
 
   // True if we are currently emitting an FDE --- that is, we have
   // called FDEHeader but have not yet called FinishEntry.
   bool in_fde_;
 
   // If in_fde_ is true, this is its starting address. We use this for
   // emitting DW_EH_PE_funcrel pointers.
-  u_int64_t fde_start_address_;
+  uint64_t fde_start_address_;
 };
 
 }  // namespace google_breakpad
 
 #endif  // PROCESSOR_CFI_ASSEMBLER_H_
diff --git a/src/common/dwarf/dwarf2reader_cfi_unittest.cc b/src/common/dwarf/dwarf2reader_cfi_unittest.cc
--- a/src/common/dwarf/dwarf2reader_cfi_unittest.cc
+++ b/src/common/dwarf/dwarf2reader_cfi_unittest.cc
@@ -2321,24 +2321,24 @@
 using google_breakpad::test_assembler::Section;
 
 struct ELFSectionHeader {
   ELFSectionHeader(unsigned int set_type)
       : type(set_type), flags(0), address(0), link(0), info(0),
         alignment(1), entry_size(0) { }
   Label name;
   unsigned int type;
-  u_int64_t flags;
-  u_int64_t address;
+  uint64_t flags;
+  uint64_t address;
   Label file_offset;
   Label file_size;
   unsigned int link;
   unsigned int info;
-  u_int64_t alignment;
-  u_int64_t entry_size;
+  uint64_t alignment;
+  uint64_t entry_size;
 };
 
 void AppendSectionHeader(CFISection *table, const ELFSectionHeader &header) {
   (*table)
       .D32(header.name)                   // name, index in string tbl
       .D32(header.type)                   // type
       .Address(header.flags)              // flags
       .Address(header.address)            // address in memory
diff --git a/src/common/dwarf/dwarf2reader_die_unittest.cc b/src/common/dwarf/dwarf2reader_die_unittest.cc
--- a/src/common/dwarf/dwarf2reader_die_unittest.cc
+++ b/src/common/dwarf/dwarf2reader_die_unittest.cc
@@ -284,17 +284,17 @@
 
 struct DwarfForms: public DwarfFormsFixture,
                    public TestWithParam<DwarfHeaderParams> { };
 
 TEST_P(DwarfForms, addr) {
   StartSingleAttributeDIE(GetParam(), dwarf2reader::DW_TAG_compile_unit,
                           dwarf2reader::DW_AT_low_pc,
                           dwarf2reader::DW_FORM_addr);
-  u_int64_t value;
+  uint64_t value;
   if (GetParam().address_size == 4) {
     value = 0xc8e9ffcc;
     info.D32(value);
   } else {
     value = 0xe942517fc2768564ULL;
     info.D64(value);
   }
   info.Finish();
@@ -367,17 +367,17 @@
 
   ParseCompilationUnit(GetParam());
 }
 
 TEST_P(DwarfForms, sec_offset) {
   StartSingleAttributeDIE(GetParam(), (DwarfTag) 0x1d971689,
                           (DwarfAttribute) 0xa060bfd1,
                           dwarf2reader::DW_FORM_sec_offset);
-  u_int64_t value;
+  uint64_t value;
   if (GetParam().format_size == 4) {
     value = 0xacc9c388;
     info.D32(value);
   } else {
     value = 0xcffe5696ffe3ed0aULL;
     info.D64(value);
   }
   info.Finish();
diff --git a/src/common/dwarf/dwarf2reader_test_common.h b/src/common/dwarf/dwarf2reader_test_common.h
--- a/src/common/dwarf/dwarf2reader_test_common.h
+++ b/src/common/dwarf/dwarf2reader_test_common.h
@@ -92,17 +92,17 @@
   }
 
  private:
   // The DWARF format size for this compilation unit.
   size_t format_size_;
 
   // The offset of the point in the compilation unit header immediately
   // after the initial length field.
-  u_int64_t post_length_offset_;
+  uint64_t post_length_offset_;
 
   // The length of the compilation unit, not including the initial length field.
   Label length_;
 };
 
 // A subclass of test_assembler::Section specialized for constructing DWARF
 // abbreviation tables.
 class TestAbbrevTable: public google_breakpad::test_assembler::Section {
diff --git a/src/common/linux/guid_creator.cc b/src/common/linux/guid_creator.cc
--- a/src/common/linux/guid_creator.cc
+++ b/src/common/linux/guid_creator.cc
@@ -41,35 +41,35 @@
 //
 // This class is used to generate random GUID.
 // Currently use random number to generate a GUID since Linux has
 // no native GUID generator. This should be OK since we don't expect
 // crash to happen very offen.
 //
 class GUIDGenerator {
  public:
-  static u_int32_t BytesToUInt32(const u_int8_t bytes[]) {
-    return ((u_int32_t) bytes[0]
-            | ((u_int32_t) bytes[1] << 8)
-            | ((u_int32_t) bytes[2] << 16)
-            | ((u_int32_t) bytes[3] << 24));
+  static uint32_t BytesToUInt32(const uint8_t bytes[]) {
+    return ((uint32_t) bytes[0]
+            | ((uint32_t) bytes[1] << 8)
+            | ((uint32_t) bytes[2] << 16)
+            | ((uint32_t) bytes[3] << 24));
   }
 
-  static void UInt32ToBytes(u_int8_t bytes[], u_int32_t n) {
+  static void UInt32ToBytes(uint8_t bytes[], uint32_t n) {
     bytes[0] = n & 0xff;
     bytes[1] = (n >> 8) & 0xff;
     bytes[2] = (n >> 16) & 0xff;
     bytes[3] = (n >> 24) & 0xff;
   }
 
   static bool CreateGUID(GUID *guid) {
     InitOnce();
     guid->data1 = random();
-    guid->data2 = (u_int16_t)(random());
-    guid->data3 = (u_int16_t)(random());
+    guid->data2 = (uint16_t)(random());
+    guid->data3 = (uint16_t)(random());
     UInt32ToBytes(&guid->data4[0], random());
     UInt32ToBytes(&guid->data4[4], random());
     return true;
   }
 
  private:
   static void InitOnce() {
     pthread_once(&once_control, &InitOnceImpl);
diff --git a/src/common/linux/memory_mapped_file.cc b/src/common/linux/memory_mapped_file.cc
--- a/src/common/linux/memory_mapped_file.cc
+++ b/src/common/linux/memory_mapped_file.cc
@@ -92,14 +92,14 @@
   }
 
   content_.Set(data, st.st_size);
   return true;
 }
 
 void MemoryMappedFile::Unmap() {
   if (content_.data()) {
-    sys_munmap(const_cast<u_int8_t*>(content_.data()), content_.length());
+    sys_munmap(const_cast<uint8_t*>(content_.data()), content_.length());
     content_.Set(NULL, 0);
   }
 }
 
 }  // namespace google_breakpad
diff --git a/src/common/mac/MachIPC.h b/src/common/mac/MachIPC.h
--- a/src/common/mac/MachIPC.h
+++ b/src/common/mac/MachIPC.h
@@ -159,21 +159,21 @@
 //
 //  A MachMessage object is used by ReceivePort::WaitForMessage
 //  and MachPortSender::SendMessage
 //
 class MachMessage {
  public:
 
   // The receiver of the message can retrieve the raw data this way
-  u_int8_t *GetData() {
+  uint8_t *GetData() {
     return GetDataLength() > 0 ? GetDataPacket()->data : NULL;
   }
 
-  u_int32_t GetDataLength() {
+  uint32_t GetDataLength() {
     return EndianU32_LtoN(GetDataPacket()->data_length);
   }
 
   // The message ID may be used as a code identifying the type of message
   void SetMessageID(int32_t message_id) {
     GetDataPacket()->id = EndianU32_NtoL(message_id);
   }
 
@@ -205,30 +205,30 @@
 
   friend class ReceivePort;
   friend class MachPortSender;
 
   // Represents raw data in our message
   struct MessageDataPacket {
     int32_t      id;          // little-endian
     int32_t      data_length; // little-endian
-    u_int8_t     data[1];     // actual size limited by sizeof(MachMessage)
+    uint8_t     data[1];     // actual size limited by sizeof(MachMessage)
   };
 
   MessageDataPacket* GetDataPacket();
 
   void SetDescriptorCount(int n);
   void SetDescriptor(int n, const MachMsgPortDescriptor &desc);
 
   // Returns total message size setting msgh_size in the header to this value
   mach_msg_size_t CalculateSize();
 
   mach_msg_header_t  head;
   mach_msg_body_t    body;
-  u_int8_t           padding[1024]; // descriptors and data may be embedded here
+  uint8_t           padding[1024]; // descriptors and data may be embedded here
 };
 
 //==============================================================================
 // MachReceiveMessage and MachSendMessage are useful to separate the idea
 // of a mach message being sent and being received, and adds increased type
 // safety:
 //  ReceivePort::WaitForMessage() only accepts a MachReceiveMessage
 //  MachPortSender::SendMessage() only accepts a MachSendMessage
diff --git a/src/common/memory_range.h b/src/common/memory_range.h
--- a/src/common/memory_range.h
+++ b/src/common/memory_range.h
@@ -62,17 +62,17 @@
   // Resets to an empty range.
   void Reset() {
     data_ = NULL;
     length_ = 0;
   }
 
   // Sets this memory range to point to |data| and its length to |length|.
   void Set(const void* data, size_t length) {
-    data_ = reinterpret_cast<const u_int8_t*>(data);
+    data_ = reinterpret_cast<const uint8_t*>(data);
     // Always set |length_| to zero if |data_| is NULL.
     length_ = data ? length : 0;
   }
 
   // Returns true if this range covers a subrange of |sub_length| bytes
   // at |sub_offset| bytes of this memory range, or false otherwise.
   bool Covers(size_t sub_offset, size_t sub_length) const {
     // The following checks verify that:
@@ -122,24 +122,24 @@
   // Returns a subrange of |sub_length| bytes at |sub_offset| bytes of
   // this memory range, or an empty range if the subrange is out of bounds.
   MemoryRange Subrange(size_t sub_offset, size_t sub_length) const {
     return Covers(sub_offset, sub_length) ?
         MemoryRange(data_ + sub_offset, sub_length) : MemoryRange();
   }
 
   // Returns a pointer to the beginning of this memory range.
-  const u_int8_t* data() const { return data_; }
+  const uint8_t* data() const { return data_; }
 
   // Returns the length, in bytes, of this memory range.
   size_t length() const { return length_; }
 
  private:
   // Pointer to the beginning of this memory range.
-  const u_int8_t* data_;
+  const uint8_t* data_;
 
   // Length, in bytes, of this memory range.
   size_t length_;
 };
 
 }  // namespace google_breakpad
 
 #endif  // COMMON_MEMORY_RANGE_H_
diff --git a/src/common/memory_range_unittest.cc b/src/common/memory_range_unittest.cc
--- a/src/common/memory_range_unittest.cc
+++ b/src/common/memory_range_unittest.cc
@@ -32,19 +32,19 @@
 #include "breakpad_googletest_includes.h"
 #include "common/memory_range.h"
 
 using google_breakpad::MemoryRange;
 using testing::Message;
 
 namespace {
 
-const u_int32_t kBuffer[10] = { 0 };
+const uint32_t kBuffer[10] = { 0 };
 const size_t kBufferSize = sizeof(kBuffer);
-const u_int8_t* kBufferPointer = reinterpret_cast<const u_int8_t*>(kBuffer);
+const uint8_t* kBufferPointer = reinterpret_cast<const uint8_t*>(kBuffer);
 
 // Test vectors for verifying Covers, GetData, and Subrange.
 const struct {
   bool valid;
   size_t offset;
   size_t length;
 } kSubranges[] = {
   { true, 0, 0 },
diff --git a/src/common/module.h b/src/common/module.h
--- a/src/common/module.h
+++ b/src/common/module.h
@@ -55,17 +55,17 @@
 
 // A Module represents the contents of a module, and supports methods
 // for adding information produced by parsing STABS or DWARF data
 // --- possibly both from the same file --- and then writing out the
 // unified contents as a Breakpad-format symbol file.
 class Module {
  public:
   // The type of addresses and sizes in a symbol table.
-  typedef u_int64_t Address;
+  typedef uint64_t Address;
   struct File;
   struct Function;
   struct Line;
   struct Extern;
 
   // Addresses appearing in File, Function, and Line structures are
   // absolute, not relative to the the module's load address.  That
   // is, if the module were loaded at its nominal load address, the
diff --git a/src/common/solaris/dump_symbols.cc b/src/common/solaris/dump_symbols.cc
--- a/src/common/solaris/dump_symbols.cc
+++ b/src/common/solaris/dump_symbols.cc
@@ -151,17 +151,17 @@
 
 // Strtab section name.
 const char *kStrtabName = ".strtab";
 
 // Default buffer lenght for demangle.
 const int demangleLen = 20000;
 
 // Offset to the string table.
-u_int64_t stringOffset = 0;
+uint64_t stringOffset = 0;
 
 // Update the offset to the start of the string index of the next
 // object module for every N_ENDM stabs.
 inline void RecalculateOffset(struct slist* cur_list, char *stabstr) {
   while ((--cur_list)->n_strx == 0) ;
   stringOffset += cur_list->n_strx;
 
   char *temp = stabstr + stringOffset;
diff --git a/src/common/solaris/guid_creator.cc b/src/common/solaris/guid_creator.cc
--- a/src/common/solaris/guid_creator.cc
+++ b/src/common/solaris/guid_creator.cc
@@ -48,20 +48,20 @@
 class GUIDGenerator {
  public:
   GUIDGenerator() {
     srandom(time(NULL));
   }
 
   bool CreateGUID(GUID *guid) const {
     guid->data1 = random();
-    guid->data2 = (u_int16_t)(random());
-    guid->data3 = (u_int16_t)(random());
-    *reinterpret_cast<u_int32_t*>(&guid->data4[0]) = random();
-    *reinterpret_cast<u_int32_t*>(&guid->data4[4]) = random();
+    guid->data2 = (uint16_t)(random());
+    guid->data3 = (uint16_t)(random());
+    *reinterpret_cast<uint32_t*>(&guid->data4[0]) = random();
+    *reinterpret_cast<uint32_t*>(&guid->data4[4]) = random();
     return true;
   }
 };
 
 // Guid generator.
 const GUIDGenerator kGuidGenerator;
 
 bool CreateGUID(GUID *guid) {
@@ -69,16 +69,16 @@
 };
 
 // Parse guid to string.
 bool GUIDToString(const GUID *guid, char *buf, int buf_len) {
   // Should allow more space the the max length of GUID.
   assert(buf_len > kGUIDStringLength);
   int num = snprintf(buf, buf_len, kGUIDFormatString,
                      guid->data1, guid->data2, guid->data3,
-                     *reinterpret_cast<const u_int32_t *>(&(guid->data4[0])),
-                     *reinterpret_cast<const u_int32_t *>(&(guid->data4[4])));
+                     *reinterpret_cast<const uint32_t *>(&(guid->data4[0])),
+                     *reinterpret_cast<const uint32_t *>(&(guid->data4[4])));
   if (num != kGUIDStringLength)
     return false;
 
   buf[num] = '\0';
   return true;
 }
diff --git a/src/common/stabs_reader_unittest.cc b/src/common/stabs_reader_unittest.cc
--- a/src/common/stabs_reader_unittest.cc
+++ b/src/common/stabs_reader_unittest.cc
@@ -560,17 +560,17 @@
 
 #if defined(HAVE_MACH_O_NLIST_H)
 // These tests have no meaning on non-Mach-O-based systems, as
 // only Mach-O uses N_SECT to represent public symbols.
 TEST_F(Stabs, OnePublicSymbol) {
   stabs.set_endianness(kLittleEndian);
   stabs.set_value_size(4);
 
-  const u_int32_t kExpectedAddress = 0x9000;
+  const uint32_t kExpectedAddress = 0x9000;
   const string kExpectedFunctionName("public_function");
   stabs
     .Stab(N_SECT, 1, 0, kExpectedAddress, kExpectedFunctionName);
 
   {
     InSequence s;
     EXPECT_CALL(mock_handler,
                 Extern(StrEq(kExpectedFunctionName),
@@ -579,19 +579,19 @@
   }
   ASSERT_TRUE(ApplyHandlerToMockStabsData());
 }
 
 TEST_F(Stabs, TwoPublicSymbols) {
   stabs.set_endianness(kLittleEndian);
   stabs.set_value_size(4);
 
-  const u_int32_t kExpectedAddress1 = 0xB0B0B0B0;
+  const uint32_t kExpectedAddress1 = 0xB0B0B0B0;
   const string kExpectedFunctionName1("public_function");
-  const u_int32_t kExpectedAddress2 = 0xF0F0F0F0;
+  const uint32_t kExpectedAddress2 = 0xF0F0F0F0;
   const string kExpectedFunctionName2("something else");
   stabs
     .Stab(N_SECT, 1, 0, kExpectedAddress1, kExpectedFunctionName1)
     .Stab(N_SECT, 1, 0, kExpectedAddress2, kExpectedFunctionName2);
 
   {
     InSequence s;
     EXPECT_CALL(mock_handler,
diff --git a/src/common/string_conversion.cc b/src/common/string_conversion.cc
--- a/src/common/string_conversion.cc
+++ b/src/common/string_conversion.cc
@@ -33,38 +33,38 @@
 #include "common/scoped_ptr.h"
 #include "common/string_conversion.h"
 #include "common/using_std_string.h"
 
 namespace google_breakpad {
 
 using std::vector;
 
-void UTF8ToUTF16(const char *in, vector<u_int16_t> *out) {
+void UTF8ToUTF16(const char *in, vector<uint16_t> *out) {
   size_t source_length = strlen(in);
   const UTF8 *source_ptr = reinterpret_cast<const UTF8 *>(in);
   const UTF8 *source_end_ptr = source_ptr + source_length;
   // Erase the contents and zero fill to the expected size
   out->clear();
   out->insert(out->begin(), source_length, 0);
-  u_int16_t *target_ptr = &(*out)[0];
-  u_int16_t *target_end_ptr = target_ptr + out->capacity() * sizeof(u_int16_t);
+  uint16_t *target_ptr = &(*out)[0];
+  uint16_t *target_end_ptr = target_ptr + out->capacity() * sizeof(uint16_t);
   ConversionResult result = ConvertUTF8toUTF16(&source_ptr, source_end_ptr,
                                                &target_ptr, target_end_ptr,
                                                strictConversion);
 
   // Resize to be the size of the # of converted characters + NULL
   out->resize(result == conversionOK ? target_ptr - &(*out)[0] + 1: 0);
 }
 
-int UTF8ToUTF16Char(const char *in, int in_length, u_int16_t out[2]) {
+int UTF8ToUTF16Char(const char *in, int in_length, uint16_t out[2]) {
   const UTF8 *source_ptr = reinterpret_cast<const UTF8 *>(in);
   const UTF8 *source_end_ptr = source_ptr + sizeof(char);
-  u_int16_t *target_ptr = out;
-  u_int16_t *target_end_ptr = target_ptr + 2 * sizeof(u_int16_t);
+  uint16_t *target_ptr = out;
+  uint16_t *target_end_ptr = target_ptr + 2 * sizeof(uint16_t);
   out[0] = out[1] = 0;
 
   // Process one character at a time
   while (1) {
     ConversionResult result = ConvertUTF8toUTF16(&source_ptr, source_end_ptr,
                                                  &target_ptr, target_end_ptr,
                                                  strictConversion);
 
@@ -77,62 +77,62 @@
 
     if (source_end_ptr > reinterpret_cast<const UTF8 *>(in) + in_length)
       break;
   }
 
   return 0;
 }
 
-void UTF32ToUTF16(const wchar_t *in, vector<u_int16_t> *out) {
+void UTF32ToUTF16(const wchar_t *in, vector<uint16_t> *out) {
   size_t source_length = wcslen(in);
   const UTF32 *source_ptr = reinterpret_cast<const UTF32 *>(in);
   const UTF32 *source_end_ptr = source_ptr + source_length;
   // Erase the contents and zero fill to the expected size
   out->clear();
   out->insert(out->begin(), source_length, 0);
-  u_int16_t *target_ptr = &(*out)[0];
-  u_int16_t *target_end_ptr = target_ptr + out->capacity() * sizeof(u_int16_t);
+  uint16_t *target_ptr = &(*out)[0];
+  uint16_t *target_end_ptr = target_ptr + out->capacity() * sizeof(uint16_t);
   ConversionResult result = ConvertUTF32toUTF16(&source_ptr, source_end_ptr,
                                                 &target_ptr, target_end_ptr,
                                                 strictConversion);
 
   // Resize to be the size of the # of converted characters + NULL
   out->resize(result == conversionOK ? target_ptr - &(*out)[0] + 1: 0);
 }
 
-void UTF32ToUTF16Char(wchar_t in, u_int16_t out[2]) {
+void UTF32ToUTF16Char(wchar_t in, uint16_t out[2]) {
   const UTF32 *source_ptr = reinterpret_cast<const UTF32 *>(&in);
   const UTF32 *source_end_ptr = source_ptr + 1;
-  u_int16_t *target_ptr = out;
-  u_int16_t *target_end_ptr = target_ptr + 2 * sizeof(u_int16_t);
+  uint16_t *target_ptr = out;
+  uint16_t *target_end_ptr = target_ptr + 2 * sizeof(uint16_t);
   out[0] = out[1] = 0;
   ConversionResult result = ConvertUTF32toUTF16(&source_ptr, source_end_ptr,
                                                 &target_ptr, target_end_ptr,
                                                 strictConversion);
 
   if (result != conversionOK) {
     out[0] = out[1] = 0;
   }
 }
 
-static inline u_int16_t Swap(u_int16_t value) {
-  return (value >> 8) | static_cast<u_int16_t>(value << 8);
+static inline uint16_t Swap(uint16_t value) {
+  return (value >> 8) | static_cast<uint16_t>(value << 8);
 }
 
-string UTF16ToUTF8(const vector<u_int16_t> &in, bool swap) {
+string UTF16ToUTF8(const vector<uint16_t> &in, bool swap) {
   const UTF16 *source_ptr = &in[0];
-  scoped_ptr<u_int16_t> source_buffer;
+  scoped_ptr<uint16_t> source_buffer;
 
   // If we're to swap, we need to make a local copy and swap each byte pair
   if (swap) {
     int idx = 0;
-    source_buffer.reset(new u_int16_t[in.size()]);
+    source_buffer.reset(new uint16_t[in.size()]);
     UTF16 *source_buffer_ptr = source_buffer.get();
-    for (vector<u_int16_t>::const_iterator it = in.begin();
+    for (vector<uint16_t>::const_iterator it = in.begin();
          it != in.end(); ++it, ++idx)
       source_buffer_ptr[idx] = Swap(*it);
 
     source_ptr = source_buffer.get();
   }
 
   // The maximum expansion would be 4x the size of the input string.
   const UTF16 *source_end_ptr = source_ptr + in.size();
diff --git a/src/common/string_conversion.h b/src/common/string_conversion.h
--- a/src/common/string_conversion.h
+++ b/src/common/string_conversion.h
@@ -39,30 +39,30 @@
 #include "google_breakpad/common/breakpad_types.h"
 
 namespace google_breakpad {
   
 using std::vector;
 
 // Convert |in| to UTF-16 into |out|.  Use platform byte ordering.  If the
 // conversion failed, |out| will be zero length.
-void UTF8ToUTF16(const char *in, vector<u_int16_t> *out);
+void UTF8ToUTF16(const char *in, vector<uint16_t> *out);
 
 // Convert at least one character (up to a maximum of |in_length|) from |in|
 // to UTF-16 into |out|.  Return the number of characters consumed from |in|.
 // Any unused characters in |out| will be initialized to 0.  No memory will
 // be allocated by this routine.
-int UTF8ToUTF16Char(const char *in, int in_length, u_int16_t out[2]);
+int UTF8ToUTF16Char(const char *in, int in_length, uint16_t out[2]);
 
 // Convert |in| to UTF-16 into |out|.  Use platform byte ordering.  If the
 // conversion failed, |out| will be zero length.
-void UTF32ToUTF16(const wchar_t *in, vector<u_int16_t> *out);
+void UTF32ToUTF16(const wchar_t *in, vector<uint16_t> *out);
 
 // Convert |in| to UTF-16 into |out|.  Any unused characters in |out| will be
 // initialized to 0.  No memory will be allocated by this routine.
-void UTF32ToUTF16Char(wchar_t in, u_int16_t out[2]);
+void UTF32ToUTF16Char(wchar_t in, uint16_t out[2]);
 
 // Convert |in| to UTF-8.  If |swap| is true, swap bytes before converting.
-string UTF16ToUTF8(const vector<u_int16_t> &in, bool swap);
+string UTF16ToUTF8(const vector<uint16_t> &in, bool swap);
 
 }  // namespace google_breakpad
 
 #endif  // COMMON_STRING_CONVERSION_H__
diff --git a/src/common/test_assembler.cc b/src/common/test_assembler.cc
--- a/src/common/test_assembler.cc
+++ b/src/common/test_assembler.cc
@@ -40,42 +40,42 @@
 #include <iterator>
 
 namespace google_breakpad {
 namespace test_assembler {
 
 using std::back_insert_iterator;
 
 Label::Label() : value_(new Binding()) { }
-Label::Label(u_int64_t value) : value_(new Binding(value)) { }
+Label::Label(uint64_t value) : value_(new Binding(value)) { }
 Label::Label(const Label &label) {
   value_ = label.value_;
   value_->Acquire();
 }
 Label::~Label() {
   if (value_->Release()) delete value_;
 }
 
-Label &Label::operator=(u_int64_t value) {
+Label &Label::operator=(uint64_t value) {
   value_->Set(NULL, value);
   return *this;
 }
 
 Label &Label::operator=(const Label &label) {
   value_->Set(label.value_, 0);
   return *this;
 }
 
-Label Label::operator+(u_int64_t addend) const {
+Label Label::operator+(uint64_t addend) const {
   Label l;
   l.value_->Set(this->value_, addend);
   return l;
 }
 
-Label Label::operator-(u_int64_t subtrahend) const {
+Label Label::operator-(uint64_t subtrahend) const {
   Label l;
   l.value_->Set(this->value_, -subtrahend);
   return l;
 }
 
 // When NDEBUG is #defined, assert doesn't evaluate its argument. This
 // means you can't simply use assert to check the return value of a
 // function with necessary side effects.
@@ -84,78 +84,78 @@
 // NDEBUG is #defined; when NDEBUG is not #defined, it further asserts
 // that x is true.
 #ifdef NDEBUG
 #define ALWAYS_EVALUATE_AND_ASSERT(x) x
 #else
 #define ALWAYS_EVALUATE_AND_ASSERT(x) assert(x)
 #endif
 
-u_int64_t Label::operator-(const Label &label) const {
-  u_int64_t offset;
+uint64_t Label::operator-(const Label &label) const {
+  uint64_t offset;
   ALWAYS_EVALUATE_AND_ASSERT(IsKnownOffsetFrom(label, &offset));
   return offset;
 }
 
-u_int64_t Label::Value() const {
-  u_int64_t v = 0;
+uint64_t Label::Value() const {
+  uint64_t v = 0;
   ALWAYS_EVALUATE_AND_ASSERT(IsKnownConstant(&v));
   return v;
 };
 
-bool Label::IsKnownConstant(u_int64_t *value_p) const {
+bool Label::IsKnownConstant(uint64_t *value_p) const {
   Binding *base;
-  u_int64_t addend;
+  uint64_t addend;
   value_->Get(&base, &addend);
   if (base != NULL) return false;
   if (value_p) *value_p = addend;
   return true;
 }
 
-bool Label::IsKnownOffsetFrom(const Label &label, u_int64_t *offset_p) const
+bool Label::IsKnownOffsetFrom(const Label &label, uint64_t *offset_p) const
 {
   Binding *label_base, *this_base;
-  u_int64_t label_addend, this_addend;
+  uint64_t label_addend, this_addend;
   label.value_->Get(&label_base, &label_addend);
   value_->Get(&this_base, &this_addend);
   // If this and label are related, Get will find their final
   // common ancestor, regardless of how indirect the relation is. This
   // comparison also handles the constant vs. constant case.
   if (this_base != label_base) return false;
   if (offset_p) *offset_p = this_addend - label_addend;
   return true;
 }
 
 Label::Binding::Binding() : base_(this), addend_(), reference_count_(1) { }
 
-Label::Binding::Binding(u_int64_t addend)
+Label::Binding::Binding(uint64_t addend)
     : base_(NULL), addend_(addend), reference_count_(1) { }
 
 Label::Binding::~Binding() {
   assert(reference_count_ == 0);
   if (base_ && base_ != this && base_->Release())
     delete base_;
 }
 
-void Label::Binding::Set(Binding *binding, u_int64_t addend) {
+void Label::Binding::Set(Binding *binding, uint64_t addend) {
   if (!base_ && !binding) {
     // We're equating two constants. This could be okay.
     assert(addend_ == addend);
   } else if (!base_) {
     // We are a known constant, but BINDING may not be, so turn the
     // tables and try to set BINDING's value instead.
     binding->Set(NULL, addend_ - addend);
   } else {
     if (binding) {
       // Find binding's final value. Since the final value is always either
       // completely unconstrained or a constant, never a reference to
       // another variable (otherwise, it wouldn't be final), this
       // guarantees we won't create cycles here, even for code like this:
       //   l = m, m = n, n = l;
-      u_int64_t binding_addend;
+      uint64_t binding_addend;
       binding->Get(&binding, &binding_addend);
       addend += binding_addend;
     }
 
     // It seems likely that setting a binding to itself is a bug
     // (although I can imagine this might turn out to be helpful to
     // permit).
     assert(binding != this);
@@ -178,62 +178,62 @@
     // complained if BINDING were 'this' or anywhere along our chain,
     // so we didn't release BINDING.
     if (binding) binding->Acquire();
     base_ = binding;
     addend_ = addend;
   }
 }
 
-void Label::Binding::Get(Binding **base, u_int64_t *addend) {
+void Label::Binding::Get(Binding **base, uint64_t *addend) {
   if (base_ && base_ != this) {
     // Recurse to find the end of our reference chain (the root of our
     // tree), and then rewrite every binding along the chain to refer
     // to it directly, adjusting addends appropriately. (This is why
     // this member function isn't this-const.)
     Binding *final_base;
-    u_int64_t final_addend;
+    uint64_t final_addend;
     base_->Get(&final_base, &final_addend);
     if (final_base) final_base->Acquire();
     if (base_->Release()) delete base_;
     base_ = final_base;
     addend_ += final_addend;
   }
   *base = base_;
   *addend = addend_;
 }
 
 template<typename Inserter>
 static inline void InsertEndian(test_assembler::Endianness endianness,
-                                size_t size, u_int64_t number, Inserter dest) {
+                                size_t size, uint64_t number, Inserter dest) {
   assert(size > 0);
   if (endianness == kLittleEndian) {
     for (size_t i = 0; i < size; i++) {
       *dest++ = (char) (number & 0xff);
       number >>= 8;
     }
   } else {
     assert(endianness == kBigEndian);
     // The loop condition is odd, but it's correct for size_t.
     for (size_t i = size - 1; i < size; i--)
       *dest++ = (char) ((number >> (i * 8)) & 0xff);
   }
 }
 
-Section &Section::Append(Endianness endianness, size_t size, u_int64_t number) {
+Section &Section::Append(Endianness endianness, size_t size, uint64_t number) {
   InsertEndian(endianness, size, number,
                back_insert_iterator<string>(contents_));
   return *this;
 }
 
 Section &Section::Append(Endianness endianness, size_t size,
                          const Label &label) {
   // If this label's value is known, there's no reason to waste an
   // entry in references_ on it.
-  u_int64_t value;
+  uint64_t value;
   if (label.IsKnownConstant(&value))
     return Append(endianness, size, value);
 
   // This will get caught when the references are resolved, but it's
   // nicer to find out earlier.
   assert(endianness != kUnsetEndian);
 
   references_.push_back(Reference(contents_.size(), endianness, size, label));
@@ -241,17 +241,17 @@
   return *this;
 }
 
 #define ENDIANNESS_L kLittleEndian
 #define ENDIANNESS_B kBigEndian
 #define ENDIANNESS(e) ENDIANNESS_ ## e
 
 #define DEFINE_SHORT_APPEND_NUMBER_ENDIAN(e, bits)                      \
-  Section &Section::e ## bits(u_int ## bits ## _t v) {                  \
+  Section &Section::e ## bits(uint ## bits ## _t v) {                  \
     InsertEndian(ENDIANNESS(e), bits / 8, v,                            \
                  back_insert_iterator<string>(contents_));              \
     return *this;                                                       \
   }
 
 #define DEFINE_SHORT_APPEND_LABEL_ENDIAN(e, bits)                       \
   Section &Section::e ## bits(const Label &v) {                         \
     return Append(ENDIANNESS(e), bits / 8, v);                          \
@@ -267,17 +267,17 @@
 DEFINE_SHORT_APPEND_ENDIAN(L, 16);
 DEFINE_SHORT_APPEND_ENDIAN(L, 32);
 DEFINE_SHORT_APPEND_ENDIAN(L, 64);
 DEFINE_SHORT_APPEND_ENDIAN(B, 16);
 DEFINE_SHORT_APPEND_ENDIAN(B, 32);
 DEFINE_SHORT_APPEND_ENDIAN(B, 64);
 
 #define DEFINE_SHORT_APPEND_NUMBER_DEFAULT(bits)                        \
-  Section &Section::D ## bits(u_int ## bits ## _t v) {                  \
+  Section &Section::D ## bits(uint ## bits ## _t v) {                  \
     InsertEndian(endianness_, bits / 8, v,                              \
                  back_insert_iterator<string>(contents_));              \
     return *this;                                                       \
   }
 #define DEFINE_SHORT_APPEND_LABEL_DEFAULT(bits)                         \
   Section &Section::D ## bits(const Label &v) {                         \
     return Append(endianness_, bits / 8, v);                            \
   }
@@ -307,26 +307,26 @@
       value = (value >> 7) | ~(((unsigned long long) -1) >> 7);
     else
       value = (value >> 7);
   }
   contents_ += value & 0x7f;
   return *this;
 }
 
-Section &Section::ULEB128(u_int64_t value) {
+Section &Section::ULEB128(uint64_t value) {
   while (value > 0x7f) {
     contents_ += (value & 0x7f) | 0x80;
     value = (value >> 7);
   }
   contents_ += value;
   return *this;
 }
 
-Section &Section::Align(size_t alignment, u_int8_t pad_byte) {
+Section &Section::Align(size_t alignment, uint8_t pad_byte) {
   // ALIGNMENT must be a power of two.
   assert(((alignment - 1) & alignment) == 0);
   size_t new_size = (contents_.size() + alignment - 1) & ~(alignment - 1);
   contents_.append(new_size - contents_.size(), pad_byte);
   assert((contents_.size() & (alignment - 1)) == 0);
   return *this;
 }
 
@@ -335,17 +335,17 @@
   references_.clear();
 }
 
 bool Section::GetContents(string *contents) {
   // For each label reference, find the label's value, and patch it into
   // the section's contents.
   for (size_t i = 0; i < references_.size(); i++) {
     Reference &r = references_[i];
-    u_int64_t value;
+    uint64_t value;
     if (!r.label.IsKnownConstant(&value)) {
       fprintf(stderr, "Undefined label #%zu at offset 0x%zx\n", i, r.offset);
       return false;
     }
     assert(r.offset < contents_.size());
     assert(contents_.size() - r.offset >= r.size);
     InsertEndian(r.endianness, r.size, value, contents_.begin() + r.offset);
   }
diff --git a/src/common/test_assembler.h b/src/common/test_assembler.h
--- a/src/common/test_assembler.h
+++ b/src/common/test_assembler.h
@@ -105,62 +105,62 @@
 // Label objects' lifetimes are unconstrained: notice that, in the
 // above example, even though a and b are only related through c, and
 // c goes out of scope, the assignment to a sets b's value as well. In
 // particular, it's not necessary to ensure that a Label lives beyond
 // Sections that refer to it.
 class Label {
  public:
   Label();                      // An undefined label.
-  Label(u_int64_t value);       // A label with a fixed value
+  Label(uint64_t value);       // A label with a fixed value
   Label(const Label &value);    // A label equal to another.
   ~Label();
 
   // Return this label's value; it must be known.
   //
   // Providing this as a cast operator is nifty, but the conversions
   // happen in unexpected places. In particular, ISO C++ says that
   // Label + size_t becomes ambigious, because it can't decide whether
-  // to convert the Label to a u_int64_t and then to a size_t, or use
+  // to convert the Label to a uint64_t and then to a size_t, or use
   // the overloaded operator that returns a new label, even though the
   // former could fail if the label is not yet defined and the latter won't.
-  u_int64_t Value() const;
+  uint64_t Value() const;
 
-  Label &operator=(u_int64_t value);
+  Label &operator=(uint64_t value);
   Label &operator=(const Label &value);
-  Label operator+(u_int64_t addend) const;
-  Label operator-(u_int64_t subtrahend) const;
-  u_int64_t operator-(const Label &subtrahend) const;
+  Label operator+(uint64_t addend) const;
+  Label operator-(uint64_t subtrahend) const;
+  uint64_t operator-(const Label &subtrahend) const;
 
   // We could also provide == and != that work on undefined, but
   // related, labels.
 
   // Return true if this label's value is known. If VALUE_P is given,
   // set *VALUE_P to the known value if returning true.
-  bool IsKnownConstant(u_int64_t *value_p = NULL) const;
+  bool IsKnownConstant(uint64_t *value_p = NULL) const;
 
   // Return true if the offset from LABEL to this label is known. If
   // OFFSET_P is given, set *OFFSET_P to the offset when returning true.
   //
   // You can think of l.KnownOffsetFrom(m, &d) as being like 'd = l-m',
   // except that it also returns a value indicating whether the
   // subtraction is possible given what we currently know of l and m.
   // It can be possible even if we don't know l and m's values. For
   // example:
   // 
   //   Label l, m;
   //   m = l + 10;
   //   l.IsKnownConstant();             // false
   //   m.IsKnownConstant();             // false
-  //   u_int64_t d;                     
+  //   uint64_t d;                     
   //   l.IsKnownOffsetFrom(m, &d);      // true, and sets d to -10.
   //   l-m                              // -10
   //   m-l                              // 10
   //   m.Value()                        // error: m's value is not known
-  bool IsKnownOffsetFrom(const Label &label, u_int64_t *offset_p = NULL) const;
+  bool IsKnownOffsetFrom(const Label &label, uint64_t *offset_p = NULL) const;
 
  private:
   // A label's value, or if that is not yet known, how the value is
   // related to other labels' values. A binding may be:
   // - a known constant,
   // - constrained to be equal to some other binding plus a constant, or
   // - unconstrained, and free to take on any value.
   //
@@ -168,42 +168,42 @@
   // refer to another, so bindings and labels form trees whose leaves
   // are labels, whose interior nodes (and roots) are bindings, and
   // where links point from children to parents. Bindings are
   // reference counted, allowing labels to be lightweight, copyable,
   // assignable, placed in containers, and so on.
   class Binding {
    public:
     Binding();
-    Binding(u_int64_t addend);
+    Binding(uint64_t addend);
     ~Binding();
 
     // Increment our reference count.
     void Acquire() { reference_count_++; };
     // Decrement our reference count, and return true if it is zero.
     bool Release() { return --reference_count_ == 0; }
 
     // Set this binding to be equal to BINDING + ADDEND. If BINDING is
     // NULL, then set this binding to the known constant ADDEND.
     // Update every binding on this binding's chain to point directly
     // to BINDING, or to be a constant, with addends adjusted
     // appropriately.
-    void Set(Binding *binding, u_int64_t value);
+    void Set(Binding *binding, uint64_t value);
 
     // Return what we know about the value of this binding.
     // - If this binding's value is a known constant, set BASE to
     //   NULL, and set ADDEND to its value.
     // - If this binding is not a known constant but related to other
     //   bindings, set BASE to the binding at the end of the relation
     //   chain (which will always be unconstrained), and set ADDEND to the
     //   value to add to that binding's value to get this binding's
     //   value.
     // - If this binding is unconstrained, set BASE to this, and leave
     //   ADDEND unchanged.
-    void Get(Binding **base, u_int64_t *addend);
+    void Get(Binding **base, uint64_t *addend);
 
    private:
     // There are three cases:
     //
     // - A binding representing a known constant value has base_ NULL,
     //   and addend_ equal to the value.
     //
     // - A binding representing a completely unconstrained value has
@@ -216,29 +216,29 @@
     //   x = y+c.
     //
     // Thus, the bind_ links form a chain terminating in either a
     // known constant value or a completely unconstrained value. Most
     // operations on bindings do path compression: they change every
     // binding on the chain to point directly to the final value,
     // adjusting addends as appropriate.
     Binding *base_;
-    u_int64_t addend_;
+    uint64_t addend_;
 
     // The number of Labels and Bindings pointing to this binding.
     // (When a binding points to itself, indicating a completely
     // unconstrained binding, that doesn't count as a reference.)
     int reference_count_;
   };
 
   // This label's value.
   Binding *value_;
 };
 
-inline Label operator+(u_int64_t a, const Label &l) { return l + a; }
+inline Label operator+(uint64_t a, const Label &l) { return l + a; }
 // Note that int-Label isn't defined, as negating a Label is not an
 // operation we support.
 
 // Conventions for representing larger numbers as sequences of bytes.
 enum Endianness {
   kBigEndian,        // Big-endian: the most significant byte comes first.
   kLittleEndian,     // Little-endian: the least significant byte comes first.
   kUnsetEndian,      // used internally
@@ -283,36 +283,36 @@
     endianness_ = endianness;
   }
 
   // Return the default endianness of this section.
   Endianness endianness() const { return endianness_; }
 
   // Append the SIZE bytes at DATA or the contents of STRING to the
   // end of this section. Return a reference to this section.
-  Section &Append(const u_int8_t *data, size_t size) {
+  Section &Append(const uint8_t *data, size_t size) {
     contents_.append(reinterpret_cast<const char *>(data), size);
     return *this;
   };
   Section &Append(const string &data) {
     contents_.append(data);
     return *this;
   };
 
   // Append SIZE copies of BYTE to the end of this section. Return a
   // reference to this section.
-  Section &Append(size_t size, u_int8_t byte) {
+  Section &Append(size_t size, uint8_t byte) {
     contents_.append(size, (char) byte);
     return *this;
   }
       
   // Append NUMBER to this section. ENDIANNESS is the endianness to
   // use to write the number. SIZE is the length of the number in
   // bytes. Return a reference to this section.
-  Section &Append(Endianness endianness, size_t size, u_int64_t number);
+  Section &Append(Endianness endianness, size_t size, uint64_t number);
   Section &Append(Endianness endianness, size_t size, const Label &label);
 
   // Append SECTION to the end of this section. The labels SECTION
   // refers to need not be defined yet.
   //
   // Note that this has no effect on any Labels' values, or on
   // SECTION. If placing SECTION within 'this' provides new
   // constraints on existing labels' values, then it's up to the
@@ -347,22 +347,22 @@
   //
   // Since endianness doesn't matter for a single byte, all the
   // <BITWIDTH>=8 functions are equivalent.
   //
   // These can be used to write both signed and unsigned values, as
   // the compiler will properly sign-extend a signed value before
   // passing it to the function, at which point the function's
   // behavior is the same either way.
-  Section &L8(u_int8_t value) { contents_ += value; return *this; }
-  Section &B8(u_int8_t value) { contents_ += value; return *this; }
-  Section &D8(u_int8_t value) { contents_ += value; return *this; }
-  Section &L16(u_int16_t), &L32(u_int32_t), &L64(u_int64_t),
-          &B16(u_int16_t), &B32(u_int32_t), &B64(u_int64_t),
-          &D16(u_int16_t), &D32(u_int32_t), &D64(u_int64_t);
+  Section &L8(uint8_t value) { contents_ += value; return *this; }
+  Section &B8(uint8_t value) { contents_ += value; return *this; }
+  Section &D8(uint8_t value) { contents_ += value; return *this; }
+  Section &L16(uint16_t), &L32(uint32_t), &L64(uint64_t),
+          &B16(uint16_t), &B32(uint32_t), &B64(uint64_t),
+          &D16(uint16_t), &D32(uint32_t), &D64(uint64_t);
   Section &L8(const Label &label),  &L16(const Label &label),
           &L32(const Label &label), &L64(const Label &label),
           &B8(const Label &label),  &B16(const Label &label),
           &B32(const Label &label), &B64(const Label &label),
           &D8(const Label &label),  &D16(const Label &label),
           &D32(const Label &label), &D64(const Label &label);
 
   // Append VALUE in a signed LEB128 (Little-Endian Base 128) form.
@@ -394,23 +394,23 @@
   //   representation is a single byte whose value is N.
   // 
   // - Otherwise, its unsigned LEB128 representation is (N & 0x7f) |
   //   0x80, followed by the unsigned LEB128 representation of N /
   //   128, rounded towards negative infinity.
   //
   // Note that VALUE cannot be a Label (we would have to implement
   // relaxation).
-  Section &ULEB128(u_int64_t value);
+  Section &ULEB128(uint64_t value);
 
   // Jump to the next location aligned on an ALIGNMENT-byte boundary,
   // relative to the start of the section. Fill the gap with PAD_BYTE.
   // ALIGNMENT must be a power of two. Return a reference to this
   // section.
-  Section &Align(size_t alignment, u_int8_t pad_byte = 0);
+  Section &Align(size_t alignment, uint8_t pad_byte = 0);
 
   // Clear the contents of this section.
   void Clear();
 
   // Return the current size of the section.
   size_t Size() const { return contents_.size(); }
 
   // Return a label representing the start of the section.
diff --git a/src/common/test_assembler_unittest.cc b/src/common/test_assembler_unittest.cc
--- a/src/common/test_assembler_unittest.cc
+++ b/src/common/test_assembler_unittest.cc
@@ -55,89 +55,89 @@
 
 TEST(ConstructLabelDeathTest, Undefined) {
   Label l;
   ASSERT_DEATH(l.Value(), "IsKnownConstant\\(&v\\)");
 }
 
 TEST(ConstructLabel, Constant) {
   Label l(0x060b9f974eaf301eULL);
-  u_int64_t v;
+  uint64_t v;
   EXPECT_TRUE(l.IsKnownConstant(&v));
   EXPECT_EQ(v, 0x060b9f974eaf301eULL);
   EXPECT_EQ(l.Value(), 0x060b9f974eaf301eULL);
 }
 
 TEST(ConstructLabel, Copy) {
   Label l;
   Label m(l);
-  u_int64_t v;
+  uint64_t v;
   EXPECT_TRUE(l.IsKnownOffsetFrom(m, &v));
   EXPECT_EQ(0U, v);
 }
 
 // The left-hand-side of a label assignment can be either
 // unconstrained, related, or known. The right-hand-side can be any of
 // those, or an integer.
 TEST(Assignment, UnconstrainedToUnconstrained) {
   Label l, m;
   l = m;
   EXPECT_EQ(0U, l-m);
   EXPECT_TRUE(l.IsKnownOffsetFrom(m));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(l.IsKnownOffsetFrom(m, &d));
   EXPECT_EQ(0U, d);
   EXPECT_FALSE(l.IsKnownConstant());
 }
 
 TEST(Assignment, UnconstrainedToRelated) {
   Label l, m, n;
   l = n;
   l = m;
   EXPECT_EQ(0U, l-m);
   EXPECT_TRUE(l.IsKnownOffsetFrom(m));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(l.IsKnownOffsetFrom(m, &d));
   EXPECT_EQ(0U, d);
   EXPECT_FALSE(l.IsKnownConstant());
 }
 
 TEST(Assignment, UnconstrainedToKnown) {
   Label l, m;
   l = 0x8fd16e55b20a39c1ULL;
   l = m;
   EXPECT_EQ(0U, l-m);
   EXPECT_TRUE(l.IsKnownOffsetFrom(m));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(l.IsKnownOffsetFrom(m, &d));
   EXPECT_EQ(0U, d);
   EXPECT_TRUE(m.IsKnownConstant());
   EXPECT_EQ(0x8fd16e55b20a39c1ULL, m.Value());
 }
 
 TEST(Assignment, RelatedToUnconstrained) {
   Label l, m, n;
   m = n;
   l = m;
   EXPECT_EQ(0U, l-n);
   EXPECT_TRUE(l.IsKnownOffsetFrom(n));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(l.IsKnownOffsetFrom(n, &d));
   EXPECT_EQ(0U, d);
   EXPECT_FALSE(l.IsKnownConstant());
 }
 
 TEST(Assignment, RelatedToRelated) {
   Label l, m, n, o;
   l = n;
   m = o;
   l = m;
   EXPECT_EQ(0U, n-o);
   EXPECT_TRUE(n.IsKnownOffsetFrom(o));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(n.IsKnownOffsetFrom(o, &d));
   EXPECT_EQ(0U, d);
   EXPECT_FALSE(l.IsKnownConstant());
 }
 
 TEST(Assignment, RelatedToKnown) {
   Label l, m, n;
   m = n;
@@ -229,72 +229,72 @@
   o = n;
   ASSERT_DEATH(o = l, "binding != this");
 }
 
 TEST(Addition, LabelConstant) {
   Label l, m;
   m = l + 0x5248d93e8bbe9497ULL;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l, &d));
   EXPECT_EQ(0x5248d93e8bbe9497ULL, d);
   EXPECT_FALSE(m.IsKnownConstant());
 }
 
 TEST(Addition, ConstantLabel) {
   Label l, m;
   m = 0xf51e94e00d6e3c84ULL + l;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l, &d));
   EXPECT_EQ(0xf51e94e00d6e3c84ULL, d);
   EXPECT_FALSE(m.IsKnownConstant());
 }
 
 TEST(Addition, KnownLabelConstant) {
   Label l, m;
   l = 0x16286307042ce0d8ULL;
   m = l + 0x3fdddd91306719d7ULL;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l, &d));
   EXPECT_EQ(0x3fdddd91306719d7ULL, d);
   EXPECT_TRUE(m.IsKnownConstant());
   EXPECT_EQ(0x16286307042ce0d8ULL + 0x3fdddd91306719d7ULL, m.Value());
 }
 
 TEST(Addition, ConstantKnownLabel) {
   Label l, m;
   l = 0x50f62d0cdd1031deULL;
   m = 0x1b13462d8577c538ULL + l;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l, &d));
   EXPECT_EQ(0x1b13462d8577c538ULL, d);
   EXPECT_TRUE(m.IsKnownConstant());
   EXPECT_EQ(0x50f62d0cdd1031deULL + 0x1b13462d8577c538ULL, m.Value());
 }
 
 TEST(Subtraction, LabelConstant) {
   Label l, m;
   m = l - 0x0620884d21d3138eULL;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l, &d));
   EXPECT_EQ(-0x0620884d21d3138eULL, d);
   EXPECT_FALSE(m.IsKnownConstant());
 }
 
 TEST(Subtraction, KnownLabelConstant) {
   Label l, m;
   l = 0x6237fbaf9ef7929eULL;
   m = l - 0x317730995d2ab6eeULL;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l));
-  u_int64_t d;
+  uint64_t d;
   EXPECT_TRUE(m.IsKnownOffsetFrom(l, &d));
   EXPECT_EQ(-0x317730995d2ab6eeULL, d);
   EXPECT_TRUE(m.IsKnownConstant());
   EXPECT_EQ(0x6237fbaf9ef7929eULL - 0x317730995d2ab6eeULL, m.Value());
 }
 
 TEST(SubtractionDeathTest, LabelLabel) {
   Label l, m;
@@ -470,59 +470,59 @@
 
 TEST(LabelChain, AssignEndRelationBeforeForward) {
   Label a, b, c, d;
   Label x;
   x = d;
   b = a + 0x1;
   c = b + 0x10;
   d = c + 0x100;
-  EXPECT_EQ(-(u_int64_t)0x111U, a-x);
-  EXPECT_EQ(-(u_int64_t)0x110U, b-x);
-  EXPECT_EQ(-(u_int64_t)0x100U, c-x);
-  EXPECT_EQ(-(u_int64_t)0U,     d-x);
+  EXPECT_EQ(-(uint64_t)0x111U, a-x);
+  EXPECT_EQ(-(uint64_t)0x110U, b-x);
+  EXPECT_EQ(-(uint64_t)0x100U, c-x);
+  EXPECT_EQ(-(uint64_t)0U,     d-x);
 }
 
 TEST(LabelChain, AssignEndRelationBeforeBackward) {
   Label a, b, c, d;
   Label x;
   x = d;
   d = c + 0x100;
   c = b + 0x10;
   b = a + 0x1;
-  EXPECT_EQ(-(u_int64_t)0x111U, a-x);
-  EXPECT_EQ(-(u_int64_t)0x110U, b-x);
-  EXPECT_EQ(-(u_int64_t)0x100U, c-x);
-  EXPECT_EQ(-(u_int64_t)0U,     d-x);
+  EXPECT_EQ(-(uint64_t)0x111U, a-x);
+  EXPECT_EQ(-(uint64_t)0x110U, b-x);
+  EXPECT_EQ(-(uint64_t)0x100U, c-x);
+  EXPECT_EQ(-(uint64_t)0U,     d-x);
 }
 
 TEST(LabelChain, AssignEndRelationAfterForward) {
   Label a, b, c, d;
   Label x;
   b = a + 0x1;
   c = b + 0x10;
   d = c + 0x100;
   x = d;
-  EXPECT_EQ(-(u_int64_t)0x111U, a-x);
-  EXPECT_EQ(-(u_int64_t)0x110U, b-x);
-  EXPECT_EQ(-(u_int64_t)0x100U, c-x);
-  EXPECT_EQ(-(u_int64_t)0x000U, d-x);
+  EXPECT_EQ(-(uint64_t)0x111U, a-x);
+  EXPECT_EQ(-(uint64_t)0x110U, b-x);
+  EXPECT_EQ(-(uint64_t)0x100U, c-x);
+  EXPECT_EQ(-(uint64_t)0x000U, d-x);
 }
 
 TEST(LabelChain, AssignEndRelationAfterBackward) {
   Label a, b, c, d;
   Label x;
   d = c + 0x100;
   c = b + 0x10;
   b = a + 0x1;
   x = d;
-  EXPECT_EQ(-(u_int64_t)0x111U, a-x);
-  EXPECT_EQ(-(u_int64_t)0x110U, b-x);
-  EXPECT_EQ(-(u_int64_t)0x100U, c-x);
-  EXPECT_EQ(-(u_int64_t)0x000U, d-x);
+  EXPECT_EQ(-(uint64_t)0x111U, a-x);
+  EXPECT_EQ(-(uint64_t)0x110U, b-x);
+  EXPECT_EQ(-(uint64_t)0x100U, c-x);
+  EXPECT_EQ(-(uint64_t)0x000U, d-x);
 }
 
 TEST(LabelChain, AssignEndValueBeforeForward) {
   Label a, b, c, d;
   d = 0xa131200190546ac2ULL;
   b = a + 0x1;
   c = b + 0x10;
   d = c + 0x100;
@@ -618,20 +618,20 @@
 
 TEST(LabelChain, ConstructEndRelationAfterForward) {
   Label x;
   Label a;
   Label b(a + 0x1);
   Label c(b + 0x10);
   Label d(c + 0x100);
   x = d;
-  EXPECT_EQ(-(u_int64_t)0x111U, a-x);
-  EXPECT_EQ(-(u_int64_t)0x110U, b-x);
-  EXPECT_EQ(-(u_int64_t)0x100U, c-x);
-  EXPECT_EQ(-(u_int64_t)0x000U, d-x);
+  EXPECT_EQ(-(uint64_t)0x111U, a-x);
+  EXPECT_EQ(-(uint64_t)0x110U, b-x);
+  EXPECT_EQ(-(uint64_t)0x100U, c-x);
+  EXPECT_EQ(-(uint64_t)0x000U, d-x);
 }
 
 TEST(LabelChain, ConstructEndValueAfterForward) {
   Label a;
   Label b(a + 0x1);
   Label c(b + 0x10);
   Label d(c + 0x100);
   d = 0x99b8f51bafd41adaULL;
@@ -727,38 +727,38 @@
   Section s(kBigEndian);
 }
 
 // A fixture class for TestAssembler::Section tests.
 class SectionFixture {
  public:
   Section section;
   string contents;
-  static const u_int8_t data[];
+  static const uint8_t data[];
   static const size_t data_size;
 };
 
-const u_int8_t SectionFixture::data[] = {
+const uint8_t SectionFixture::data[] = {
   0x87, 0x4f, 0x43, 0x67, 0x30, 0xd0, 0xd4, 0x0e
 };
 
 #define I0()
 #define I1(a) { a }
 #define I2(a,b) { a,b }
 #define I3(a,b,c) { a,b,c }
 #define I4(a,b,c,d) { a,b,c,d }
 #define I5(a,b,c,d,e) { a,b,c,d,e }
 #define I6(a,b,c,d,e,f) { a,b,c,d,e,f }
 #define I7(a,b,c,d,e,f,g) { a,b,c,d,e,f,g }
 #define I8(a,b,c,d,e,f,g,h) { a,b,c,d,e,f,g,h }
 #define I9(a,b,c,d,e,f,g,h,i) { a,b,c,d,e,f,g,h,i }
 #define ASSERT_BYTES(s, b)                                              \
   do                                                                    \
     {                                                                   \
-      static const u_int8_t expected_bytes[] = b;                       \
+      static const uint8_t expected_bytes[] = b;                       \
       ASSERT_EQ(sizeof(expected_bytes), s.size());                      \
       ASSERT_TRUE(memcmp(s.data(), (const char *) expected_bytes,       \
                          sizeof(expected_bytes)) == 0);                 \
     }                                                                   \
   while(0)
 
 class Append: public SectionFixture, public Test { };
 
@@ -1356,17 +1356,17 @@
   d = 0x163177f15a0eb4ecULL;
   e = 0xbd1b0f1d977f2246ULL;
   f = 0x2b0842eee83c6461ULL;
   g = 0x92f4b928a4bf875eULL;
   h = 0x61a199a8f7286ba6ULL;
   ASSERT_EQ(8 * 18U, section.Size());
   ASSERT_TRUE(section.GetContents(&contents));
 
-  static const u_int8_t expected[] = {
+  static const uint8_t expected[] = {
     0x35,    0xa6, 0x6b, 0x28, 0xf7, 0xa8, 0x99, 0xa1, 0x61,
     0x8b,    0x39, 0x44, 0x8f, 0x44, 0x40, 0x65, 0xa5, 0x0e,
     0xc9, 0x1c,    0x5e, 0x87, 0xbf, 0xa4, 0x28, 0xb9, 0xf4,
     0xcf, 0x15,    0x4a, 0x72, 0xc5, 0x04, 0x4f, 0x69, 0x29,
     0x05, 0x86, 0x2f,    0x61, 0x64, 0x3c, 0xe8, 0xee, 0x42,
     0x8c, 0x3f, 0xfd,    0x7a, 0x18, 0x80, 0xba, 0x11, 0x6f,
     0x5a, 0x0e, 0xb4, 0xec,    0x46, 0x22, 0x7f, 0x97, 0x1d,
     0x2f, 0xda, 0x24, 0x72,    0x3f, 0x42, 0x2d, 0xa0, 0x0a,
diff --git a/src/google_breakpad/common/breakpad_types.h b/src/google_breakpad/common/breakpad_types.h
--- a/src/google_breakpad/common/breakpad_types.h
+++ b/src/google_breakpad/common/breakpad_types.h
@@ -26,57 +26,59 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
 
 /* breakpad_types.h: Precise-width types
  *
  * (This is C99 source, please don't corrupt it with C++.)
  *
- * This file ensures that types u_intN_t are defined for N = 8, 16, 32, and
+ * This file ensures that types uintN_t are defined for N = 8, 16, 32, and
  * 64.  Types of precise widths are crucial to the task of writing data
  * structures on one platform and reading them on another.
  *
  * Author: Mark Mentovai */
 
 #ifndef GOOGLE_BREAKPAD_COMMON_BREAKPAD_TYPES_H__
 #define GOOGLE_BREAKPAD_COMMON_BREAKPAD_TYPES_H__
 
 #ifndef _WIN32
 
-#include <sys/types.h>
 #ifndef __STDC_FORMAT_MACROS
 #define __STDC_FORMAT_MACROS
 #endif  /* __STDC_FORMAT_MACROS */
 #include <inttypes.h>
 
-#if defined(__SUNPRO_CC) || (defined(__GNUC__) && defined(__sun__))
-typedef uint8_t u_int8_t;
-typedef uint16_t u_int16_t;
-typedef uint32_t u_int32_t;
-typedef uint64_t u_int64_t;
-#endif
-
 #else  /* !_WIN32 */
 
+#if _MSC_VER >= 1600
+#include <stdint.h>
+#elif defined(BREAKPAD_CUSTOM_STDINT_H)
+/* Visual C++ Pre-2010 did not ship a stdint.h, so allow
+ * consumers of this library to provide their own because
+ * there are often subtle type incompatibilities.
+ */
+#include BREAKPAD_CUSTOM_STDINT_H
+#else
 #include <WTypes.h>
 
-typedef unsigned __int8  u_int8_t;
-typedef unsigned __int16 u_int16_t;
-typedef unsigned __int32 u_int32_t;
-typedef unsigned __int64 u_int64_t;
+typedef unsigned __int8  uint8_t;
+typedef unsigned __int16 uint16_t;
+typedef unsigned __int32 uint32_t;
+typedef unsigned __int64 uint64_t;
+#endif
 
 #endif  /* !_WIN32 */
 
 typedef struct {
-  u_int64_t high;
-  u_int64_t low;
-} u_int128_t;
+  uint64_t high;
+  uint64_t low;
+} uint128_t;
 
-typedef u_int64_t breakpad_time_t;
+typedef uint64_t breakpad_time_t;
 
 /* Try to get PRIx64 from inttypes.h, but if it's not defined, fall back to
  * llx, which is the format string for "long long" - this is a 64-bit
  * integral type on many systems. */
 #ifndef PRIx64
 #define PRIx64 "llx"
 #endif  /* !PRIx64 */
 
diff --git a/src/google_breakpad/common/minidump_cpu_amd64.h b/src/google_breakpad/common/minidump_cpu_amd64.h
--- a/src/google_breakpad/common/minidump_cpu_amd64.h
+++ b/src/google_breakpad/common/minidump_cpu_amd64.h
@@ -74,134 +74,134 @@
 #define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_AMD64_H__
 
 
 /*
  * AMD64 support, see WINNT.H
  */
 
 typedef struct {
-  u_int16_t  control_word;
-  u_int16_t  status_word;
-  u_int8_t   tag_word;
-  u_int8_t   reserved1;
-  u_int16_t  error_opcode;
-  u_int32_t  error_offset;
-  u_int16_t  error_selector;
-  u_int16_t  reserved2;
-  u_int32_t  data_offset;
-  u_int16_t  data_selector;
-  u_int16_t  reserved3;
-  u_int32_t  mx_csr;
-  u_int32_t  mx_csr_mask;
-  u_int128_t float_registers[8];
-  u_int128_t xmm_registers[16];
-  u_int8_t   reserved4[96];
+  uint16_t  control_word;
+  uint16_t  status_word;
+  uint8_t   tag_word;
+  uint8_t   reserved1;
+  uint16_t  error_opcode;
+  uint32_t  error_offset;
+  uint16_t  error_selector;
+  uint16_t  reserved2;
+  uint32_t  data_offset;
+  uint16_t  data_selector;
+  uint16_t  reserved3;
+  uint32_t  mx_csr;
+  uint32_t  mx_csr_mask;
+  uint128_t float_registers[8];
+  uint128_t xmm_registers[16];
+  uint8_t   reserved4[96];
 } MDXmmSaveArea32AMD64;  /* XMM_SAVE_AREA32 */
 
 #define MD_CONTEXT_AMD64_VR_COUNT 26
 
 typedef struct {
   /*
    * Register parameter home addresses.
    */
-  u_int64_t  p1_home;
-  u_int64_t  p2_home;
-  u_int64_t  p3_home;
-  u_int64_t  p4_home;
-  u_int64_t  p5_home;
-  u_int64_t  p6_home;
+  uint64_t  p1_home;
+  uint64_t  p2_home;
+  uint64_t  p3_home;
+  uint64_t  p4_home;
+  uint64_t  p5_home;
+  uint64_t  p6_home;
 
   /* The next field determines the layout of the structure, and which parts
    * of it are populated */
-  u_int32_t  context_flags;
-  u_int32_t  mx_csr;
+  uint32_t  context_flags;
+  uint32_t  mx_csr;
 
   /* The next register is included with MD_CONTEXT_AMD64_CONTROL */
-  u_int16_t  cs;
+  uint16_t  cs;
 
   /* The next 4 registers are included with MD_CONTEXT_AMD64_SEGMENTS */
-  u_int16_t  ds;
-  u_int16_t  es;
-  u_int16_t  fs;
-  u_int16_t  gs;
+  uint16_t  ds;
+  uint16_t  es;
+  uint16_t  fs;
+  uint16_t  gs;
 
   /* The next 2 registers are included with MD_CONTEXT_AMD64_CONTROL */
-  u_int16_t  ss;
-  u_int32_t  eflags;
+  uint16_t  ss;
+  uint32_t  eflags;
   
   /* The next 6 registers are included with MD_CONTEXT_AMD64_DEBUG_REGISTERS */
-  u_int64_t  dr0;
-  u_int64_t  dr1;
-  u_int64_t  dr2;
-  u_int64_t  dr3;
-  u_int64_t  dr6;
-  u_int64_t  dr7;
+  uint64_t  dr0;
+  uint64_t  dr1;
+  uint64_t  dr2;
+  uint64_t  dr3;
+  uint64_t  dr6;
+  uint64_t  dr7;
 
   /* The next 4 registers are included with MD_CONTEXT_AMD64_INTEGER */
-  u_int64_t  rax;
-  u_int64_t  rcx;
-  u_int64_t  rdx;
-  u_int64_t  rbx;
+  uint64_t  rax;
+  uint64_t  rcx;
+  uint64_t  rdx;
+  uint64_t  rbx;
 
   /* The next register is included with MD_CONTEXT_AMD64_CONTROL */
-  u_int64_t  rsp;
+  uint64_t  rsp;
 
   /* The next 11 registers are included with MD_CONTEXT_AMD64_INTEGER */
-  u_int64_t  rbp;
-  u_int64_t  rsi;
-  u_int64_t  rdi;
-  u_int64_t  r8;
-  u_int64_t  r9;
-  u_int64_t  r10;
-  u_int64_t  r11;
-  u_int64_t  r12;
-  u_int64_t  r13;
-  u_int64_t  r14;
-  u_int64_t  r15;
+  uint64_t  rbp;
+  uint64_t  rsi;
+  uint64_t  rdi;
+  uint64_t  r8;
+  uint64_t  r9;
+  uint64_t  r10;
+  uint64_t  r11;
+  uint64_t  r12;
+  uint64_t  r13;
+  uint64_t  r14;
+  uint64_t  r15;
 
   /* The next register is included with MD_CONTEXT_AMD64_CONTROL */
-  u_int64_t  rip;
+  uint64_t  rip;
 
   /* The next set of registers are included with
    * MD_CONTEXT_AMD64_FLOATING_POINT
    */
   union {
     MDXmmSaveArea32AMD64 flt_save;
     struct {
-      u_int128_t header[2];
-      u_int128_t legacy[8];
-      u_int128_t xmm0;
-      u_int128_t xmm1;
-      u_int128_t xmm2;
-      u_int128_t xmm3;
-      u_int128_t xmm4;
-      u_int128_t xmm5;
-      u_int128_t xmm6;
-      u_int128_t xmm7;
-      u_int128_t xmm8;
-      u_int128_t xmm9;
-      u_int128_t xmm10;
-      u_int128_t xmm11;
-      u_int128_t xmm12;
-      u_int128_t xmm13;
-      u_int128_t xmm14;
-      u_int128_t xmm15;
+      uint128_t header[2];
+      uint128_t legacy[8];
+      uint128_t xmm0;
+      uint128_t xmm1;
+      uint128_t xmm2;
+      uint128_t xmm3;
+      uint128_t xmm4;
+      uint128_t xmm5;
+      uint128_t xmm6;
+      uint128_t xmm7;
+      uint128_t xmm8;
+      uint128_t xmm9;
+      uint128_t xmm10;
+      uint128_t xmm11;
+      uint128_t xmm12;
+      uint128_t xmm13;
+      uint128_t xmm14;
+      uint128_t xmm15;
     } sse_registers;
   };
 
-  u_int128_t vector_register[MD_CONTEXT_AMD64_VR_COUNT];
-  u_int64_t  vector_control;
+  uint128_t vector_register[MD_CONTEXT_AMD64_VR_COUNT];
+  uint64_t  vector_control;
 
   /* The next 5 registers are included with MD_CONTEXT_AMD64_DEBUG_REGISTERS */
-  u_int64_t debug_control;
-  u_int64_t last_branch_to_rip;
-  u_int64_t last_branch_from_rip;
-  u_int64_t last_exception_to_rip;
-  u_int64_t last_exception_from_rip;
+  uint64_t debug_control;
+  uint64_t last_branch_to_rip;
+  uint64_t last_branch_from_rip;
+  uint64_t last_exception_to_rip;
+  uint64_t last_exception_from_rip;
   
 } MDRawContextAMD64;  /* CONTEXT */
 
 /* For (MDRawContextAMD64).context_flags.  These values indicate the type of
  * context stored in the structure.  The high 24 bits identify the CPU, the
  * low 8 bits identify the type of context saved. */
 #define MD_CONTEXT_AMD64 0x00100000  /* CONTEXT_AMD64 */
 #define MD_CONTEXT_AMD64_CONTROL         (MD_CONTEXT_AMD64 | 0x00000001)
diff --git a/src/google_breakpad/common/minidump_cpu_arm.h b/src/google_breakpad/common/minidump_cpu_arm.h
--- a/src/google_breakpad/common/minidump_cpu_arm.h
+++ b/src/google_breakpad/common/minidump_cpu_arm.h
@@ -72,49 +72,49 @@
 /*
  * Note that these structures *do not* map directly to the CONTEXT
  * structure defined in WinNT.h in the Windows Mobile SDK. That structure
  * does not accomodate VFPv3, and I'm unsure if it was ever used in the
  * wild anyway, as Windows CE only seems to produce "cedumps" which
  * are not exactly minidumps.
  */
 typedef struct {
-  u_int64_t	fpscr;      /* FPU status register */
+  uint64_t	fpscr;      /* FPU status register */
 
   /* 32 64-bit floating point registers, d0 .. d31. */
-  u_int64_t	regs[MD_FLOATINGSAVEAREA_ARM_FPR_COUNT];
+  uint64_t	regs[MD_FLOATINGSAVEAREA_ARM_FPR_COUNT];
 
   /* Miscellaneous control words */
-  u_int32_t     extra[MD_FLOATINGSAVEAREA_ARM_FPEXTRA_COUNT];
+  uint32_t     extra[MD_FLOATINGSAVEAREA_ARM_FPEXTRA_COUNT];
 } MDFloatingSaveAreaARM;
 
 #define MD_CONTEXT_ARM_GPR_COUNT 16
 
 typedef struct {
   /* The next field determines the layout of the structure, and which parts
    * of it are populated
    */
-  u_int32_t	context_flags;
+  uint32_t	context_flags;
 
   /* 16 32-bit integer registers, r0 .. r15
    * Note the following fixed uses:
    *   r13 is the stack pointer
    *   r14 is the link register
    *   r15 is the program counter
    */
-  u_int32_t     iregs[MD_CONTEXT_ARM_GPR_COUNT];
+  uint32_t     iregs[MD_CONTEXT_ARM_GPR_COUNT];
 
   /* CPSR (flags, basically): 32 bits:
         bit 31 - N (negative)
         bit 30 - Z (zero)
         bit 29 - C (carry)
         bit 28 - V (overflow)
         bit 27 - Q (saturation flag, sticky)
      All other fields -- ignore */
-  u_int32_t    cpsr;
+  uint32_t    cpsr;
 
   /* The next field is included with MD_CONTEXT_ARM_FLOATING_POINT */
   MDFloatingSaveAreaARM float_save;
 
 } MDRawContextARM;
 
 /* Indices into iregs for registers with a dedicated or conventional 
  * purpose.
diff --git a/src/google_breakpad/common/minidump_cpu_ppc.h b/src/google_breakpad/common/minidump_cpu_ppc.h
--- a/src/google_breakpad/common/minidump_cpu_ppc.h
+++ b/src/google_breakpad/common/minidump_cpu_ppc.h
@@ -76,34 +76,34 @@
  */
 
 #ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_PPC_H__
 #define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_PPC_H__
 
 #define MD_FLOATINGSAVEAREA_PPC_FPR_COUNT 32
 
 typedef struct {
-  /* fpregs is a double[32] in mach/ppc/_types.h, but a u_int64_t is used
+  /* fpregs is a double[32] in mach/ppc/_types.h, but a uint64_t is used
    * here for precise sizing. */
-  u_int64_t fpregs[MD_FLOATINGSAVEAREA_PPC_FPR_COUNT];
-  u_int32_t fpscr_pad;
-  u_int32_t fpscr;      /* Status/control */
+  uint64_t fpregs[MD_FLOATINGSAVEAREA_PPC_FPR_COUNT];
+  uint32_t fpscr_pad;
+  uint32_t fpscr;      /* Status/control */
 } MDFloatingSaveAreaPPC;  /* Based on ppc_float_state */
 
 
 #define MD_VECTORSAVEAREA_PPC_VR_COUNT 32
 
 typedef struct {
   /* Vector registers (including vscr) are 128 bits, but mach/ppc/_types.h
    * exposes them as four 32-bit quantities. */
-  u_int128_t save_vr[MD_VECTORSAVEAREA_PPC_VR_COUNT];
-  u_int128_t save_vscr;  /* Status/control */
-  u_int32_t  save_pad5[4];
-  u_int32_t  save_vrvalid;  /* Identifies which vector registers are saved */
-  u_int32_t  save_pad6[7];
+  uint128_t save_vr[MD_VECTORSAVEAREA_PPC_VR_COUNT];
+  uint128_t save_vscr;  /* Status/control */
+  uint32_t  save_pad5[4];
+  uint32_t  save_vrvalid;  /* Identifies which vector registers are saved */
+  uint32_t  save_pad6[7];
 } MDVectorSaveAreaPPC;  /* ppc_vector_state */
 
 
 #define MD_CONTEXT_PPC_GPR_COUNT 32
 
 /* Use the same 32-bit alignment when accessing this structure from 64-bit code
  * as is used natively in 32-bit code.  #pragma pack is a MSVC extension
  * supported by gcc. */
@@ -112,31 +112,31 @@
 #else
 #pragma pack(push, 4)
 #endif
 
 typedef struct {
   /* context_flags is not present in ppc_thread_state, but it aids
    * identification of MDRawContextPPC among other raw context types,
    * and it guarantees alignment when we get to float_save. */
-  u_int32_t             context_flags;
+  uint32_t             context_flags;
 
-  u_int32_t             srr0;    /* Machine status save/restore: stores pc
+  uint32_t             srr0;    /* Machine status save/restore: stores pc
                                   * (instruction) */
-  u_int32_t             srr1;    /* Machine status save/restore: stores msr
+  uint32_t             srr1;    /* Machine status save/restore: stores msr
                                   * (ps, program/machine state) */
   /* ppc_thread_state contains 32 fields, r0 .. r31.  Here, an array is
    * used for brevity. */
-  u_int32_t             gpr[MD_CONTEXT_PPC_GPR_COUNT];
-  u_int32_t             cr;      /* Condition */
-  u_int32_t             xer;     /* Integer (fiXed-point) exception */
-  u_int32_t             lr;      /* Link */
-  u_int32_t             ctr;     /* Count */
-  u_int32_t             mq;      /* Multiply/Quotient (PPC 601, POWER only) */
-  u_int32_t             vrsave;  /* Vector save */
+  uint32_t             gpr[MD_CONTEXT_PPC_GPR_COUNT];
+  uint32_t             cr;      /* Condition */
+  uint32_t             xer;     /* Integer (fiXed-point) exception */
+  uint32_t             lr;      /* Link */
+  uint32_t             ctr;     /* Count */
+  uint32_t             mq;      /* Multiply/Quotient (PPC 601, POWER only) */
+  uint32_t             vrsave;  /* Vector save */
 
   /* float_save and vector_save aren't present in ppc_thread_state, but
    * are represented in separate structures that still define a thread's
    * context. */
   MDFloatingSaveAreaPPC float_save;
   MDVectorSaveAreaPPC   vector_save;
 } MDRawContextPPC;  /* Based on ppc_thread_state */
 
diff --git a/src/google_breakpad/common/minidump_cpu_ppc64.h b/src/google_breakpad/common/minidump_cpu_ppc64.h
--- a/src/google_breakpad/common/minidump_cpu_ppc64.h
+++ b/src/google_breakpad/common/minidump_cpu_ppc64.h
@@ -85,30 +85,30 @@
 typedef MDVectorSaveAreaPPC MDVectorSaveAreaPPC64;
 
 #define MD_CONTEXT_PPC64_GPR_COUNT MD_CONTEXT_PPC_GPR_COUNT
 
 typedef struct {
   /* context_flags is not present in ppc_thread_state, but it aids
    * identification of MDRawContextPPC among other raw context types,
    * and it guarantees alignment when we get to float_save. */
-  u_int64_t             context_flags;
+  uint64_t             context_flags;
 
-  u_int64_t             srr0;    /* Machine status save/restore: stores pc
+  uint64_t             srr0;    /* Machine status save/restore: stores pc
                                   * (instruction) */
-  u_int64_t             srr1;    /* Machine status save/restore: stores msr
+  uint64_t             srr1;    /* Machine status save/restore: stores msr
                                   * (ps, program/machine state) */
   /* ppc_thread_state contains 32 fields, r0 .. r31.  Here, an array is
    * used for brevity. */
-  u_int64_t             gpr[MD_CONTEXT_PPC64_GPR_COUNT];
-  u_int64_t             cr;      /* Condition */
-  u_int64_t             xer;     /* Integer (fiXed-point) exception */
-  u_int64_t             lr;      /* Link */
-  u_int64_t             ctr;     /* Count */
-  u_int64_t             vrsave;  /* Vector save */
+  uint64_t             gpr[MD_CONTEXT_PPC64_GPR_COUNT];
+  uint64_t             cr;      /* Condition */
+  uint64_t             xer;     /* Integer (fiXed-point) exception */
+  uint64_t             lr;      /* Link */
+  uint64_t             ctr;     /* Count */
+  uint64_t             vrsave;  /* Vector save */
 
   /* float_save and vector_save aren't present in ppc_thread_state, but
    * are represented in separate structures that still define a thread's
    * context. */
   MDFloatingSaveAreaPPC float_save;
   MDVectorSaveAreaPPC   vector_save;
 } MDRawContextPPC64;  /* Based on ppc_thread_state */
 
diff --git a/src/google_breakpad/common/minidump_cpu_sparc.h b/src/google_breakpad/common/minidump_cpu_sparc.h
--- a/src/google_breakpad/common/minidump_cpu_sparc.h
+++ b/src/google_breakpad/common/minidump_cpu_sparc.h
@@ -77,66 +77,66 @@
 #ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_SPARC_H__
 #define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_SPARC_H__
 
 #define MD_FLOATINGSAVEAREA_SPARC_FPR_COUNT 32
 
 typedef struct {
 
   /* FPU floating point regs */
-  u_int64_t	regs[MD_FLOATINGSAVEAREA_SPARC_FPR_COUNT];
+  uint64_t	regs[MD_FLOATINGSAVEAREA_SPARC_FPR_COUNT];
 
-  u_int64_t	filler;
-  u_int64_t	fsr;        /* FPU status register */
+  uint64_t	filler;
+  uint64_t	fsr;        /* FPU status register */
 } MDFloatingSaveAreaSPARC;  /* FLOATING_SAVE_AREA */
 
 #define MD_CONTEXT_SPARC_GPR_COUNT 32
 
 typedef struct {
   /* The next field determines the layout of the structure, and which parts
    * of it are populated
    */
-  u_int32_t	context_flags;
-  u_int32_t	flag_pad;
+  uint32_t	context_flags;
+  uint32_t	flag_pad;
   /*
    * General register access (SPARC).
    * Don't confuse definitions here with definitions in <sys/regset.h>.
    * Registers are 32 bits for ILP32, 64 bits for LP64.
    * SPARC V7/V8 is for 32bit, SPARC V9 is for 64bit
    */
 
   /* 32 Integer working registers */
 
   /* g_r[0-7]   global registers(g0-g7)
    * g_r[8-15]  out registers(o0-o7)
    * g_r[16-23] local registers(l0-l7)
    * g_r[24-31] in registers(i0-i7)
    */
-  u_int64_t     g_r[MD_CONTEXT_SPARC_GPR_COUNT];
+  uint64_t     g_r[MD_CONTEXT_SPARC_GPR_COUNT];
 
   /* several control registers */
 
   /* Processor State register(PSR) for SPARC V7/V8
    * Condition Code register (CCR) for SPARC V9
    */
-  u_int64_t     ccr;
+  uint64_t     ccr;
 
-  u_int64_t     pc;     /* Program Counter register (PC) */
-  u_int64_t     npc;    /* Next Program Counter register (nPC) */
-  u_int64_t     y;      /* Y register (Y) */
+  uint64_t     pc;     /* Program Counter register (PC) */
+  uint64_t     npc;    /* Next Program Counter register (nPC) */
+  uint64_t     y;      /* Y register (Y) */
 
   /* Address Space Identifier register (ASI) for SPARC V9
    * WIM for SPARC V7/V8
    */
-  u_int64_t     asi;
+  uint64_t     asi;
 
   /* Floating-Point Registers State register (FPRS) for SPARC V9
    * TBR for for SPARC V7/V8
    */
-  u_int64_t     fprs;
+  uint64_t     fprs;
 
   /* The next field is included with MD_CONTEXT_SPARC_FLOATING_POINT */
   MDFloatingSaveAreaSPARC float_save;
 
 } MDRawContextSPARC;  /* CONTEXT_SPARC */
 
 /* For (MDRawContextSPARC).context_flags.  These values indicate the type of
  * context stored in the structure.  MD_CONTEXT_SPARC is Breakpad-defined.  Its
diff --git a/src/google_breakpad/common/minidump_cpu_x86.h b/src/google_breakpad/common/minidump_cpu_x86.h
--- a/src/google_breakpad/common/minidump_cpu_x86.h
+++ b/src/google_breakpad/common/minidump_cpu_x86.h
@@ -71,77 +71,77 @@
 
 #ifndef GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_X86_H__
 #define GOOGLE_BREAKPAD_COMMON_MINIDUMP_CPU_X86_H__
 
 #define MD_FLOATINGSAVEAREA_X86_REGISTERAREA_SIZE 80
      /* SIZE_OF_80387_REGISTERS */
 
 typedef struct {
-  u_int32_t control_word;
-  u_int32_t status_word;
-  u_int32_t tag_word;
-  u_int32_t error_offset;
-  u_int32_t error_selector;
-  u_int32_t data_offset;
-  u_int32_t data_selector;
+  uint32_t control_word;
+  uint32_t status_word;
+  uint32_t tag_word;
+  uint32_t error_offset;
+  uint32_t error_selector;
+  uint32_t data_offset;
+  uint32_t data_selector;
 
   /* register_area contains eight 80-bit (x87 "long double") quantities for
    * floating-point registers %st0 (%mm0) through %st7 (%mm7). */
-  u_int8_t  register_area[MD_FLOATINGSAVEAREA_X86_REGISTERAREA_SIZE];
-  u_int32_t cr0_npx_state;
+  uint8_t  register_area[MD_FLOATINGSAVEAREA_X86_REGISTERAREA_SIZE];
+  uint32_t cr0_npx_state;
 } MDFloatingSaveAreaX86;  /* FLOATING_SAVE_AREA */
 
 
 #define MD_CONTEXT_X86_EXTENDED_REGISTERS_SIZE 512
      /* MAXIMUM_SUPPORTED_EXTENSION */
 
 typedef struct {
   /* The next field determines the layout of the structure, and which parts
    * of it are populated */
-  u_int32_t             context_flags;
+  uint32_t             context_flags;
 
   /* The next 6 registers are included with MD_CONTEXT_X86_DEBUG_REGISTERS */
-  u_int32_t             dr0;
-  u_int32_t             dr1;
-  u_int32_t             dr2;
-  u_int32_t             dr3;
-  u_int32_t             dr6;
-  u_int32_t             dr7;
+  uint32_t             dr0;
+  uint32_t             dr1;
+  uint32_t             dr2;
+  uint32_t             dr3;
+  uint32_t             dr6;
+  uint32_t             dr7;
 
   /* The next field is included with MD_CONTEXT_X86_FLOATING_POINT */
   MDFloatingSaveAreaX86 float_save;
 
   /* The next 4 registers are included with MD_CONTEXT_X86_SEGMENTS */
-  u_int32_t             gs; 
-  u_int32_t             fs;
-  u_int32_t             es;
-  u_int32_t             ds;
+  uint32_t             gs; 
+  uint32_t             fs;
+  uint32_t             es;
+  uint32_t             ds;
   /* The next 6 registers are included with MD_CONTEXT_X86_INTEGER */
-  u_int32_t             edi;
-  u_int32_t             esi;
-  u_int32_t             ebx;
-  u_int32_t             edx;
-  u_int32_t             ecx;
-  u_int32_t             eax;
+  uint32_t             edi;
+  uint32_t             esi;
+  uint32_t             ebx;
+  uint32_t             edx;
+  uint32_t             ecx;
+  uint32_t             eax;
 
   /* The next 6 registers are included with MD_CONTEXT_X86_CONTROL */
-  u_int32_t             ebp;
-  u_int32_t             eip;
-  u_int32_t             cs;      /* WinNT.h says "must be sanitized" */
-  u_int32_t             eflags;  /* WinNT.h says "must be sanitized" */
-  u_int32_t             esp;
-  u_int32_t             ss;
+  uint32_t             ebp;
+  uint32_t             eip;
+  uint32_t             cs;      /* WinNT.h says "must be sanitized" */
+  uint32_t             eflags;  /* WinNT.h says "must be sanitized" */
+  uint32_t             esp;
+  uint32_t             ss;
 
   /* The next field is included with MD_CONTEXT_X86_EXTENDED_REGISTERS.
    * It contains vector (MMX/SSE) registers.  It it laid out in the
    * format used by the fxsave and fsrstor instructions, so it includes
    * a copy of the x87 floating-point registers as well.  See FXSAVE in
    * "Intel Architecture Software Developer's Manual, Volume 2." */
-  u_int8_t              extended_registers[
+  uint8_t              extended_registers[
                          MD_CONTEXT_X86_EXTENDED_REGISTERS_SIZE];
 } MDRawContextX86;  /* CONTEXT */
 
 /* For (MDRawContextX86).context_flags.  These values indicate the type of
  * context stored in the structure.  The high 24 bits identify the CPU, the
  * low 8 bits identify the type of context saved. */
 #define MD_CONTEXT_X86                    0x00010000
      /* CONTEXT_i386, CONTEXT_i486: identifies CPU */
diff --git a/src/google_breakpad/common/minidump_format.h b/src/google_breakpad/common/minidump_format.h
--- a/src/google_breakpad/common/minidump_format.h
+++ b/src/google_breakpad/common/minidump_format.h
@@ -74,20 +74,20 @@
 #endif  /* _MSC_VER */
 
 
 /*
  * guiddef.h
  */
 
 typedef struct {
-  u_int32_t data1;
-  u_int16_t data2;
-  u_int16_t data3;
-  u_int8_t  data4[8];
+  uint32_t data1;
+  uint16_t data2;
+  uint16_t data3;
+  uint8_t  data4[8];
 } MDGUID;  /* GUID */
 
 
 /*
  * WinNT.h
  */
 
 /* Non-x86 CPU identifiers found in the high 24 bits of
@@ -105,45 +105,45 @@
  * http://msdn.microsoft.com/en-us/library/hh134238%28v=vs.85%29.aspx */
 #define MD_CONTEXT_CPU_MASK 0xffffff00
 
 
 /* This is a base type for MDRawContextX86 and MDRawContextPPC.  This
  * structure should never be allocated directly.  The actual structure type
  * can be determined by examining the context_flags field. */
 typedef struct {
-  u_int32_t context_flags;
+  uint32_t context_flags;
 } MDRawContextBase;
 
 #include "minidump_cpu_amd64.h"
 #include "minidump_cpu_arm.h"
 #include "minidump_cpu_ppc.h"
 #include "minidump_cpu_ppc64.h"
 #include "minidump_cpu_sparc.h"
 #include "minidump_cpu_x86.h"
 
 /*
  * WinVer.h
  */
 
 
 typedef struct {
-  u_int32_t signature;
-  u_int32_t struct_version;
-  u_int32_t file_version_hi;
-  u_int32_t file_version_lo;
-  u_int32_t product_version_hi;
-  u_int32_t product_version_lo;
-  u_int32_t file_flags_mask;    /* Identifies valid bits in fileFlags */
-  u_int32_t file_flags;
-  u_int32_t file_os;
-  u_int32_t file_type;
-  u_int32_t file_subtype;
-  u_int32_t file_date_hi;
-  u_int32_t file_date_lo;
+  uint32_t signature;
+  uint32_t struct_version;
+  uint32_t file_version_hi;
+  uint32_t file_version_lo;
+  uint32_t product_version_hi;
+  uint32_t product_version_lo;
+  uint32_t file_flags_mask;    /* Identifies valid bits in fileFlags */
+  uint32_t file_flags;
+  uint32_t file_os;
+  uint32_t file_type;
+  uint32_t file_subtype;
+  uint32_t file_date_hi;
+  uint32_t file_date_lo;
 } MDVSFixedFileInfo;  /* VS_FIXEDFILEINFO */
 
 /* For (MDVSFixedFileInfo).signature */
 #define MD_VSFIXEDFILEINFO_SIGNATURE 0xfeef04bd
      /* VS_FFI_SIGNATURE */
 
 /* For (MDVSFixedFileInfo).version */
 #define MD_VSFIXEDFILEINFO_VERSION 0x00010000
@@ -226,43 +226,43 @@
 
 /*
  * DbgHelp.h
  */
 
 
 /* An MDRVA is an offset into the minidump file.  The beginning of the
  * MDRawHeader is at offset 0. */
-typedef u_int32_t MDRVA;  /* RVA */
+typedef uint32_t MDRVA;  /* RVA */
 
 typedef struct {
-  u_int32_t data_size;
+  uint32_t data_size;
   MDRVA     rva;
 } MDLocationDescriptor;  /* MINIDUMP_LOCATION_DESCRIPTOR */
 
 
 typedef struct {
   /* The base address of the memory range on the host that produced the
    * minidump. */
-  u_int64_t            start_of_memory_range;
+  uint64_t            start_of_memory_range;
 
   MDLocationDescriptor memory;
 } MDMemoryDescriptor;  /* MINIDUMP_MEMORY_DESCRIPTOR */
 
 
 typedef struct {
-  u_int32_t signature;
-  u_int32_t version;
-  u_int32_t stream_count;
+  uint32_t signature;
+  uint32_t version;
+  uint32_t stream_count;
   MDRVA     stream_directory_rva;  /* A |stream_count|-sized array of
                                     * MDRawDirectory structures. */
-  u_int32_t checksum;              /* Can be 0.  In fact, that's all that's
+  uint32_t checksum;              /* Can be 0.  In fact, that's all that's
                                     * been found in minidump files. */
-  u_int32_t time_date_stamp;       /* time_t */
-  u_int64_t flags;
+  uint32_t time_date_stamp;       /* time_t */
+  uint64_t flags;
 } MDRawHeader;  /* MINIDUMP_HEADER */
 
 /* For (MDRawHeader).signature and (MDRawHeader).version.  Note that only the
  * low 16 bits of (MDRawHeader).version are MD_HEADER_VERSION.  Per the
  * documentation, the high 16 bits are implementation-specific. */
 #define MD_HEADER_SIGNATURE 0x504d444d /* 'PMDM' */
      /* MINIDUMP_SIGNATURE */
 #define MD_HEADER_VERSION   0x0000a793 /* 42899 */
@@ -297,17 +297,17 @@
   MD_WITH_FULL_AUXILLIARY_STATE        = 0x00008000,
   MD_WITH_PRIVATE_WRITE_COPY_MEMORY    = 0x00010000,
   MD_IGNORE_INACCESSIBLE_MEMORY        = 0x00020000,
   MD_WITH_TOKEN_INFORMATION            = 0x00040000
 } MDType;  /* MINIDUMP_TYPE */
 
 
 typedef struct {
-  u_int32_t            stream_type;
+  uint32_t            stream_type;
   MDLocationDescriptor location;
 } MDRawDirectory;  /* MINIDUMP_DIRECTORY */
 
 /* For (MDRawDirectory).stream_type */
 typedef enum {
   MD_UNUSED_STREAM               =  0,
   MD_RESERVED_STREAM_0           =  1,
   MD_RESERVED_STREAM_1           =  2,
@@ -341,49 +341,49 @@
   MD_LINUX_ENVIRON               = 0x47670007,  /* /proc/$x/environ   */
   MD_LINUX_AUXV                  = 0x47670008,  /* /proc/$x/auxv      */
   MD_LINUX_MAPS                  = 0x47670009,  /* /proc/$x/maps      */
   MD_LINUX_DSO_DEBUG             = 0x4767000A   /* MDRawDebug         */
 } MDStreamType;  /* MINIDUMP_STREAM_TYPE */
 
 
 typedef struct {
-  u_int32_t length;     /* Length of buffer in bytes (not characters),
+  uint32_t length;     /* Length of buffer in bytes (not characters),
                          * excluding 0-terminator */
-  u_int16_t buffer[1];  /* UTF-16-encoded, 0-terminated */
+  uint16_t buffer[1];  /* UTF-16-encoded, 0-terminated */
 } MDString;  /* MINIDUMP_STRING */
 
 static const size_t MDString_minsize = offsetof(MDString, buffer[0]);
 
 
 typedef struct {
-  u_int32_t            thread_id;
-  u_int32_t            suspend_count;
-  u_int32_t            priority_class;
-  u_int32_t            priority;
-  u_int64_t            teb;             /* Thread environment block */
+  uint32_t            thread_id;
+  uint32_t            suspend_count;
+  uint32_t            priority_class;
+  uint32_t            priority;
+  uint64_t            teb;             /* Thread environment block */
   MDMemoryDescriptor   stack;
   MDLocationDescriptor thread_context;  /* MDRawContext[CPU] */
 } MDRawThread;  /* MINIDUMP_THREAD */
 
 
 typedef struct {
-  u_int32_t   number_of_threads;
+  uint32_t   number_of_threads;
   MDRawThread threads[1];
 } MDRawThreadList;  /* MINIDUMP_THREAD_LIST */
 
 static const size_t MDRawThreadList_minsize = offsetof(MDRawThreadList,
                                                        threads[0]);
 
 
 typedef struct {
-  u_int64_t            base_of_image;
-  u_int32_t            size_of_image;
-  u_int32_t            checksum;         /* 0 if unknown */
-  u_int32_t            time_date_stamp;  /* time_t */
+  uint64_t            base_of_image;
+  uint32_t            size_of_image;
+  uint32_t            checksum;         /* 0 if unknown */
+  uint32_t            time_date_stamp;  /* time_t */
   MDRVA                module_name_rva;  /* MDString, pathname or filename */
   MDVSFixedFileInfo    version_info;
 
   /* The next field stores a CodeView record and is populated when a module's
    * debug information resides in a PDB file.  It identifies the PDB file. */
   MDLocationDescriptor cv_record;
 
   /* The next field is populated when a module's debug information resides
@@ -397,69 +397,69 @@
    * specifies full alignment of 64-bit quantities in structures (as ppc
    * does), there will be padding between miscRecord and reserved0.  If
    * 64-bit quantities can be aligned on 32-bit boundaries (as on x86),
    * this padding will not exist.  (Note that the structure up to this point
    * contains 1 64-bit member followed by 21 32-bit members.)
    * As a workaround, reserved0 and reserved1 are instead defined here as
    * four 32-bit quantities.  This should be harmless, as there are
    * currently no known uses for these fields. */
-  u_int32_t            reserved0[2];
-  u_int32_t            reserved1[2];
+  uint32_t            reserved0[2];
+  uint32_t            reserved1[2];
 } MDRawModule;  /* MINIDUMP_MODULE */
 
 /* The inclusion of a 64-bit type in MINIDUMP_MODULE forces the struct to
  * be tail-padded out to a multiple of 64 bits under some ABIs (such as PPC).
  * This doesn't occur on systems that don't tail-pad in this manner.  Define
  * this macro to be the usable size of the MDRawModule struct, and use it in
  * place of sizeof(MDRawModule). */
 #define MD_MODULE_SIZE 108
 
 
 /* (MDRawModule).cv_record can reference MDCVInfoPDB20 or MDCVInfoPDB70.
  * Ref.: http://www.debuginfo.com/articles/debuginfomatch.html
  * MDCVInfoPDB70 is the expected structure type with recent toolchains. */
 
 typedef struct {
-  u_int32_t signature;
-  u_int32_t offset;     /* Offset to debug data (expect 0 in minidump) */
+  uint32_t signature;
+  uint32_t offset;     /* Offset to debug data (expect 0 in minidump) */
 } MDCVHeader;
 
 typedef struct {
   MDCVHeader cv_header;
-  u_int32_t  signature;         /* time_t debug information created */
-  u_int32_t  age;               /* revision of PDB file */
-  u_int8_t   pdb_file_name[1];  /* Pathname or filename of PDB file */
+  uint32_t  signature;         /* time_t debug information created */
+  uint32_t  age;               /* revision of PDB file */
+  uint8_t   pdb_file_name[1];  /* Pathname or filename of PDB file */
 } MDCVInfoPDB20;
 
 static const size_t MDCVInfoPDB20_minsize = offsetof(MDCVInfoPDB20,
                                                      pdb_file_name[0]);
 
 #define MD_CVINFOPDB20_SIGNATURE 0x3031424e  /* cvHeader.signature = '01BN' */
 
 typedef struct {
-  u_int32_t cv_signature;
+  uint32_t cv_signature;
   MDGUID    signature;         /* GUID, identifies PDB file */
-  u_int32_t age;               /* Identifies incremental changes to PDB file */
-  u_int8_t  pdb_file_name[1];  /* Pathname or filename of PDB file,
+  uint32_t age;               /* Identifies incremental changes to PDB file */
+  uint8_t  pdb_file_name[1];  /* Pathname or filename of PDB file,
                                 * 0-terminated 8-bit character data (UTF-8?) */
 } MDCVInfoPDB70;
 
 static const size_t MDCVInfoPDB70_minsize = offsetof(MDCVInfoPDB70,
                                                      pdb_file_name[0]);
 
 #define MD_CVINFOPDB70_SIGNATURE 0x53445352  /* cvSignature = 'SDSR' */
 
 typedef struct {
-  u_int32_t data1[2];
-  u_int32_t data2;
-  u_int32_t data3;
-  u_int32_t data4;
-  u_int32_t data5[3];
-  u_int8_t extra[2];
+  uint32_t data1[2];
+  uint32_t data2;
+  uint32_t data3;
+  uint32_t data4;
+  uint32_t data5[3];
+  uint8_t extra[2];
 } MDCVInfoELF;
 
 /* In addition to the two CodeView record formats above, used for linking
  * to external pdb files, it is possible for debugging data to be carried
  * directly in the CodeView record itself.  These signature values will
  * be found in the first 4 bytes of the CodeView record.  Additional values
  * not commonly experienced in the wild are given by "Microsoft Symbol and
  * Type Information", http://www.x86.org/ftp/manuals/tools/sym.pdf, section
@@ -474,121 +474,121 @@
 
 #define MD_CVINFOUNKNOWN_SIGNATURE 0xffffffff  /* An unlikely value. */
 
 /* (MDRawModule).miscRecord can reference MDImageDebugMisc.  The Windows
  * structure is actually defined in WinNT.h.  This structure is effectively
  * obsolete with modules built by recent toolchains. */
 
 typedef struct {
-  u_int32_t data_type;    /* IMAGE_DEBUG_TYPE_*, not defined here because
+  uint32_t data_type;    /* IMAGE_DEBUG_TYPE_*, not defined here because
                            * this debug record type is mostly obsolete. */
-  u_int32_t length;       /* Length of entire MDImageDebugMisc structure */
-  u_int8_t  unicode;      /* True if data is multibyte */
-  u_int8_t  reserved[3];
-  u_int8_t  data[1];
+  uint32_t length;       /* Length of entire MDImageDebugMisc structure */
+  uint8_t  unicode;      /* True if data is multibyte */
+  uint8_t  reserved[3];
+  uint8_t  data[1];
 } MDImageDebugMisc;  /* IMAGE_DEBUG_MISC */
 
 static const size_t MDImageDebugMisc_minsize = offsetof(MDImageDebugMisc,
                                                         data[0]);
 
 
 typedef struct {
-  u_int32_t   number_of_modules;
+  uint32_t   number_of_modules;
   MDRawModule modules[1];
 } MDRawModuleList;  /* MINIDUMP_MODULE_LIST */
 
 static const size_t MDRawModuleList_minsize = offsetof(MDRawModuleList,
                                                        modules[0]);
 
 
 typedef struct {
-  u_int32_t          number_of_memory_ranges;
+  uint32_t          number_of_memory_ranges;
   MDMemoryDescriptor memory_ranges[1];
 } MDRawMemoryList;  /* MINIDUMP_MEMORY_LIST */
 
 static const size_t MDRawMemoryList_minsize = offsetof(MDRawMemoryList,
                                                        memory_ranges[0]);
 
 
 #define MD_EXCEPTION_MAXIMUM_PARAMETERS 15
 
 typedef struct {
-  u_int32_t exception_code;     /* Windows: MDExceptionCodeWin,
+  uint32_t exception_code;     /* Windows: MDExceptionCodeWin,
                                  * Mac OS X: MDExceptionMac,
                                  * Linux: MDExceptionCodeLinux. */
-  u_int32_t exception_flags;    /* Windows: 1 if noncontinuable,
+  uint32_t exception_flags;    /* Windows: 1 if noncontinuable,
                                    Mac OS X: MDExceptionCodeMac. */
-  u_int64_t exception_record;   /* Address (in the minidump-producing host's
+  uint64_t exception_record;   /* Address (in the minidump-producing host's
                                  * memory) of another MDException, for
                                  * nested exceptions. */
-  u_int64_t exception_address;  /* The address that caused the exception.
+  uint64_t exception_address;  /* The address that caused the exception.
                                  * Mac OS X: exception subcode (which is
                                  *           typically the address). */
-  u_int32_t number_parameters;  /* Number of valid elements in
+  uint32_t number_parameters;  /* Number of valid elements in
                                  * exception_information. */
-  u_int32_t __align;
-  u_int64_t exception_information[MD_EXCEPTION_MAXIMUM_PARAMETERS];
+  uint32_t __align;
+  uint64_t exception_information[MD_EXCEPTION_MAXIMUM_PARAMETERS];
 } MDException;  /* MINIDUMP_EXCEPTION */
 
 #include "minidump_exception_win32.h"
 #include "minidump_exception_mac.h"
 #include "minidump_exception_linux.h"
 #include "minidump_exception_solaris.h"
 
 typedef struct {
-  u_int32_t            thread_id;         /* Thread in which the exception
+  uint32_t            thread_id;         /* Thread in which the exception
                                            * occurred.  Corresponds to
                                            * (MDRawThread).thread_id. */
-  u_int32_t            __align;
+  uint32_t            __align;
   MDException          exception_record;
   MDLocationDescriptor thread_context;    /* MDRawContext[CPU] */
 } MDRawExceptionStream;  /* MINIDUMP_EXCEPTION_STREAM */
 
 
 typedef union {
   struct {
-    u_int32_t vendor_id[3];               /* cpuid 0: ebx, edx, ecx */
-    u_int32_t version_information;        /* cpuid 1: eax */
-    u_int32_t feature_information;        /* cpuid 1: edx */
-    u_int32_t amd_extended_cpu_features;  /* cpuid 0x80000001, ebx */
+    uint32_t vendor_id[3];               /* cpuid 0: ebx, edx, ecx */
+    uint32_t version_information;        /* cpuid 1: eax */
+    uint32_t feature_information;        /* cpuid 1: edx */
+    uint32_t amd_extended_cpu_features;  /* cpuid 0x80000001, ebx */
   } x86_cpu_info;
   struct {
-    u_int64_t processor_features[2];
+    uint64_t processor_features[2];
   } other_cpu_info;
 } MDCPUInformation;  /* CPU_INFORMATION */
 
 
 typedef struct {
   /* The next 3 fields and numberOfProcessors are from the SYSTEM_INFO
    * structure as returned by GetSystemInfo */
-  u_int16_t        processor_architecture;
-  u_int16_t        processor_level;         /* x86: 5 = 586, 6 = 686, ... */
-  u_int16_t        processor_revision;      /* x86: 0xMMSS, where MM=model,
+  uint16_t        processor_architecture;
+  uint16_t        processor_level;         /* x86: 5 = 586, 6 = 686, ... */
+  uint16_t        processor_revision;      /* x86: 0xMMSS, where MM=model,
                                              *      SS=stepping */
 
-  u_int8_t         number_of_processors;
-  u_int8_t         product_type;            /* Windows: VER_NT_* from WinNT.h */
+  uint8_t         number_of_processors;
+  uint8_t         product_type;            /* Windows: VER_NT_* from WinNT.h */
 
   /* The next 5 fields are from the OSVERSIONINFO structure as returned
    * by GetVersionEx */
-  u_int32_t        major_version;
-  u_int32_t        minor_version;
-  u_int32_t        build_number;
-  u_int32_t        platform_id;
+  uint32_t        major_version;
+  uint32_t        minor_version;
+  uint32_t        build_number;
+  uint32_t        platform_id;
   MDRVA            csd_version_rva;  /* MDString further identifying the
                                       * host OS.
                                       * Windows: name of the installed OS
                                       *          service pack.
                                       * Mac OS X: the Apple OS build number
                                       *           (sw_vers -buildVersion).
                                       * Linux: uname -srvmo */
 
-  u_int16_t        suite_mask;       /* Windows: VER_SUITE_* from WinNT.h */
-  u_int16_t        reserved2;
+  uint16_t        suite_mask;       /* Windows: VER_SUITE_* from WinNT.h */
+  uint16_t        reserved2;
 
   MDCPUInformation cpu;
 } MDRawSystemInfo;  /* MINIDUMP_SYSTEM_INFO */
 
 /* For (MDRawSystemInfo).processor_architecture: */
 typedef enum {
   MD_CPU_ARCHITECTURE_X86       =  0,  /* PROCESSOR_ARCHITECTURE_INTEL */
   MD_CPU_ARCHITECTURE_MIPS      =  1,  /* PROCESSOR_ARCHITECTURE_MIPS */
@@ -622,39 +622,39 @@
   MD_OS_IOS           = 0x8102,  /* iOS */
   MD_OS_LINUX         = 0x8201,  /* Linux */
   MD_OS_SOLARIS       = 0x8202,  /* Solaris */
   MD_OS_ANDROID       = 0x8203   /* Android */
 } MDOSPlatform;
 
 
 typedef struct {
-  u_int32_t size_of_info;  /* Length of entire MDRawMiscInfo structure. */
-  u_int32_t flags1;
+  uint32_t size_of_info;  /* Length of entire MDRawMiscInfo structure. */
+  uint32_t flags1;
 
   /* The next field is only valid if flags1 contains
    * MD_MISCINFO_FLAGS1_PROCESS_ID. */
-  u_int32_t process_id;
+  uint32_t process_id;
 
   /* The next 3 fields are only valid if flags1 contains
    * MD_MISCINFO_FLAGS1_PROCESS_TIMES. */
-  u_int32_t process_create_time;  /* time_t process started */
-  u_int32_t process_user_time;    /* seconds of user CPU time */
-  u_int32_t process_kernel_time;  /* seconds of kernel CPU time */
+  uint32_t process_create_time;  /* time_t process started */
+  uint32_t process_user_time;    /* seconds of user CPU time */
+  uint32_t process_kernel_time;  /* seconds of kernel CPU time */
 
   /* The following fields are not present in MINIDUMP_MISC_INFO but are
    * in MINIDUMP_MISC_INFO_2.  When this struct is populated, these values
    * may not be set.  Use flags1 or sizeOfInfo to determine whether these
    * values are present.  These are only valid when flags1 contains
    * MD_MISCINFO_FLAGS1_PROCESSOR_POWER_INFO. */
-  u_int32_t processor_max_mhz;
-  u_int32_t processor_current_mhz;
-  u_int32_t processor_mhz_limit;
-  u_int32_t processor_max_idle_state;
-  u_int32_t processor_current_idle_state;
+  uint32_t processor_max_mhz;
+  uint32_t processor_current_mhz;
+  uint32_t processor_mhz_limit;
+  uint32_t processor_max_idle_state;
+  uint32_t processor_current_idle_state;
 } MDRawMiscInfo;  /* MINIDUMP_MISC_INFO, MINIDUMP_MISC_INFO2 */
 
 #define MD_MISCINFO_SIZE 24
 #define MD_MISCINFO2_SIZE 44
 
 /* For (MDRawMiscInfo).flags1.  These values indicate which fields in the
  * MDRawMiscInfoStructure are valid. */
 typedef enum {
@@ -672,34 +672,34 @@
  * represent the variable-length data to including explicit
  * "size of header", "size of entry" and "number of entries" fields
  * in the header, presumably to allow backwards-compatibly-extending
  * the structures in the future. The actual list entries follow the
  * header data directly in this case.
  */
 
 typedef struct {
-  u_int32_t size_of_header;    /* sizeof(MDRawMemoryInfoList) */
-  u_int32_t size_of_entry;     /* sizeof(MDRawMemoryInfo) */
-  u_int64_t number_of_entries;
+  uint32_t size_of_header;    /* sizeof(MDRawMemoryInfoList) */
+  uint32_t size_of_entry;     /* sizeof(MDRawMemoryInfo) */
+  uint64_t number_of_entries;
 } MDRawMemoryInfoList;  /* MINIDUMP_MEMORY_INFO_LIST */
 
 typedef struct {
-  u_int64_t base_address;           /* Base address of a region of pages */
-  u_int64_t allocation_base;        /* Base address of a range of pages
+  uint64_t base_address;           /* Base address of a region of pages */
+  uint64_t allocation_base;        /* Base address of a range of pages
                                      * within this region. */
-  u_int32_t allocation_protection;  /* Memory protection when this region
+  uint32_t allocation_protection;  /* Memory protection when this region
                                      * was originally allocated:
                                      * MDMemoryProtection */
-  u_int32_t __alignment1;
-  u_int64_t region_size;
-  u_int32_t state;                  /* MDMemoryState */
-  u_int32_t protection;             /* MDMemoryProtection */
-  u_int32_t type;                   /* MDMemoryType */
-  u_int32_t __alignment2;
+  uint32_t __alignment1;
+  uint64_t region_size;
+  uint32_t state;                  /* MDMemoryState */
+  uint32_t protection;             /* MDMemoryProtection */
+  uint32_t type;                   /* MDMemoryType */
+  uint32_t __alignment2;
 } MDRawMemoryInfo;  /* MINIDUMP_MEMORY_INFO */
 
 /* For (MDRawMemoryInfo).state */
 typedef enum {
   MD_MEMORY_STATE_COMMIT   = 0x1000,  /* physical storage has been allocated */
   MD_MEMORY_STATE_RESERVE  = 0x2000,  /* reserved, but no physical storage */
   MD_MEMORY_STATE_FREE     = 0x10000  /* available to be allocated */
 } MDMemoryState;
@@ -716,55 +716,55 @@
   MD_MEMORY_PROTECT_EXECUTE_WRITECOPY = 0x80,  /* PAGE_EXECUTE_WRITECOPY */
   /* These options can be combined with the previous flags. */
   MD_MEMORY_PROTECT_GUARD             = 0x100,  /* PAGE_GUARD */
   MD_MEMORY_PROTECT_NOCACHE           = 0x200,  /* PAGE_NOCACHE */
   MD_MEMORY_PROTECT_WRITECOMBINE      = 0x400,  /* PAGE_WRITECOMBINE */
 } MDMemoryProtection;
 
 /* Used to mask the mutually exclusive options from the combinable flags. */
-const u_int32_t MD_MEMORY_PROTECTION_ACCESS_MASK = 0xFF;
+const uint32_t MD_MEMORY_PROTECTION_ACCESS_MASK = 0xFF;
 
 /* For (MDRawMemoryInfo).type */
 typedef enum {
   MD_MEMORY_TYPE_PRIVATE = 0x20000,   /* not shared by other processes */
   MD_MEMORY_TYPE_MAPPED  = 0x40000,   /* mapped into the view of a section */
   MD_MEMORY_TYPE_IMAGE   = 0x1000000  /* mapped into the view of an image */
 } MDMemoryType;
 
 /*
  * Breakpad extension types
  */
 
 
 typedef struct {
   /* validity is a bitmask with values from MDBreakpadInfoValidity, indicating
    * which of the other fields in the structure are valid. */
-  u_int32_t validity;
+  uint32_t validity;
 
   /* Thread ID of the handler thread.  dump_thread_id should correspond to
    * the thread_id of an MDRawThread in the minidump's MDRawThreadList if
    * a dedicated thread in that list was used to produce the minidump.  If
    * the MDRawThreadList does not contain a dedicated thread used to produce
    * the minidump, this field should be set to 0 and the validity field
    * must not contain MD_BREAKPAD_INFO_VALID_DUMP_THREAD_ID. */
-  u_int32_t dump_thread_id;
+  uint32_t dump_thread_id;
 
   /* Thread ID of the thread that requested the minidump be produced.  As
    * with dump_thread_id, requesting_thread_id should correspond to the
    * thread_id of an MDRawThread in the minidump's MDRawThreadList.  For
    * minidumps produced as a result of an exception, requesting_thread_id
    * will be the same as the MDRawExceptionStream's thread_id field.  For
    * minidumps produced "manually" at the program's request,
    * requesting_thread_id will indicate which thread caused the dump to be
    * written.  If the minidump was produced at the request of something
    * other than a thread in the MDRawThreadList, this field should be set
    * to 0 and the validity field must not contain
    * MD_BREAKPAD_INFO_VALID_REQUESTING_THREAD_ID. */
-  u_int32_t requesting_thread_id;
+  uint32_t requesting_thread_id;
 } MDRawBreakpadInfo;
 
 /* For (MDRawBreakpadInfo).validity: */
 typedef enum {
   /* When set, the dump_thread_id field is valid. */
   MD_BREAKPAD_INFO_VALID_DUMP_THREAD_ID       = 1 << 0,
 
   /* When set, the requesting_thread_id field is valid. */
@@ -772,21 +772,21 @@
 } MDBreakpadInfoValidity;
 
 typedef struct {
   /* expression, function, and file are 0-terminated UTF-16 strings.  They
    * may be truncated if necessary, but should always be 0-terminated when
    * written to a file.
    * Fixed-length strings are used because MiniDumpWriteDump doesn't offer
    * a way for user streams to point to arbitrary RVAs for strings. */
-  u_int16_t expression[128];  /* Assertion that failed... */
-  u_int16_t function[128];    /* ...within this function... */
-  u_int16_t file[128];        /* ...in this file... */
-  u_int32_t line;             /* ...at this line. */
-  u_int32_t type;
+  uint16_t expression[128];  /* Assertion that failed... */
+  uint16_t function[128];    /* ...within this function... */
+  uint16_t file[128];        /* ...in this file... */
+  uint32_t line;             /* ...at this line. */
+  uint32_t type;
 } MDRawAssertionInfo;
 
 /* For (MDRawAssertionInfo).type: */
 typedef enum {
   MD_ASSERTION_INFO_TYPE_UNKNOWN = 0,
 
   /* Used for assertions that would be raised by the MSVC CRT but are
    * directed to an invalid parameter handler instead. */
@@ -801,19 +801,19 @@
  * which is necessary for converting minidumps to usable coredumps. */
 typedef struct {
   void*     addr;
   MDRVA     name;
   void*     ld;
 } MDRawLinkMap;
 
 typedef struct {
-  u_int32_t version;
+  uint32_t version;
   MDRVA     map;
-  u_int32_t dso_count;
+  uint32_t dso_count;
   void*     brk;
   void*     ldbase;
   void*     dynamic;
 } MDRawDebug;
 
 #if defined(_MSC_VER)
 #pragma warning(pop)
 #endif  /* _MSC_VER */
diff --git a/src/google_breakpad/processor/code_module.h b/src/google_breakpad/processor/code_module.h
--- a/src/google_breakpad/processor/code_module.h
+++ b/src/google_breakpad/processor/code_module.h
@@ -42,21 +42,21 @@
 
 namespace google_breakpad {
 
 class CodeModule {
  public:
   virtual ~CodeModule() {}
 
   // The base address of this code module as it was loaded by the process.
-  // (u_int64_t)-1 on error.
-  virtual u_int64_t base_address() const = 0;
+  // (uint64_t)-1 on error.
+  virtual uint64_t base_address() const = 0;
 
   // The size of the code module.  0 on error.
-  virtual u_int64_t size() const = 0;
+  virtual uint64_t size() const = 0;
 
   // The path or file name that the code module was loaded from.  Empty on
   // error.
   virtual string code_file() const = 0;
 
   // An identifying string used to discriminate between multiple versions and
   // builds of the same code module.  This may contain a uuid, timestamp,
   // version number, or any combination of this or other information, in an
diff --git a/src/google_breakpad/processor/code_modules.h b/src/google_breakpad/processor/code_modules.h
--- a/src/google_breakpad/processor/code_modules.h
+++ b/src/google_breakpad/processor/code_modules.h
@@ -48,17 +48,17 @@
   // The number of contained CodeModule objects.
   virtual unsigned int module_count() const = 0;
 
   // Random access to modules.  Returns the module whose code is present
   // at the address indicated by |address|.  If no module is present at this
   // address, returns NULL.  Ownership of the returned CodeModule is retained
   // by the CodeModules object; pointers returned by this method are valid for
   // comparison with pointers returned by the other Get methods.
-  virtual const CodeModule* GetModuleForAddress(u_int64_t address) const = 0;
+  virtual const CodeModule* GetModuleForAddress(uint64_t address) const = 0;
 
   // Returns the module corresponding to the main executable.  If there is
   // no main executable, returns NULL.  Ownership of the returned CodeModule
   // is retained by the CodeModules object; pointers returned by this method
   // are valid for comparison with pointers returned by the other Get
   // methods.
   virtual const CodeModule* GetMainModule() const = 0;
 
diff --git a/src/google_breakpad/processor/exploitability.h b/src/google_breakpad/processor/exploitability.h
--- a/src/google_breakpad/processor/exploitability.h
+++ b/src/google_breakpad/processor/exploitability.h
@@ -49,17 +49,17 @@
 class Exploitability {
  public:
   virtual ~Exploitability() {}
 
   static Exploitability *ExploitabilityForPlatform(Minidump *dump,
                                                    ProcessState *process_state);
 
   ExploitabilityRating CheckExploitability();
-  bool AddressIsAscii(u_int64_t);
+  bool AddressIsAscii(uint64_t);
 
  protected:
   Exploitability(Minidump *dump,
                  ProcessState *process_state);
 
   Minidump *dump_;
   ProcessState *process_state_;
   SystemInfo *system_info_;
diff --git a/src/google_breakpad/processor/memory_region.h b/src/google_breakpad/processor/memory_region.h
--- a/src/google_breakpad/processor/memory_region.h
+++ b/src/google_breakpad/processor/memory_region.h
@@ -45,32 +45,32 @@
 namespace google_breakpad {
 
 
 class MemoryRegion {
  public:
   virtual ~MemoryRegion() {}
 
   // The base address of this memory region.
-  virtual u_int64_t GetBase() const = 0;
+  virtual uint64_t GetBase() const = 0;
 
   // The size of this memory region.
-  virtual u_int32_t GetSize() const = 0;
+  virtual uint32_t GetSize() const = 0;
 
   // Access to data of various sizes within the memory region.  address
   // is a pointer to read, and it must lie within the memory region as
   // defined by its base address and size.  The location pointed to by
   // value is set to the value at address.  Byte-swapping is performed
   // if necessary so that the value is appropriate for the running
   // program.  Returns true on success.  Fails and returns false if address
   // is out of the region's bounds (after considering the width of value),
   // or for other types of errors.
-  virtual bool GetMemoryAtAddress(u_int64_t address, u_int8_t*  value) const =0;
-  virtual bool GetMemoryAtAddress(u_int64_t address, u_int16_t* value) const =0;
-  virtual bool GetMemoryAtAddress(u_int64_t address, u_int32_t* value) const =0;
-  virtual bool GetMemoryAtAddress(u_int64_t address, u_int64_t* value) const =0;
+  virtual bool GetMemoryAtAddress(uint64_t address, uint8_t*  value) const =0;
+  virtual bool GetMemoryAtAddress(uint64_t address, uint16_t* value) const =0;
+  virtual bool GetMemoryAtAddress(uint64_t address, uint32_t* value) const =0;
+  virtual bool GetMemoryAtAddress(uint64_t address, uint64_t* value) const =0;
 };
 
 
 }  // namespace google_breakpad
 
 
 #endif  // GOOGLE_BREAKPAD_PROCESSOR_MEMORY_REGION_H__
diff --git a/src/google_breakpad/processor/minidump.h b/src/google_breakpad/processor/minidump.h
--- a/src/google_breakpad/processor/minidump.h
+++ b/src/google_breakpad/processor/minidump.h
@@ -149,17 +149,17 @@
  private:
   // Populate (and validate) the MinidumpStream.  minidump_ is expected
   // to be positioned at the beginning of the stream, so that the next
   // read from the minidump will be at the beginning of the stream.
   // expected_size should be set to the stream's length as contained in
   // the MDRawDirectory record or other identifying record.  A class
   // that implements MinidumpStream can compare expected_size to a
   // known size as an integrity check.
-  virtual bool Read(u_int32_t expected_size) = 0;
+  virtual bool Read(uint32_t expected_size) = 0;
 };
 
 
 // MinidumpContext carries a CPU-specific MDRawContext structure, which
 // contains CPU context such as register states.  Each thread has its
 // own context, and the exception record, if present, also has its own
 // context.  Note that if the exception record is present, the context it
 // refers to is probably what the user wants to use for the exception
@@ -171,21 +171,21 @@
 class MinidumpContext : public MinidumpStream {
  public:
   virtual ~MinidumpContext();
 
   // Returns an MD_CONTEXT_* value such as MD_CONTEXT_X86 or MD_CONTEXT_PPC
   // identifying the CPU type that the context was collected from.  The
   // returned value will identify the CPU only, and will have any other
   // MD_CONTEXT_* bits masked out.  Returns 0 on failure.
-  u_int32_t GetContextCPU() const;
+  uint32_t GetContextCPU() const;
 
   // A convenience method to get the instruction pointer out of the
   // MDRawContext, since it varies per-CPU architecture.
-  bool GetInstructionPointer(u_int64_t* ip) const;
+  bool GetInstructionPointer(uint64_t* ip) const;
 
   // Returns raw CPU-specific context data for the named CPU type.  If the
   // context data does not match the CPU type or does not exist, returns
   // NULL.
   const MDRawContextAMD64* GetContextAMD64() const;
   const MDRawContextARM*   GetContextARM() const;
   const MDRawContextPPC*   GetContextPPC() const;
   const MDRawContextSPARC* GetContextSPARC() const;
@@ -205,100 +205,100 @@
     MDRawContextAMD64* amd64;
     // on Solaris SPARC, sparc is defined as a numeric constant,
     // so variables can NOT be named as sparc
     MDRawContextSPARC* ctx_sparc;
     MDRawContextARM*   arm;
   } context_;
 
   // Store this separately because of the weirdo AMD64 context
-  u_int32_t context_flags_;
+  uint32_t context_flags_;
 
  private:
   friend class MinidumpThread;
   friend class MinidumpException;
 
-  bool Read(u_int32_t expected_size);
+  bool Read(uint32_t expected_size);
 
   // Free the CPU-specific context structure.
   void FreeContext();
 
   // If the minidump contains a SYSTEM_INFO_STREAM, makes sure that the
   // system info stream gives an appropriate CPU type matching the context
   // CPU type in context_cpu_type.  Returns false if the CPU type does not
   // match.  Returns true if the CPU type matches or if the minidump does
   // not contain a system info stream.
-  bool CheckAgainstSystemInfo(u_int32_t context_cpu_type);
+  bool CheckAgainstSystemInfo(uint32_t context_cpu_type);
 };
 
 
 // MinidumpMemoryRegion does not wrap any MDRaw structure, and only contains
 // a reference to an MDMemoryDescriptor.  This object is intended to wrap
 // portions of a minidump file that contain memory dumps.  In normal
 // minidumps, each MinidumpThread owns a MinidumpMemoryRegion corresponding
 // to the thread's stack memory.  MinidumpMemoryList also gives access to
 // memory regions in its list as MinidumpMemoryRegions.  This class
 // adheres to MemoryRegion so that it may be used as a data provider to
 // the Stackwalker family of classes.
 class MinidumpMemoryRegion : public MinidumpObject,
                              public MemoryRegion {
  public:
   virtual ~MinidumpMemoryRegion();
 
-  static void set_max_bytes(u_int32_t max_bytes) { max_bytes_ = max_bytes; }
-  static u_int32_t max_bytes() { return max_bytes_; }
+  static void set_max_bytes(uint32_t max_bytes) { max_bytes_ = max_bytes; }
+  static uint32_t max_bytes() { return max_bytes_; }
 
   // Returns a pointer to the base of the memory region.  Returns the
   // cached value if available, otherwise, reads the minidump file and
   // caches the memory region.
-  const u_int8_t* GetMemory() const;
+  const uint8_t* GetMemory() const;
 
   // The address of the base of the memory region.
-  u_int64_t GetBase() const;
+  uint64_t GetBase() const;
 
   // The size, in bytes, of the memory region.
-  u_int32_t GetSize() const;
+  uint32_t GetSize() const;
 
   // Frees the cached memory region, if cached.
   void FreeMemory();
 
   // Obtains the value of memory at the pointer specified by address.
-  bool GetMemoryAtAddress(u_int64_t address, u_int8_t*  value) const;
-  bool GetMemoryAtAddress(u_int64_t address, u_int16_t* value) const;
-  bool GetMemoryAtAddress(u_int64_t address, u_int32_t* value) const;
-  bool GetMemoryAtAddress(u_int64_t address, u_int64_t* value) const;
+  bool GetMemoryAtAddress(uint64_t address, uint8_t*  value) const;
+  bool GetMemoryAtAddress(uint64_t address, uint16_t* value) const;
+  bool GetMemoryAtAddress(uint64_t address, uint32_t* value) const;
+  bool GetMemoryAtAddress(uint64_t address, uint64_t* value) const;
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  protected:
   explicit MinidumpMemoryRegion(Minidump* minidump);
 
  private:
   friend class MinidumpThread;
   friend class MinidumpMemoryList;
 
   // Identify the base address and size of the memory region, and the
   // location it may be found in the minidump file.
   void SetDescriptor(MDMemoryDescriptor* descriptor);
 
   // Implementation for GetMemoryAtAddress
-  template<typename T> bool GetMemoryAtAddressInternal(u_int64_t address,
+  template<typename T> bool GetMemoryAtAddressInternal(uint64_t address,
                                                        T*        value) const;
 
   // The largest memory region that will be read from a minidump.  The
   // default is 1MB.
-  static u_int32_t max_bytes_;
+  static uint32_t max_bytes_;
 
   // Base address and size of the memory region, and its position in the
   // minidump file.
   MDMemoryDescriptor* descriptor_;
 
   // Cached memory.
-  mutable vector<u_int8_t>* memory_;
+  mutable vector<uint8_t>* memory_;
 };
 
 
 // MinidumpThread contains information about a thread of execution,
 // including a snapshot of the thread's stack and CPU context.  For
 // the thread that caused an exception, the context carried by
 // MinidumpException is probably desired instead of the CPU context
 // provided here.
@@ -314,17 +314,17 @@
   virtual MinidumpMemoryRegion* GetMemory();
   // GetContext may return NULL even if the MinidumpThread is valid.
   virtual MinidumpContext* GetContext();
 
   // The thread ID is used to determine if a thread is the exception thread,
   // so a special getter is provided to retrieve this data from the
   // MDRawThread structure.  Returns false if the thread ID cannot be
   // determined.
-  virtual bool GetThreadID(u_int32_t *thread_id) const;
+  virtual bool GetThreadID(uint32_t *thread_id) const;
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  protected:
   explicit MinidumpThread(Minidump* minidump);
 
  private:
@@ -343,111 +343,111 @@
 
 
 // MinidumpThreadList contains all of the threads (as MinidumpThreads) in
 // a process.
 class MinidumpThreadList : public MinidumpStream {
  public:
   virtual ~MinidumpThreadList();
 
-  static void set_max_threads(u_int32_t max_threads) {
+  static void set_max_threads(uint32_t max_threads) {
     max_threads_ = max_threads;
   }
-  static u_int32_t max_threads() { return max_threads_; }
+  static uint32_t max_threads() { return max_threads_; }
 
   virtual unsigned int thread_count() const {
     return valid_ ? thread_count_ : 0;
   }
 
   // Sequential access to threads.
   virtual MinidumpThread* GetThreadAtIndex(unsigned int index) const;
 
   // Random access to threads.
-  MinidumpThread* GetThreadByID(u_int32_t thread_id);
+  MinidumpThread* GetThreadByID(uint32_t thread_id);
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  protected:
   explicit MinidumpThreadList(Minidump* aMinidump);
 
  private:
   friend class Minidump;
 
-  typedef map<u_int32_t, MinidumpThread*> IDToThreadMap;
+  typedef map<uint32_t, MinidumpThread*> IDToThreadMap;
   typedef vector<MinidumpThread> MinidumpThreads;
 
-  static const u_int32_t kStreamType = MD_THREAD_LIST_STREAM;
+  static const uint32_t kStreamType = MD_THREAD_LIST_STREAM;
 
-  bool Read(u_int32_t aExpectedSize);
+  bool Read(uint32_t aExpectedSize);
 
   // The largest number of threads that will be read from a minidump.  The
   // default is 256.
-  static u_int32_t max_threads_;
+  static uint32_t max_threads_;
 
   // Access to threads using the thread ID as the key.
   IDToThreadMap    id_to_thread_map_;
 
   // The list of threads.
   MinidumpThreads* threads_;
-  u_int32_t        thread_count_;
+  uint32_t        thread_count_;
 };
 
 
 // MinidumpModule wraps MDRawModule, which contains information about loaded
 // code modules.  Access is provided to various data referenced indirectly
 // by MDRawModule, such as the module's name and a specification for where
 // to locate debugging information for the module.
 class MinidumpModule : public MinidumpObject,
                        public CodeModule {
  public:
   virtual ~MinidumpModule();
 
-  static void set_max_cv_bytes(u_int32_t max_cv_bytes) {
+  static void set_max_cv_bytes(uint32_t max_cv_bytes) {
     max_cv_bytes_ = max_cv_bytes;
   }
-  static u_int32_t max_cv_bytes() { return max_cv_bytes_; }
+  static uint32_t max_cv_bytes() { return max_cv_bytes_; }
 
-  static void set_max_misc_bytes(u_int32_t max_misc_bytes) {
+  static void set_max_misc_bytes(uint32_t max_misc_bytes) {
     max_misc_bytes_ = max_misc_bytes;
   }
-  static u_int32_t max_misc_bytes() { return max_misc_bytes_; }
+  static uint32_t max_misc_bytes() { return max_misc_bytes_; }
 
   const MDRawModule* module() const { return valid_ ? &module_ : NULL; }
 
   // CodeModule implementation
-  virtual u_int64_t base_address() const {
-    return valid_ ? module_.base_of_image : static_cast<u_int64_t>(-1);
+  virtual uint64_t base_address() const {
+    return valid_ ? module_.base_of_image : static_cast<uint64_t>(-1);
   }
-  virtual u_int64_t size() const { return valid_ ? module_.size_of_image : 0; }
+  virtual uint64_t size() const { return valid_ ? module_.size_of_image : 0; }
   virtual string code_file() const;
   virtual string code_identifier() const;
   virtual string debug_file() const;
   virtual string debug_identifier() const;
   virtual string version() const;
   virtual const CodeModule* Copy() const;
 
   // The CodeView record, which contains information to locate the module's
-  // debugging information (pdb).  This is returned as u_int8_t* because
+  // debugging information (pdb).  This is returned as uint8_t* because
   // the data can be of types MDCVInfoPDB20* or MDCVInfoPDB70*, or it may be
   // of a type unknown to Breakpad, in which case the raw data will still be
   // returned but no byte-swapping will have been performed.  Check the
   // record's signature in the first four bytes to differentiate between
   // the various types.  Current toolchains generate modules which carry
   // MDCVInfoPDB70 by default.  Returns a pointer to the CodeView record on
   // success, and NULL on failure.  On success, the optional |size| argument
   // is set to the size of the CodeView record.
-  const u_int8_t* GetCVRecord(u_int32_t* size);
+  const uint8_t* GetCVRecord(uint32_t* size);
 
   // The miscellaneous debug record, which is obsolete.  Current toolchains
   // do not generate this type of debugging information (dbg), and this
   // field is not expected to be present.  Returns a pointer to the debugging
   // record on success, and NULL on failure.  On success, the optional |size|
   // argument is set to the size of the debugging record.
-  const MDImageDebugMisc* GetMiscRecord(u_int32_t* size);
+  const MDImageDebugMisc* GetMiscRecord(uint32_t* size);
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  private:
   // These objects are managed by MinidumpModuleList.
   friend class MinidumpModuleList;
 
@@ -464,18 +464,18 @@
   // requiring seeks to read a contiguous set of MinidumpModule objects.
   // All auxiliary data should be available when Read is called, in order to
   // allow the CodeModule getters to be const methods.
   bool ReadAuxiliaryData();
 
   // The largest number of bytes that will be read from a minidump for a
   // CodeView record or miscellaneous debugging record, respectively.  The
   // default for each is 1024.
-  static u_int32_t max_cv_bytes_;
-  static u_int32_t max_misc_bytes_;
+  static uint32_t max_cv_bytes_;
+  static uint32_t max_misc_bytes_;
 
   // True after a successful Read.  This is different from valid_, which is
   // not set true until ReadAuxiliaryData also completes successfully.
   // module_valid_ is only used by ReadAuxiliaryData and the functions it
   // calls to determine whether the object is ready for auxiliary data to 
   // be read.
   bool              module_valid_;
 
@@ -485,52 +485,52 @@
   bool              has_debug_info_;
 
   MDRawModule       module_;
 
   // Cached module name.
   const string*     name_;
 
   // Cached CodeView record - this is MDCVInfoPDB20 or (likely)
-  // MDCVInfoPDB70, or possibly something else entirely.  Stored as a u_int8_t
+  // MDCVInfoPDB70, or possibly something else entirely.  Stored as a uint8_t
   // because the structure contains a variable-sized string and its exact
   // size cannot be known until it is processed.
-  vector<u_int8_t>* cv_record_;
+  vector<uint8_t>* cv_record_;
 
   // If cv_record_ is present, cv_record_signature_ contains a copy of the
   // CodeView record's first four bytes, for ease of determinining the
   // type of structure that cv_record_ contains.
-  u_int32_t cv_record_signature_;
+  uint32_t cv_record_signature_;
 
-  // Cached MDImageDebugMisc (usually not present), stored as u_int8_t
+  // Cached MDImageDebugMisc (usually not present), stored as uint8_t
   // because the structure contains a variable-sized string and its exact
   // size cannot be known until it is processed.
-  vector<u_int8_t>* misc_record_;
+  vector<uint8_t>* misc_record_;
 };
 
 
 // MinidumpModuleList contains all of the loaded code modules for a process
 // in the form of MinidumpModules.  It maintains a map of these modules
 // so that it may easily provide a code module corresponding to a specific
 // address.
 class MinidumpModuleList : public MinidumpStream,
                            public CodeModules {
  public:
   virtual ~MinidumpModuleList();
 
-  static void set_max_modules(u_int32_t max_modules) {
+  static void set_max_modules(uint32_t max_modules) {
     max_modules_ = max_modules;
   }
-  static u_int32_t max_modules() { return max_modules_; }
+  static uint32_t max_modules() { return max_modules_; }
 
   // CodeModules implementation.
   virtual unsigned int module_count() const {
     return valid_ ? module_count_ : 0;
   }
-  virtual const MinidumpModule* GetModuleForAddress(u_int64_t address) const;
+  virtual const MinidumpModule* GetModuleForAddress(uint64_t address) const;
   virtual const MinidumpModule* GetMainModule() const;
   virtual const MinidumpModule* GetModuleAtSequence(
       unsigned int sequence) const;
   virtual const MinidumpModule* GetModuleAtIndex(unsigned int index) const;
   virtual const CodeModules* Copy() const;
 
   // Print a human-readable representation of the object to stdout.
   void Print();
@@ -538,90 +538,90 @@
  protected:
   explicit MinidumpModuleList(Minidump* minidump);
 
  private:
   friend class Minidump;
 
   typedef vector<MinidumpModule> MinidumpModules;
 
-  static const u_int32_t kStreamType = MD_MODULE_LIST_STREAM;
+  static const uint32_t kStreamType = MD_MODULE_LIST_STREAM;
 
-  bool Read(u_int32_t expected_size);
+  bool Read(uint32_t expected_size);
 
   // The largest number of modules that will be read from a minidump.  The
   // default is 1024.
-  static u_int32_t max_modules_;
+  static uint32_t max_modules_;
 
   // Access to modules using addresses as the key.
-  RangeMap<u_int64_t, unsigned int> *range_map_;
+  RangeMap<uint64_t, unsigned int> *range_map_;
 
   MinidumpModules *modules_;
-  u_int32_t module_count_;
+  uint32_t module_count_;
 };
 
 
 // MinidumpMemoryList corresponds to a minidump's MEMORY_LIST_STREAM stream,
 // which references the snapshots of all of the memory regions contained
 // within the minidump.  For a normal minidump, this includes stack memory
 // (also referenced by each MinidumpThread, in fact, the MDMemoryDescriptors
 // here and in MDRawThread both point to exactly the same data in a
 // minidump file, conserving space), as well as a 256-byte snapshot of memory
 // surrounding the instruction pointer in the case of an exception.  Other
 // types of minidumps may contain significantly more memory regions.  Full-
 // memory minidumps contain all of a process' mapped memory.
 class MinidumpMemoryList : public MinidumpStream {
  public:
   virtual ~MinidumpMemoryList();
 
-  static void set_max_regions(u_int32_t max_regions) {
+  static void set_max_regions(uint32_t max_regions) {
     max_regions_ = max_regions;
   }
-  static u_int32_t max_regions() { return max_regions_; }
+  static uint32_t max_regions() { return max_regions_; }
 
   unsigned int region_count() const { return valid_ ? region_count_ : 0; }
 
   // Sequential access to memory regions.
   MinidumpMemoryRegion* GetMemoryRegionAtIndex(unsigned int index);
 
   // Random access to memory regions.  Returns the region encompassing
   // the address identified by address.
-  MinidumpMemoryRegion* GetMemoryRegionForAddress(u_int64_t address);
+  MinidumpMemoryRegion* GetMemoryRegionForAddress(uint64_t address);
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  private:
   friend class Minidump;
 
   typedef vector<MDMemoryDescriptor>   MemoryDescriptors;
   typedef vector<MinidumpMemoryRegion> MemoryRegions;
 
-  static const u_int32_t kStreamType = MD_MEMORY_LIST_STREAM;
+  static const uint32_t kStreamType = MD_MEMORY_LIST_STREAM;
 
   explicit MinidumpMemoryList(Minidump* minidump);
 
-  bool Read(u_int32_t expected_size);
+  bool Read(uint32_t expected_size);
 
   // The largest number of memory regions that will be read from a minidump.
   // The default is 256.
-  static u_int32_t max_regions_;
+  static uint32_t max_regions_;
 
   // Access to memory regions using addresses as the key.
-  RangeMap<u_int64_t, unsigned int> *range_map_;
+  RangeMap<uint64_t, unsigned int> *range_map_;
 
   // The list of descriptors.  This is maintained separately from the list
   // of regions, because MemoryRegion doesn't own its MemoryDescriptor, it
   // maintains a pointer to it.  descriptors_ provides the storage for this
   // purpose.
   MemoryDescriptors *descriptors_;
 
   // The list of regions.
   MemoryRegions *regions_;
-  u_int32_t region_count_;
+  uint32_t region_count_;
 };
 
 
 // MinidumpException wraps MDRawExceptionStream, which contains information
 // about the exception that caused the minidump to be generated, if the
 // minidump was generated in an exception handler called as a result of
 // an exception.  It also provides access to a MinidumpContext object,
 // which contains the CPU context for the exception thread at the time
@@ -633,31 +633,31 @@
   const MDRawExceptionStream* exception() const {
     return valid_ ? &exception_ : NULL;
   }
 
   // The thread ID is used to determine if a thread is the exception thread,
   // so a special getter is provided to retrieve this data from the
   // MDRawExceptionStream structure.  Returns false if the thread ID cannot
   // be determined.
-  bool GetThreadID(u_int32_t *thread_id) const;
+  bool GetThreadID(uint32_t *thread_id) const;
 
   MinidumpContext* GetContext();
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  private:
   friend class Minidump;
 
-  static const u_int32_t kStreamType = MD_EXCEPTION_STREAM;
+  static const uint32_t kStreamType = MD_EXCEPTION_STREAM;
 
   explicit MinidumpException(Minidump* minidump);
 
-  bool Read(u_int32_t expected_size);
+  bool Read(uint32_t expected_size);
 
   MDRawExceptionStream exception_;
   MinidumpContext*     context_;
 };
 
 // MinidumpAssertion wraps MDRawAssertionInfo, which contains information
 // about an assertion that caused the minidump to be generated.
 class MinidumpAssertion : public MinidumpStream {
@@ -681,21 +681,21 @@
   }
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  private:
   friend class Minidump;
 
-  static const u_int32_t kStreamType = MD_ASSERTION_INFO_STREAM;
+  static const uint32_t kStreamType = MD_ASSERTION_INFO_STREAM;
 
   explicit MinidumpAssertion(Minidump* minidump);
 
-  bool Read(u_int32_t expected_size);
+  bool Read(uint32_t expected_size);
 
   MDRawAssertionInfo assertion_;
   string expression_;
   string function_;
   string file_;
 };
 
 
@@ -738,19 +738,19 @@
 
   // Textual representation of the OS service pack, for minidumps produced
   // by MiniDumpWriteDump on Windows.
   const string* csd_version_;
 
  private:
   friend class Minidump;
 
-  static const u_int32_t kStreamType = MD_SYSTEM_INFO_STREAM;
+  static const uint32_t kStreamType = MD_SYSTEM_INFO_STREAM;
 
-  bool Read(u_int32_t expected_size);
+  bool Read(uint32_t expected_size);
 
   // A string identifying the CPU vendor, if known.
   const string* cpu_vendor_;
 };
 
 
 // MinidumpMiscInfo wraps MDRawMiscInfo and provides information about
 // the process that generated the minidump, and optionally additional system
@@ -762,21 +762,21 @@
   }
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  private:
   friend class Minidump;
 
-  static const u_int32_t kStreamType = MD_MISC_INFO_STREAM;
+  static const uint32_t kStreamType = MD_MISC_INFO_STREAM;
 
   explicit MinidumpMiscInfo(Minidump* minidump_);
 
-  bool Read(u_int32_t expected_size_);
+  bool Read(uint32_t expected_size_);
 
   MDRawMiscInfo misc_info_;
 };
 
 
 // MinidumpBreakpadInfo wraps MDRawBreakpadInfo, which is an optional stream in
 // a minidump that provides additional information about the process state
 // at the time the minidump was generated.
@@ -785,46 +785,46 @@
   const MDRawBreakpadInfo* breakpad_info() const {
     return valid_ ? &breakpad_info_ : NULL;
   }
 
   // These thread IDs are used to determine if threads deserve special
   // treatment, so special getters are provided to retrieve this data from
   // the MDRawBreakpadInfo structure.  The getters return false if the thread
   // IDs cannot be determined.
-  bool GetDumpThreadID(u_int32_t *thread_id) const;
-  bool GetRequestingThreadID(u_int32_t *thread_id) const;
+  bool GetDumpThreadID(uint32_t *thread_id) const;
+  bool GetRequestingThreadID(uint32_t *thread_id) const;
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  private:
   friend class Minidump;
 
-  static const u_int32_t kStreamType = MD_BREAKPAD_INFO_STREAM;
+  static const uint32_t kStreamType = MD_BREAKPAD_INFO_STREAM;
 
   explicit MinidumpBreakpadInfo(Minidump* minidump_);
 
-  bool Read(u_int32_t expected_size_);
+  bool Read(uint32_t expected_size_);
 
   MDRawBreakpadInfo breakpad_info_;
 };
 
 // MinidumpMemoryInfo wraps MDRawMemoryInfo, which provides information
 // about mapped memory regions in a process, including their ranges
 // and protection.
 class MinidumpMemoryInfo : public MinidumpObject {
  public:
   const MDRawMemoryInfo* info() const { return valid_ ? &memory_info_ : NULL; }
 
   // The address of the base of the memory region.
-  u_int64_t GetBase() const { return valid_ ? memory_info_.base_address : 0; }
+  uint64_t GetBase() const { return valid_ ? memory_info_.base_address : 0; }
 
   // The size, in bytes, of the memory region.
-  u_int32_t GetSize() const { return valid_ ? memory_info_.region_size : 0; }
+  uint32_t GetSize() const { return valid_ ? memory_info_.region_size : 0; }
 
   // Return true if the memory protection allows execution.
   bool IsExecutable() const;
 
   // Return true if the memory protection allows writing.
   bool IsWritable() const;
 
   // Print a human-readable representation of the object to stdout.
@@ -849,38 +849,38 @@
 // It maintains a map of these structures so that it may easily provide
 // info corresponding to a specific address.
 class MinidumpMemoryInfoList : public MinidumpStream {
  public:
   virtual ~MinidumpMemoryInfoList();
 
   unsigned int info_count() const { return valid_ ? info_count_ : 0; }
 
-  const MinidumpMemoryInfo* GetMemoryInfoForAddress(u_int64_t address) const;
+  const MinidumpMemoryInfo* GetMemoryInfoForAddress(uint64_t address) const;
   const MinidumpMemoryInfo* GetMemoryInfoAtIndex(unsigned int index) const;
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  private:
   friend class Minidump;
 
   typedef vector<MinidumpMemoryInfo> MinidumpMemoryInfos;
 
-  static const u_int32_t kStreamType = MD_MEMORY_INFO_LIST_STREAM;
+  static const uint32_t kStreamType = MD_MEMORY_INFO_LIST_STREAM;
 
   explicit MinidumpMemoryInfoList(Minidump* minidump);
 
-  bool Read(u_int32_t expected_size);
+  bool Read(uint32_t expected_size);
 
   // Access to memory info using addresses as the key.
-  RangeMap<u_int64_t, unsigned int> *range_map_;
+  RangeMap<uint64_t, unsigned int> *range_map_;
 
   MinidumpMemoryInfos* infos_;
-  u_int32_t info_count_;
+  uint32_t info_count_;
 };
 
 
 // Minidump is the user's interface to a minidump file.  It wraps MDRawHeader
 // and provides access to the minidump's top-level stream directory.
 class Minidump {
  public:
   // path is the pathname of a file containing the minidump.
@@ -891,37 +891,37 @@
   explicit Minidump(std::istream& input);
 
   virtual ~Minidump();
 
   // path may be empty if the minidump was not opened from a file
   virtual string path() const {
     return path_;
   }
-  static void set_max_streams(u_int32_t max_streams) {
+  static void set_max_streams(uint32_t max_streams) {
     max_streams_ = max_streams;
   }
-  static u_int32_t max_streams() { return max_streams_; }
+  static uint32_t max_streams() { return max_streams_; }
 
-  static void set_max_string_length(u_int32_t max_string_length) {
+  static void set_max_string_length(uint32_t max_string_length) {
     max_string_length_ = max_string_length;
   }
-  static u_int32_t max_string_length() { return max_string_length_; }
+  static uint32_t max_string_length() { return max_string_length_; }
 
   virtual const MDRawHeader* header() const { return valid_ ? &header_ : NULL; }
 
   // Reads the CPU information from the system info stream and generates the
   // appropriate CPU flags.  The returned context_cpu_flags are the same as
   // if the CPU type bits were set in the context_flags of a context record.
   // On success, context_cpu_flags will have the flags that identify the CPU.
   // If a system info stream is missing, context_cpu_flags will be 0.
   // Returns true if the current position in the stream was not changed.
   // Returns false when the current location in the stream was changed and the
   // attempt to restore the original position failed.
-  bool GetContextCPUFlagsFromSystemInfo(u_int32_t* context_cpu_flags);
+  bool GetContextCPUFlagsFromSystemInfo(uint32_t* context_cpu_flags);
 
   // Reads the minidump file's header and top-level stream directory.
   // The minidump is expected to be positioned at the beginning of the
   // header.  Read() sets up the stream list and map, and validates the
   // Minidump object.
   virtual bool Read();
 
   // The next set of methods are stubs that call GetStream.  They exist to
@@ -975,17 +975,17 @@
   // thinking that the stream that this seeks to is the only stream with
   // type stream_type.  That can't happen for streams that these classes
   // deal with directly, because they're only supposed to be present in the
   // file singly, and that's verified when stream_map_ is built.  Users who
   // are looking for other stream types should be aware of this
   // possibility, and consider using GetDirectoryEntryAtIndex (possibly
   // with GetDirectoryEntryCount) if expecting multiple streams of the same
   // type in a single minidump file.
-  bool SeekToStreamType(u_int32_t stream_type, u_int32_t* stream_length);
+  bool SeekToStreamType(uint32_t stream_type, uint32_t* stream_length);
 
   bool swap() const { return valid_ ? swap_ : false; }
 
   // Print a human-readable representation of the object to stdout.
   void Print();
 
  private:
   // MinidumpStreamInfo is used in the MinidumpStreamMap.  It lets
@@ -998,27 +998,27 @@
     // Index into the MinidumpDirectoryEntries vector
     unsigned int    stream_index;
 
     // Pointer to the stream if cached, or NULL if not yet populated
     MinidumpStream* stream;
   };
 
   typedef vector<MDRawDirectory> MinidumpDirectoryEntries;
-  typedef map<u_int32_t, MinidumpStreamInfo> MinidumpStreamMap;
+  typedef map<uint32_t, MinidumpStreamInfo> MinidumpStreamMap;
 
   template<typename T> T* GetStream(T** stream);
 
   // Opens the minidump file, or if already open, seeks to the beginning.
   bool Open();
 
   // The largest number of top-level streams that will be read from a minidump.
   // Note that streams are only read (and only consume memory) as needed,
   // when directed by the caller.  The default is 128.
-  static u_int32_t max_streams_;
+  static uint32_t max_streams_;
 
   // The maximum length of a UTF-16 string that will be read from a minidump
   // in 16-bit words.  The default is 1024.  UTF-16 strings are converted
   // to UTF-8 when stored in memory, and each UTF-16 word will be represented
   // by as many as 3 bytes in UTF-8.
   static unsigned int max_string_length_;
 
   MDRawHeader               header_;
diff --git a/src/google_breakpad/processor/minidump_processor.h b/src/google_breakpad/processor/minidump_processor.h
--- a/src/google_breakpad/processor/minidump_processor.h
+++ b/src/google_breakpad/processor/minidump_processor.h
@@ -126,17 +126,17 @@
   // Returns a textual representation of the reason that a crash occurred,
   // if the minidump in dump was produced as a result of a crash.  Returns
   // an empty string if this information cannot be determined.  If address
   // is non-NULL, it will be set to contain the address that caused the
   // exception, if this information is available.  This will be a code
   // address when the crash was caused by problems such as illegal
   // instructions or divisions by zero, or a data address when the crash
   // was caused by a memory access violation.
-  static string GetCrashReason(Minidump* dump, u_int64_t* address);
+  static string GetCrashReason(Minidump* dump, uint64_t* address);
 
   // This function returns true if the passed-in error code is
   // something unrecoverable(i.e. retry should not happen).  For
   // instance, if the minidump is corrupt, then it makes no sense to
   // retry as we won't be able to glean additional information.
   // However, as an example of the other case, the symbol supplier can
   // return an error code indicating it was 'interrupted', which can
   // happen of the symbols are fetched from a remote store, and a
diff --git a/src/google_breakpad/processor/process_state.h b/src/google_breakpad/processor/process_state.h
--- a/src/google_breakpad/processor/process_state.h
+++ b/src/google_breakpad/processor/process_state.h
@@ -89,52 +89,52 @@
  public:
   ProcessState() : modules_(NULL) { Clear(); }
   ~ProcessState();
 
   // Resets the ProcessState to its default values
   void Clear();
 
   // Accessors.  See the data declarations below.
-  u_int32_t time_date_stamp() const { return time_date_stamp_; }
+  uint32_t time_date_stamp() const { return time_date_stamp_; }
   bool crashed() const { return crashed_; }
   string crash_reason() const { return crash_reason_; }
-  u_int64_t crash_address() const { return crash_address_; }
+  uint64_t crash_address() const { return crash_address_; }
   string assertion() const { return assertion_; }
   int requesting_thread() const { return requesting_thread_; }
   const vector<CallStack*>* threads() const { return &threads_; }
   const vector<MinidumpMemoryRegion*>* thread_memory_regions() const {
     return &thread_memory_regions_;
   }
   const SystemInfo* system_info() const { return &system_info_; }
   const CodeModules* modules() const { return modules_; }
   ExploitabilityRating exploitability() const { return exploitability_; }
 
  private:
   // MinidumpProcessor is responsible for building ProcessState objects.
   friend class MinidumpProcessor;
 
   // The time-date stamp of the minidump (time_t format)
-  u_int32_t time_date_stamp_;
+  uint32_t time_date_stamp_;
 
   // True if the process crashed, false if the dump was produced outside
   // of an exception handler.
   bool crashed_;
 
   // If the process crashed, the type of crash.  OS- and possibly CPU-
   // specific.  For example, "EXCEPTION_ACCESS_VIOLATION" (Windows),
   // "EXC_BAD_ACCESS / KERN_INVALID_ADDRESS" (Mac OS X), "SIGSEGV"
   // (other Unix).
   string crash_reason_;
 
   // If the process crashed, and if crash_reason implicates memory,
   // the memory address that caused the crash.  For data access errors,
   // this will be the data address that caused the fault.  For code errors,
   // this will be the address of the instruction that caused the fault.
-  u_int64_t crash_address_;
+  uint64_t crash_address_;
 
   // If there was an assertion that was hit, a textual representation
   // of that assertion, possibly including the file and line at which
   // it occurred.
   string assertion_;
 
   // The index of the thread that requested a dump be written in the
   // threads vector.  If a dump was produced as a result of a crash, this
diff --git a/src/google_breakpad/processor/source_line_resolver_interface.h b/src/google_breakpad/processor/source_line_resolver_interface.h
--- a/src/google_breakpad/processor/source_line_resolver_interface.h
+++ b/src/google_breakpad/processor/source_line_resolver_interface.h
@@ -43,17 +43,17 @@
 namespace google_breakpad {
 
 struct StackFrame;
 struct WindowsFrameInfo;
 class CFIFrameInfo;
 
 class SourceLineResolverInterface {
  public:
-  typedef u_int64_t MemAddr;
+  typedef uint64_t MemAddr;
 
   virtual ~SourceLineResolverInterface() {}
 
   // Adds a module to this resolver, returning true on success.
   //
   // module should have at least the code_file, debug_file,
   // and debug_identifier members populated.
   //
diff --git a/src/google_breakpad/processor/stack_frame.h b/src/google_breakpad/processor/stack_frame.h
--- a/src/google_breakpad/processor/stack_frame.h
+++ b/src/google_breakpad/processor/stack_frame.h
@@ -80,17 +80,17 @@
         return "stack scanning";
       default:
         return "unknown";
     }
   };
 
   // Return the actual return address, as saved on the stack or in a
   // register. See the comments for 'instruction', below, for details.
-  virtual u_int64_t ReturnAddress() const { return instruction; }
+  virtual uint64_t ReturnAddress() const { return instruction; }
 
   // The program counter location as an absolute virtual address.
   //
   // - For the innermost called frame in a stack, this will be an exact
   //   program counter or instruction pointer value.
   //
   // - For all other frames, this address is within the instruction that
   //   caused execution to branch to this frame's callee (although it may
@@ -103,38 +103,38 @@
   //   code, such that the "return address" (which will never be used)
   //   immediately after the call instruction is in an entirely different
   //   function, perhaps even from a different source file.)
   //
   // On some architectures, the return address as saved on the stack or in
   // a register is fine for looking up the point of the call. On others, it
   // requires adjustment. ReturnAddress returns the address as saved by the
   // machine.
-  u_int64_t instruction;
+  uint64_t instruction;
 
   // The module in which the instruction resides.
   const CodeModule *module;
 
   // The function name, may be omitted if debug symbols are not available.
   string function_name;
 
   // The start address of the function, may be omitted if debug symbols
   // are not available.
-  u_int64_t function_base;
+  uint64_t function_base;
 
   // The source file name, may be omitted if debug symbols are not available.
   string source_file_name;
 
   // The (1-based) source line number, may be omitted if debug symbols are
   // not available.
   int source_line;
 
   // The start address of the source line, may be omitted if debug symbols
   // are not available.
-  u_int64_t source_line_base;
+  uint64_t source_line_base;
 
   // Amount of trust the stack walker has in the instruction pointer
   // of this frame.
   FrameTrust trust;
 };
 
 }  // namespace google_breakpad
 
diff --git a/src/google_breakpad/processor/stack_frame_cpu.h b/src/google_breakpad/processor/stack_frame_cpu.h
--- a/src/google_breakpad/processor/stack_frame_cpu.h
+++ b/src/google_breakpad/processor/stack_frame_cpu.h
@@ -73,17 +73,17 @@
   StackFrameX86()
      : context(),
        context_validity(CONTEXT_VALID_NONE),
        windows_frame_info(NULL),
        cfi_frame_info(NULL) {}
   ~StackFrameX86();
 
   // Overriden to return the return address as saved on the stack.
-  virtual u_int64_t ReturnAddress() const;
+  virtual uint64_t ReturnAddress() const;
 
   // Register state.  This is only fully valid for the topmost frame in a
   // stack.  In other frames, the values of nonvolatile registers may be
   // present, given sufficient debugging information.  Refer to
   // context_validity.
   MDRawContextX86 context;
 
   // context_validity is actually ContextValidity, but int is used because
@@ -146,17 +146,17 @@
     CONTEXT_VALID_R15   = 1 << 15,
     CONTEXT_VALID_RIP   = 1 << 16,
     CONTEXT_VALID_ALL  = -1
   };
 
   StackFrameAMD64() : context(), context_validity(CONTEXT_VALID_NONE) {}
 
   // Overriden to return the return address as saved on the stack.
-  virtual u_int64_t ReturnAddress() const;
+  virtual uint64_t ReturnAddress() const;
 
   // Register state. This is only fully valid for the topmost frame in a
   // stack. In other frames, which registers are present depends on what
   // debugging information we had available. Refer to context_validity.
   MDRawContextAMD64 context;
 
   // For each register in context whose value has been recovered, we set
   // the corresponding CONTEXT_VALID_ bit in context_validity.
diff --git a/src/google_breakpad/processor/stackwalker.h b/src/google_breakpad/processor/stackwalker.h
--- a/src/google_breakpad/processor/stackwalker.h
+++ b/src/google_breakpad/processor/stackwalker.h
@@ -73,18 +73,18 @@
   // argument.  If no suitable concrete subclass exists, returns NULL.
   static Stackwalker* StackwalkerForCPU(
      const SystemInfo* system_info,
      MinidumpContext* context,
      MemoryRegion* memory,
      const CodeModules* modules,
      StackFrameSymbolizer* resolver_helper);
 
-  static void set_max_frames(u_int32_t max_frames) { max_frames_ = max_frames; }
-  static u_int32_t max_frames() { return max_frames_; }
+  static void set_max_frames(uint32_t max_frames) { max_frames_ = max_frames; }
+  static uint32_t max_frames() { return max_frames_; }
 
  protected:
   // system_info identifies the operating system, NULL or empty if unknown.
   // memory identifies a MemoryRegion that provides the stack memory
   // for the stack to walk.  modules, if non-NULL, is a CodeModules
   // object that is used to look up which code module each stack frame is
   // associated with.  frame_symbolizer is a StackFrameSymbolizer object that
   // encapsulates the logic of how source line resolver interacts with symbol
@@ -99,17 +99,17 @@
   // This can be used to filter out potential return addresses when
   // the stack walker resorts to stack scanning.
   // Returns true if any of:
   // * This address is within a loaded module, but we don't have symbols
   //   for that module.
   // * This address is within a loaded module for which we have symbols,
   //   and falls inside a function in that module.
   // Returns false otherwise.
-  bool InstructionAddressSeemsValid(u_int64_t address);
+  bool InstructionAddressSeemsValid(uint64_t address);
 
   // The default number of words to search through on the stack
   // for a return address.
   static const int kRASearchWords;
 
   template<typename InstructionType>
   bool ScanForReturnAddress(InstructionType location_start,
                             InstructionType* location_found,
@@ -180,15 +180,15 @@
   // return NULL on failure or when there are no more caller frames (when
   // the end of the stack has been reached).  GetCallerFrame allocates a new
   // StackFrame (or StackFrame subclass), ownership of which is taken by
   // the caller.
   virtual StackFrame* GetCallerFrame(const CallStack* stack) = 0;
 
   // The maximum number of frames Stackwalker will walk through.
   // This defaults to 1024 to prevent infinite loops.
-  static u_int32_t max_frames_;
+  static uint32_t max_frames_;
 };
 
 }  // namespace google_breakpad
 
 
 #endif  // GOOGLE_BREAKPAD_PROCESSOR_STACKWALKER_H__
diff --git a/src/processor/basic_code_module.h b/src/processor/basic_code_module.h
--- a/src/processor/basic_code_module.h
+++ b/src/processor/basic_code_module.h
@@ -58,17 +58,17 @@
       : base_address_(that->base_address()),
         size_(that->size()),
         code_file_(that->code_file()),
         code_identifier_(that->code_identifier()),
         debug_file_(that->debug_file()),
         debug_identifier_(that->debug_identifier()),
         version_(that->version()) {}
 
-  BasicCodeModule(u_int64_t base_address, u_int64_t size,
+  BasicCodeModule(uint64_t base_address, uint64_t size,
 		  const string &code_file,
 		  const string &code_identifier,
 		  const string &debug_file,
 		  const string &debug_identifier,
 		  const string &version)
     : base_address_(base_address),
       size_(size),
       code_file_(code_file),
@@ -76,28 +76,28 @@
       debug_file_(debug_file),
       debug_identifier_(debug_identifier),
       version_(version)
     {}
   virtual ~BasicCodeModule() {}
 
   // See code_module.h for descriptions of these methods and the associated
   // members.
-  virtual u_int64_t base_address() const { return base_address_; }
-  virtual u_int64_t size() const { return size_; }
+  virtual uint64_t base_address() const { return base_address_; }
+  virtual uint64_t size() const { return size_; }
   virtual string code_file() const { return code_file_; }
   virtual string code_identifier() const { return code_identifier_; }
   virtual string debug_file() const { return debug_file_; }
   virtual string debug_identifier() const { return debug_identifier_; }
   virtual string version() const { return version_; }
   virtual const CodeModule* Copy() const { return new BasicCodeModule(this); }
 
  private:
-  u_int64_t base_address_;
-  u_int64_t size_;
+  uint64_t base_address_;
+  uint64_t size_;
   string code_file_;
   string code_identifier_;
   string debug_file_;
   string debug_identifier_;
   string version_;
 
   // Disallow copy constructor and assignment operator.
   BasicCodeModule(const BasicCodeModule &that);
diff --git a/src/processor/basic_code_modules.cc b/src/processor/basic_code_modules.cc
--- a/src/processor/basic_code_modules.cc
+++ b/src/processor/basic_code_modules.cc
@@ -42,17 +42,17 @@
 #include "processor/linked_ptr.h"
 #include "processor/logging.h"
 #include "processor/range_map-inl.h"
 
 namespace google_breakpad {
 
 BasicCodeModules::BasicCodeModules(const CodeModules *that)
     : main_address_(0),
-      map_(new RangeMap<u_int64_t, linked_ptr<const CodeModule> >()) {
+      map_(new RangeMap<uint64_t, linked_ptr<const CodeModule> >()) {
   BPLOG_IF(ERROR, !that) << "BasicCodeModules::BasicCodeModules requires "
                             "|that|";
   assert(that);
 
   const CodeModule *main_module = that->GetMainModule();
   if (main_module)
     main_address_ = main_module->base_address();
 
@@ -77,17 +77,17 @@
   delete map_;
 }
 
 unsigned int BasicCodeModules::module_count() const {
   return map_->GetCount();
 }
 
 const CodeModule* BasicCodeModules::GetModuleForAddress(
-    u_int64_t address) const {
+    uint64_t address) const {
   linked_ptr<const CodeModule> module;
   if (!map_->RetrieveRange(address, &module, NULL, NULL)) {
     BPLOG(INFO) << "No module at " << HexString(address);
     return NULL;
   }
 
   return module.get();
 }
diff --git a/src/processor/basic_code_modules.h b/src/processor/basic_code_modules.h
--- a/src/processor/basic_code_modules.h
+++ b/src/processor/basic_code_modules.h
@@ -56,29 +56,29 @@
   // resources that other implementations may require.  A copy will be
   // made of each contained CodeModule using CodeModule::Copy.
   explicit BasicCodeModules(const CodeModules *that);
 
   virtual ~BasicCodeModules();
 
   // See code_modules.h for descriptions of these methods.
   virtual unsigned int module_count() const;
-  virtual const CodeModule* GetModuleForAddress(u_int64_t address) const;
+  virtual const CodeModule* GetModuleForAddress(uint64_t address) const;
   virtual const CodeModule* GetMainModule() const;
   virtual const CodeModule* GetModuleAtSequence(unsigned int sequence) const;
   virtual const CodeModule* GetModuleAtIndex(unsigned int index) const;
   virtual const CodeModules* Copy() const;
 
  private:
   // The base address of the main module.
-  u_int64_t main_address_;
+  uint64_t main_address_;
 
   // The map used to contain each CodeModule, keyed by each CodeModule's
   // address range.
-  RangeMap<u_int64_t, linked_ptr<const CodeModule> > *map_;
+  RangeMap<uint64_t, linked_ptr<const CodeModule> > *map_;
 
   // Disallow copy constructor and assignment operator.
   BasicCodeModules(const BasicCodeModules &that);
   void operator=(const BasicCodeModules &that);
 };
 
 }  // namespace google_breakpad
 
diff --git a/src/processor/basic_source_line_resolver.cc b/src/processor/basic_source_line_resolver.cc
--- a/src/processor/basic_source_line_resolver.cc
+++ b/src/processor/basic_source_line_resolver.cc
@@ -295,34 +295,34 @@
   // FUNC <address> <size> <stack_param_size> <name>
   function_line += 5;  // skip prefix
 
   vector<char*> tokens;
   if (!Tokenize(function_line, kWhitespace, 4, &tokens)) {
     return NULL;
   }
 
-  u_int64_t address    = strtoull(tokens[0], NULL, 16);
-  u_int64_t size       = strtoull(tokens[1], NULL, 16);
+  uint64_t address    = strtoull(tokens[0], NULL, 16);
+  uint64_t size       = strtoull(tokens[1], NULL, 16);
   int stack_param_size = strtoull(tokens[2], NULL, 16);
   char *name           = tokens[3];
 
   return new Function(name, address, size, stack_param_size);
 }
 
 BasicSourceLineResolver::Line* BasicSourceLineResolver::Module::ParseLine(
     char *line_line) {
   // <address> <line number> <source file id>
   vector<char*> tokens;
   if (!Tokenize(line_line, kWhitespace, 4, &tokens)) {
     return NULL;
   }
 
-  u_int64_t address = strtoull(tokens[0], NULL, 16);
-  u_int64_t size    = strtoull(tokens[1], NULL, 16);
+  uint64_t address = strtoull(tokens[0], NULL, 16);
+  uint64_t size    = strtoull(tokens[1], NULL, 16);
   int line_number   = atoi(tokens[2]);
   int source_file   = atoi(tokens[3]);
   if (line_number <= 0) {
     return NULL;
   }
 
   return new Line(address, size, source_file, line_number);
 }
@@ -333,17 +333,17 @@
   // Skip "PUBLIC " prefix.
   public_line += 7;
 
   vector<char*> tokens;
   if (!Tokenize(public_line, kWhitespace, 3, &tokens)) {
     return false;
   }
 
-  u_int64_t address    = strtoull(tokens[0], NULL, 16);
+  uint64_t address    = strtoull(tokens[0], NULL, 16);
   int stack_param_size = strtoull(tokens[1], NULL, 16);
   char *name           = tokens[2];
 
   // A few public symbols show up with an address of 0.  This has been seen
   // in the dumped output of ntdll.pdb for symbols such as _CIlog, _CIpow,
   // RtlDescribeChunkLZNT1, and RtlReserveChunkLZNT1.  They would conflict
   // with one another if they were allowed into the public_symbols_ map,
   // but since the address is obviously invalid, gracefully accept them
@@ -368,17 +368,17 @@
   const char *platform = stack_info_line;
   while (!strchr(kWhitespace, *stack_info_line))
     stack_info_line++;
   *stack_info_line++ = '\0';
 
   // MSVC stack frame info.
   if (strcmp(platform, "WIN") == 0) {
     int type = 0;
-    u_int64_t rva, code_size;
+    uint64_t rva, code_size;
     linked_ptr<WindowsFrameInfo>
       stack_frame_info(WindowsFrameInfo::ParseFromString(stack_info_line,
                                                          type,
                                                          rva,
                                                          code_size));
     if (stack_frame_info == NULL)
       return false;
 
diff --git a/src/processor/basic_source_line_resolver_unittest.cc b/src/processor/basic_source_line_resolver_unittest.cc
--- a/src/processor/basic_source_line_resolver_unittest.cc
+++ b/src/processor/basic_source_line_resolver_unittest.cc
@@ -54,77 +54,77 @@
 using google_breakpad::linked_ptr;
 using google_breakpad::scoped_ptr;
 
 class TestCodeModule : public CodeModule {
  public:
   TestCodeModule(string code_file) : code_file_(code_file) {}
   virtual ~TestCodeModule() {}
 
-  virtual u_int64_t base_address() const { return 0; }
-  virtual u_int64_t size() const { return 0xb000; }
+  virtual uint64_t base_address() const { return 0; }
+  virtual uint64_t size() const { return 0xb000; }
   virtual string code_file() const { return code_file_; }
   virtual string code_identifier() const { return ""; }
   virtual string debug_file() const { return ""; }
   virtual string debug_identifier() const { return ""; }
   virtual string version() const { return ""; }
   virtual const CodeModule* Copy() const {
     return new TestCodeModule(code_file_);
   }
 
  private:
   string code_file_;
 };
 
 // A mock memory region object, for use by the STACK CFI tests.
 class MockMemoryRegion: public MemoryRegion {
-  u_int64_t GetBase() const { return 0x10000; }
-  u_int32_t GetSize() const { return 0x01000; }
-  bool GetMemoryAtAddress(u_int64_t address, u_int8_t *value) const {
+  uint64_t GetBase() const { return 0x10000; }
+  uint32_t GetSize() const { return 0x01000; }
+  bool GetMemoryAtAddress(uint64_t address, uint8_t *value) const {
     *value = address & 0xff;
     return true;
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int16_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint16_t *value) const {
     *value = address & 0xffff;
     return true;
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int32_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint32_t *value) const {
     switch (address) {
       case 0x10008: *value = 0x98ecadc3; break; // saved %ebx
       case 0x1000c: *value = 0x878f7524; break; // saved %esi
       case 0x10010: *value = 0x6312f9a5; break; // saved %edi
       case 0x10014: *value = 0x10038;    break; // caller's %ebp
       case 0x10018: *value = 0xf6438648; break; // return address
       default: *value = 0xdeadbeef;      break; // junk
     }
     return true;
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int64_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint64_t *value) const {
     *value = address;
     return true;
   }
 };
 
 // Verify that, for every association in ACTUAL, EXPECTED has the same
 // association. (That is, ACTUAL's associations should be a subset of
 // EXPECTED's.) Also verify that ACTUAL has associations for ".ra" and
 // ".cfa".
 static bool VerifyRegisters(
     const char *file, int line,
-    const CFIFrameInfo::RegisterValueMap<u_int32_t> &expected,
-    const CFIFrameInfo::RegisterValueMap<u_int32_t> &actual) {
-  CFIFrameInfo::RegisterValueMap<u_int32_t>::const_iterator a;
+    const CFIFrameInfo::RegisterValueMap<uint32_t> &expected,
+    const CFIFrameInfo::RegisterValueMap<uint32_t> &actual) {
+  CFIFrameInfo::RegisterValueMap<uint32_t>::const_iterator a;
   a = actual.find(".cfa");
   if (a == actual.end())
     return false;
   a = actual.find(".ra");
   if (a == actual.end())
     return false;
   for (a = actual.begin(); a != actual.end(); a++) {
-    CFIFrameInfo::RegisterValueMap<u_int32_t>::const_iterator e =
+    CFIFrameInfo::RegisterValueMap<uint32_t>::const_iterator e =
       expected.find(a->first);
     if (e == expected.end()) {
       fprintf(stderr, "%s:%d: unexpected register '%s' recovered, value 0x%x\n",
               file, line, a->first.c_str(), a->second);
       return false;
     }
     if (e->second != a->second) {
       fprintf(stderr,
@@ -247,19 +247,19 @@
   cfi_frame_info.reset(resolver.FindCFIFrameInfo(&frame));
   ASSERT_FALSE(cfi_frame_info.get());
 
   frame.instruction = 0x3e9f;
   frame.module = &module1;
   cfi_frame_info.reset(resolver.FindCFIFrameInfo(&frame));
   ASSERT_FALSE(cfi_frame_info.get());
 
-  CFIFrameInfo::RegisterValueMap<u_int32_t> current_registers;
-  CFIFrameInfo::RegisterValueMap<u_int32_t> caller_registers;
-  CFIFrameInfo::RegisterValueMap<u_int32_t> expected_caller_registers;
+  CFIFrameInfo::RegisterValueMap<uint32_t> current_registers;
+  CFIFrameInfo::RegisterValueMap<uint32_t> caller_registers;
+  CFIFrameInfo::RegisterValueMap<uint32_t> expected_caller_registers;
   MockMemoryRegion memory;
 
   // Regardless of which instruction evaluation takes place at, it
   // should produce the same values for the caller's registers.
   expected_caller_registers[".cfa"] = 0x1001c;
   expected_caller_registers[".ra"]  = 0xf6438648;
   expected_caller_registers["$ebp"] = 0x10038;
   expected_caller_registers["$ebx"] = 0x98ecadc3;
@@ -272,67 +272,67 @@
   current_registers["$esp"] = 0x10018;
   current_registers["$ebp"] = 0x10038;
   current_registers["$ebx"] = 0x98ecadc3;
   current_registers["$esi"] = 0x878f7524;
   current_registers["$edi"] = 0x6312f9a5;
   cfi_frame_info.reset(resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   ASSERT_TRUE(VerifyRegisters(__FILE__, __LINE__,
                               expected_caller_registers, caller_registers));
 
   frame.instruction = 0x3d41;
   current_registers["$esp"] = 0x10014;
   cfi_frame_info.reset(resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   ASSERT_TRUE(VerifyRegisters(__FILE__, __LINE__,
                               expected_caller_registers, caller_registers));
 
   frame.instruction = 0x3d43;
   current_registers["$ebp"] = 0x10014;
   cfi_frame_info.reset(resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   VerifyRegisters(__FILE__, __LINE__,
                   expected_caller_registers, caller_registers);
 
   frame.instruction = 0x3d54;
   current_registers["$ebx"] = 0x6864f054U;
   cfi_frame_info.reset(resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   VerifyRegisters(__FILE__, __LINE__,
                   expected_caller_registers, caller_registers);
 
   frame.instruction = 0x3d5a;
   current_registers["$esi"] = 0x6285f79aU;
   cfi_frame_info.reset(resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   VerifyRegisters(__FILE__, __LINE__,
                   expected_caller_registers, caller_registers);
 
   frame.instruction = 0x3d84;
   current_registers["$edi"] = 0x64061449U;
   cfi_frame_info.reset(resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   VerifyRegisters(__FILE__, __LINE__,
                   expected_caller_registers, caller_registers);
 
   frame.instruction = 0x2900;
   frame.module = &module1;
   resolver.FillSourceLineInfo(&frame);
   ASSERT_EQ(frame.function_name, string("PublicSymbol"));
diff --git a/src/processor/binarystream.cc b/src/processor/binarystream.cc
--- a/src/processor/binarystream.cc
+++ b/src/processor/binarystream.cc
@@ -35,90 +35,90 @@
 
 #include "common/using_std_string.h"
 #include "processor/binarystream.h"
 
 namespace google_breakpad {
 using std::vector;
 
 binarystream &binarystream::operator>>(string &str) {
-  u_int16_t length;
+  uint16_t length;
   *this >> length;
   if (eof())
     return *this;
   if (length == 0) {
     str.clear();
     return *this;
   }
   vector<char> buffer(length);
   stream_.read(&buffer[0], length);
   if (!eof())
     str.assign(&buffer[0], length);
   return *this;
 }
 
-binarystream &binarystream::operator>>(u_int8_t &u8) {
+binarystream &binarystream::operator>>(uint8_t &u8) {
   stream_.read((char *)&u8, 1);
   return *this;
 }
 
-binarystream &binarystream::operator>>(u_int16_t &u16) {
-  u_int16_t temp;
+binarystream &binarystream::operator>>(uint16_t &u16) {
+  uint16_t temp;
   stream_.read((char *)&temp, 2);
   if (!eof())
     u16 = ntohs(temp);
   return *this;
 }
 
-binarystream &binarystream::operator>>(u_int32_t &u32) {
-  u_int32_t temp;
+binarystream &binarystream::operator>>(uint32_t &u32) {
+  uint32_t temp;
   stream_.read((char *)&temp, 4);
   if (!eof())
     u32 = ntohl(temp);
   return *this;
 }
 
-binarystream &binarystream::operator>>(u_int64_t &u64) {
-  u_int32_t lower, upper;
+binarystream &binarystream::operator>>(uint64_t &u64) {
+  uint32_t lower, upper;
   *this >> lower >> upper;
   if (!eof())
-    u64 = static_cast<u_int64_t>(lower) | (static_cast<u_int64_t>(upper) << 32);
+    u64 = static_cast<uint64_t>(lower) | (static_cast<uint64_t>(upper) << 32);
   return *this;
 }
 
 binarystream &binarystream::operator<<(const string &str) {
   if (str.length() > USHRT_MAX) {
     // truncate to 16-bit length
-    *this << static_cast<u_int16_t>(USHRT_MAX);
+    *this << static_cast<uint16_t>(USHRT_MAX);
     stream_.write(str.c_str(), USHRT_MAX);
   } else {
-    *this << (u_int16_t)(str.length() & 0xFFFF);
+    *this << (uint16_t)(str.length() & 0xFFFF);
     stream_.write(str.c_str(), str.length());
   }
   return *this;
 }
 
-binarystream &binarystream::operator<<(u_int8_t u8) {
+binarystream &binarystream::operator<<(uint8_t u8) {
   stream_.write((const char*)&u8, 1);
   return *this;
 }
 
-binarystream &binarystream::operator<<(u_int16_t u16) {
+binarystream &binarystream::operator<<(uint16_t u16) {
   u16 = htons(u16);
   stream_.write((const char*)&u16, 2);
   return *this;
 }
 
-binarystream &binarystream::operator<<(u_int32_t u32) {
+binarystream &binarystream::operator<<(uint32_t u32) {
   u32 = htonl(u32);
   stream_.write((const char*)&u32, 4);
   return *this;
 }
 
-binarystream &binarystream::operator<<(u_int64_t u64) {
+binarystream &binarystream::operator<<(uint64_t u64) {
   // write 64-bit ints as two 32-bit ints, so we can byte-swap them easily
-  u_int32_t lower = static_cast<u_int32_t>(u64 & 0xFFFFFFFF);
-  u_int32_t upper = static_cast<u_int32_t>(u64 >> 32);
+  uint32_t lower = static_cast<uint32_t>(u64 & 0xFFFFFFFF);
+  uint32_t upper = static_cast<uint32_t>(u64 >> 32);
   *this << lower << upper;
   return *this;
 }
 
 }  // namespace google_breakpad
diff --git a/src/processor/binarystream.h b/src/processor/binarystream.h
--- a/src/processor/binarystream.h
+++ b/src/processor/binarystream.h
@@ -51,27 +51,27 @@
   explicit binarystream(const string &str,
                         ios_base::openmode which = ios_base::out|ios_base::in)
     : stream_(str, which) {}
   explicit binarystream(const char *str, size_t size,
                         ios_base::openmode which = ios_base::out|ios_base::in)
     : stream_(string(str, size), which) {}
 
   binarystream &operator>>(string &str);
-  binarystream &operator>>(u_int8_t &u8);
-  binarystream &operator>>(u_int16_t &u16);
-  binarystream &operator>>(u_int32_t &u32);
-  binarystream &operator>>(u_int64_t &u64);
+  binarystream &operator>>(uint8_t &u8);
+  binarystream &operator>>(uint16_t &u16);
+  binarystream &operator>>(uint32_t &u32);
+  binarystream &operator>>(uint64_t &u64);
 
   // Note: strings are truncated at 65535 characters
   binarystream &operator<<(const string &str);
-  binarystream &operator<<(u_int8_t u8);
-  binarystream &operator<<(u_int16_t u16);
-  binarystream &operator<<(u_int32_t u32);
-  binarystream &operator<<(u_int64_t u64);
+  binarystream &operator<<(uint8_t u8);
+  binarystream &operator<<(uint16_t u16);
+  binarystream &operator<<(uint32_t u32);
+  binarystream &operator<<(uint64_t u64);
 
   // Forward a few methods directly from the stream object
   bool eof() const { return stream_.eof(); }
   void clear() { stream_.clear(); }
   string str() const { return stream_.str(); }
   void str(const string &s) { stream_.str(s); }
     
   // Seek both read and write pointers to the beginning of the stream.
diff --git a/src/processor/binarystream_unittest.cc b/src/processor/binarystream_unittest.cc
--- a/src/processor/binarystream_unittest.cc
+++ b/src/processor/binarystream_unittest.cc
@@ -42,69 +42,69 @@
 
 
 class BinaryStreamBasicTest : public ::testing::Test {
 protected:
   binarystream stream;
 };
  
 TEST_F(BinaryStreamBasicTest, ReadU8) {
-  u_int8_t u8 = 0;
+  uint8_t u8 = 0;
   ASSERT_FALSE(stream.eof());
   stream >> u8;
   ASSERT_TRUE(stream.eof());
   EXPECT_EQ(0U, u8);
   stream.rewind();
   stream.clear();
-  stream << (u_int8_t)1;
+  stream << (uint8_t)1;
   ASSERT_FALSE(stream.eof());
   stream >> u8;
   EXPECT_EQ(1, u8);
   EXPECT_FALSE(stream.eof());
 }
 
 TEST_F(BinaryStreamBasicTest, ReadU16) {
-  u_int16_t u16 = 0;
+  uint16_t u16 = 0;
   ASSERT_FALSE(stream.eof());
   stream >> u16;
   ASSERT_TRUE(stream.eof());
   EXPECT_EQ(0U, u16);
   stream.rewind();
   stream.clear();
-  stream << (u_int16_t)1;
+  stream << (uint16_t)1;
   ASSERT_FALSE(stream.eof());
   stream >> u16;
   EXPECT_EQ(1, u16);
   EXPECT_FALSE(stream.eof());
 }
 
 TEST_F(BinaryStreamBasicTest, ReadU32) {
-  u_int32_t u32 = 0;
+  uint32_t u32 = 0;
   ASSERT_FALSE(stream.eof());
   stream >> u32;
   ASSERT_TRUE(stream.eof());
   EXPECT_EQ(0U, u32);
   stream.rewind();
   stream.clear();
-  stream << (u_int32_t)1;
+  stream << (uint32_t)1;
   ASSERT_FALSE(stream.eof());
   stream >> u32;
   EXPECT_EQ(1U, u32);
   EXPECT_FALSE(stream.eof());
 }
 
 TEST_F(BinaryStreamBasicTest, ReadU64) {
-  u_int64_t u64 = 0;
+  uint64_t u64 = 0;
   ASSERT_FALSE(stream.eof());
   stream >> u64;
   ASSERT_TRUE(stream.eof());
   EXPECT_EQ(0U, u64);
   stream.rewind();
   stream.clear();
-  stream << (u_int64_t)1;
+  stream << (uint64_t)1;
   ASSERT_FALSE(stream.eof());
   stream >> u64;
   EXPECT_EQ(1U, u64);
   EXPECT_FALSE(stream.eof());
 }
 
 TEST_F(BinaryStreamBasicTest, ReadString) {
   string s("");
@@ -132,18 +132,18 @@
 TEST_F(BinaryStreamBasicTest, ReadEmptyString) {
   string s("abc");
   stream << string("");
   stream >> s;
   EXPECT_EQ("", s);
 }
 
 TEST_F(BinaryStreamBasicTest, ReadMultiU8) {
-  const u_int8_t ea = 0, eb = 100, ec = 200, ed = 0xFF;
-  u_int8_t a, b, c, d, e;
+  const uint8_t ea = 0, eb = 100, ec = 200, ed = 0xFF;
+  uint8_t a, b, c, d, e;
   stream << ea << eb << ec << ed;
   stream >> a >> b >> c >> d;
   ASSERT_FALSE(stream.eof());
   EXPECT_EQ(ea, a);
   EXPECT_EQ(eb, b);
   EXPECT_EQ(ec, c);
   EXPECT_EQ(ed, d);
   ASSERT_FALSE(stream.eof());
@@ -162,18 +162,18 @@
   EXPECT_EQ(eb, b);
   EXPECT_EQ(ec, c);
   EXPECT_EQ(ed, d);
   EXPECT_EQ(0U, e);
   EXPECT_TRUE(stream.eof());
 }
 
 TEST_F(BinaryStreamBasicTest, ReadMultiU16) {
-  const u_int16_t ea = 0, eb = 0x100, ec = 0x8000, ed = 0xFFFF;
-  u_int16_t a, b, c, d, e;
+  const uint16_t ea = 0, eb = 0x100, ec = 0x8000, ed = 0xFFFF;
+  uint16_t a, b, c, d, e;
   stream << ea << eb << ec << ed;
   stream >> a >> b >> c >> d;
   ASSERT_FALSE(stream.eof());
   EXPECT_EQ(ea, a);
   EXPECT_EQ(eb, b);
   EXPECT_EQ(ec, c);
   EXPECT_EQ(ed, d);
   ASSERT_FALSE(stream.eof());
@@ -192,18 +192,18 @@
   EXPECT_EQ(eb, b);
   EXPECT_EQ(ec, c);
   EXPECT_EQ(ed, d);
   EXPECT_EQ(0U, e);
   EXPECT_TRUE(stream.eof());
 }
 
 TEST_F(BinaryStreamBasicTest, ReadMultiU32) {
-  const u_int32_t ea = 0, eb = 0x10000, ec = 0x8000000, ed = 0xFFFFFFFF;
-  u_int32_t a, b, c, d, e;
+  const uint32_t ea = 0, eb = 0x10000, ec = 0x8000000, ed = 0xFFFFFFFF;
+  uint32_t a, b, c, d, e;
   stream << ea << eb << ec << ed;
   stream >> a >> b >> c >> d;
   ASSERT_FALSE(stream.eof());
   EXPECT_EQ(ea, a);
   EXPECT_EQ(eb, b);
   EXPECT_EQ(ec, c);
   EXPECT_EQ(ed, d);
   ASSERT_FALSE(stream.eof());
@@ -222,19 +222,19 @@
   EXPECT_EQ(eb, b);
   EXPECT_EQ(ec, c);
   EXPECT_EQ(ed, d);
   EXPECT_EQ(0U, e);
   EXPECT_TRUE(stream.eof());
 }
 
 TEST_F(BinaryStreamBasicTest, ReadMultiU64) {
-  const u_int64_t ea = 0, eb = 0x10000, ec = 0x100000000ULL,
+  const uint64_t ea = 0, eb = 0x10000, ec = 0x100000000ULL,
     ed = 0xFFFFFFFFFFFFFFFFULL;
-  u_int64_t a, b, c, d, e;
+  uint64_t a, b, c, d, e;
   stream << ea << eb << ec << ed;
   stream >> a >> b >> c >> d;
   ASSERT_FALSE(stream.eof());
   EXPECT_EQ(ea, a);
   EXPECT_EQ(eb, b);
   EXPECT_EQ(ec, c);
   EXPECT_EQ(ed, d);
   ASSERT_FALSE(stream.eof());
@@ -253,73 +253,73 @@
   EXPECT_EQ(eb, b);
   EXPECT_EQ(ec, c);
   EXPECT_EQ(ed, d);
   EXPECT_EQ(0U, e);
   EXPECT_TRUE(stream.eof());
 }
 
 TEST_F(BinaryStreamBasicTest, ReadMixed) {
-  const u_int8_t e8 = 0x10;
-  const u_int16_t e16 = 0x2020;
-  const u_int32_t e32 = 0x30303030;
-  const u_int64_t e64 = 0x4040404040404040ULL;
+  const uint8_t e8 = 0x10;
+  const uint16_t e16 = 0x2020;
+  const uint32_t e32 = 0x30303030;
+  const uint64_t e64 = 0x4040404040404040ULL;
   const string es = "test";
-  u_int8_t u8 = 0;
-  u_int16_t u16 = 0;
-  u_int32_t u32 = 0;
-  u_int64_t u64 = 0;
+  uint8_t u8 = 0;
+  uint16_t u16 = 0;
+  uint32_t u32 = 0;
+  uint64_t u64 = 0;
   string s("test");
   stream << e8 << e16 << e32 << e64 << es;
   stream >> u8 >> u16 >> u32 >> u64 >> s;
   EXPECT_FALSE(stream.eof());
   EXPECT_EQ(e8, u8);
   EXPECT_EQ(e16, u16);
   EXPECT_EQ(e32, u32);
   EXPECT_EQ(e64, u64);
   EXPECT_EQ(es, s);
 }
 
 TEST_F(BinaryStreamBasicTest, ReadStringMissing) {
   // ensure that reading a string where only the length is present fails
-  u_int16_t u16 = 8;
+  uint16_t u16 = 8;
   stream << u16;
   stream.rewind();
   string s("");
   stream >> s;
   EXPECT_EQ("", s);
   EXPECT_TRUE(stream.eof());
 }
 
 TEST_F(BinaryStreamBasicTest, ReadStringTruncated) {
   // ensure that reading a string where not all the data is present fails
-  u_int16_t u16 = 8;
+  uint16_t u16 = 8;
   stream << u16;
-  stream << (u_int8_t)'t' << (u_int8_t)'e' << (u_int8_t)'s' << (u_int8_t)'t';
+  stream << (uint8_t)'t' << (uint8_t)'e' << (uint8_t)'s' << (uint8_t)'t';
   stream.rewind();
   string s("");
   stream >> s;
   EXPECT_EQ("", s);
   EXPECT_TRUE(stream.eof());
 }
 
 TEST_F(BinaryStreamBasicTest, StreamByteLength) {
   // Test that the stream buffer contains the right amount of data
-  stream << (u_int8_t)0 << (u_int16_t)1 << (u_int32_t)2 << (u_int64_t)3
+  stream << (uint8_t)0 << (uint16_t)1 << (uint32_t)2 << (uint64_t)3
          << string("test");
   string s = stream.str();
   EXPECT_EQ(21U, s.length());
 }
 
 TEST_F(BinaryStreamBasicTest, AppendStreamResultsByteLength) {
   // Test that appending the str() results from two streams
   // gives the right byte length
   binarystream stream2;
-  stream << (u_int8_t)0 << (u_int16_t)1;
-  stream2 << (u_int32_t)0 << (u_int64_t)2
+  stream << (uint8_t)0 << (uint16_t)1;
+  stream2 << (uint32_t)0 << (uint64_t)2
           << string("test");
   string s = stream.str();
   string s2 = stream2.str();
   s.append(s2);
   EXPECT_EQ(21U, s.length());
 }
 
 TEST_F(BinaryStreamBasicTest, StreamSetStr) {
@@ -339,38 +339,38 @@
   EXPECT_EQ("test", s);
 }
 
 class BinaryStreamU8Test : public ::testing::Test {
 protected:
   binarystream stream;
 
   void SetUp() {
-    stream << (u_int8_t)1;
+    stream << (uint8_t)1;
   }
 };
 
 TEST_F(BinaryStreamU8Test, ReadU16) {
-  u_int16_t u16 = 0;
+  uint16_t u16 = 0;
   ASSERT_FALSE(stream.eof());
   stream >> u16;
   ASSERT_TRUE(stream.eof());
   EXPECT_EQ(0U, u16);
 }
 
 TEST_F(BinaryStreamU8Test, ReadU32) {
-  u_int32_t u32 = 0;
+  uint32_t u32 = 0;
   ASSERT_FALSE(stream.eof());
   stream >> u32;
   ASSERT_TRUE(stream.eof());
   EXPECT_EQ(0U, u32);
 }
 
 TEST_F(BinaryStreamU8Test, ReadU64) {
-  u_int64_t u64 = 0;
+  uint64_t u64 = 0;
   ASSERT_FALSE(stream.eof());
   stream >> u64;
   ASSERT_TRUE(stream.eof());
   EXPECT_EQ(0U, u64);
 }
 
 TEST_F(BinaryStreamU8Test, ReadString) {
   string s("");
@@ -379,29 +379,29 @@
   ASSERT_TRUE(stream.eof());
   EXPECT_EQ("", s);
 }
 
 
 TEST(BinaryStreamTest, InitWithData) {
   const char *data = "abcd";
   binarystream stream(data);
-  u_int8_t a, b, c, d;
+  uint8_t a, b, c, d;
   stream >> a >> b >> c >> d;
   ASSERT_FALSE(stream.eof());
   EXPECT_EQ('a', a);
   EXPECT_EQ('b', b);
   EXPECT_EQ('c', c);
   EXPECT_EQ('d', d);
 }
 
 TEST(BinaryStreamTest, InitWithDataLeadingNull) {
   const char *data = "\0abcd";
   binarystream stream(data, 5);
-  u_int8_t z, a, b, c, d;
+  uint8_t z, a, b, c, d;
   stream >> z >> a >> b >> c >> d;
   ASSERT_FALSE(stream.eof());
   EXPECT_EQ(0U, z);
   EXPECT_EQ('a', a);
   EXPECT_EQ('b', b);
   EXPECT_EQ('c', c);
   EXPECT_EQ('d', d);
 }
@@ -410,17 +410,17 @@
   vector<char> data;
   data.push_back('a');
   data.push_back('b');
   data.push_back('c');
   data.push_back('d');
   data.push_back('e');
   data.resize(4);
   binarystream stream(&data[0], data.size());
-  u_int8_t a, b, c, d;
+  uint8_t a, b, c, d;
   stream >> a >> b >> c >> d;
   ASSERT_FALSE(stream.eof());
   EXPECT_EQ('a', a);
   EXPECT_EQ('b', b);
   EXPECT_EQ('c', c);
   EXPECT_EQ('d', d);
 }
 
diff --git a/src/processor/cfi_frame_info.cc b/src/processor/cfi_frame_info.cc
--- a/src/processor/cfi_frame_info.cc
+++ b/src/processor/cfi_frame_info.cc
@@ -83,24 +83,24 @@
 
   (*caller_registers)[".ra"] = ra;
   (*caller_registers)[".cfa"] = cfa;
 
   return true;
 }
 
 // Explicit instantiations for 32-bit and 64-bit architectures.
-template bool CFIFrameInfo::FindCallerRegs<u_int32_t>(
-    const RegisterValueMap<u_int32_t> &registers,
+template bool CFIFrameInfo::FindCallerRegs<uint32_t>(
+    const RegisterValueMap<uint32_t> &registers,
     const MemoryRegion &memory,
-    RegisterValueMap<u_int32_t> *caller_registers) const;
-template bool CFIFrameInfo::FindCallerRegs<u_int64_t>(
-    const RegisterValueMap<u_int64_t> &registers,
+    RegisterValueMap<uint32_t> *caller_registers) const;
+template bool CFIFrameInfo::FindCallerRegs<uint64_t>(
+    const RegisterValueMap<uint64_t> &registers,
     const MemoryRegion &memory,
-    RegisterValueMap<u_int64_t> *caller_registers) const;
+    RegisterValueMap<uint64_t> *caller_registers) const;
 
 string CFIFrameInfo::Serialize() const {
   std::ostringstream stream;
 
   if (!cfa_rule_.empty()) {
     stream << ".cfa: " << cfa_rule_;
   }
   if (!ra_rule_.empty()) {
diff --git a/src/processor/cfi_frame_info.h b/src/processor/cfi_frame_info.h
--- a/src/processor/cfi_frame_info.h
+++ b/src/processor/cfi_frame_info.h
@@ -75,18 +75,18 @@
   void SetCFARule(const string &expression) { cfa_rule_ = expression; }
   void SetRARule(const string &expression)  { ra_rule_ = expression; }
   void SetRegisterRule(const string &register_name, const string &expression) {
     register_rules_[register_name] = expression;
   }
 
   // Compute the values of the calling frame's registers, according to
   // this rule set. Use ValueType in expression evaluation; this
-  // should be u_int32_t on machines with 32-bit addresses, or
-  // u_int64_t on machines with 64-bit addresses.
+  // should be uint32_t on machines with 32-bit addresses, or
+  // uint64_t on machines with 64-bit addresses.
   //
   // Return true on success, false otherwise.
   //
   // MEMORY provides access to the contents of the stack. REGISTERS is
   // a dictionary mapping the names of registers whose values are
   // known in the current frame to their values. CALLER_REGISTERS is
   // populated with the values of the recoverable registers in the
   // frame that called the current frame.
@@ -199,17 +199,17 @@
 //
 // This class template doesn't use any internal knowledge of CFIFrameInfo
 // or the other stack walking structures; it just uses the public interface
 // of CFIFrameInfo to do the usual things. But the logic it handles should
 // be common to many different architectures' stack walkers, so wrapping it
 // up in a class should allow the walkers to share code.
 //
 // RegisterType should be the type of this architecture's registers, either
-// u_int32_t or u_int64_t. RawContextType should be the raw context
+// uint32_t or uint64_t. RawContextType should be the raw context
 // structure type for this architecture.
 template <typename RegisterType, class RawContextType>
 class SimpleCFIWalker {
  public:
   // A structure describing one architecture register.
   struct RegisterSet {
     // The register name, as it appears in STACK CFI rules.
     const char *name;
diff --git a/src/processor/cfi_frame_info_unittest.cc b/src/processor/cfi_frame_info_unittest.cc
--- a/src/processor/cfi_frame_info_unittest.cc
+++ b/src/processor/cfi_frame_info_unittest.cc
@@ -49,70 +49,70 @@
 using testing::AtMost;
 using testing::DoAll;
 using testing::Return;
 using testing::SetArgumentPointee;
 using testing::Test;
 
 class MockMemoryRegion: public MemoryRegion {
  public:
-  MOCK_CONST_METHOD0(GetBase, u_int64_t());
-  MOCK_CONST_METHOD0(GetSize, u_int32_t());
-  MOCK_CONST_METHOD2(GetMemoryAtAddress, bool(u_int64_t, u_int8_t *));
-  MOCK_CONST_METHOD2(GetMemoryAtAddress, bool(u_int64_t, u_int16_t *));
-  MOCK_CONST_METHOD2(GetMemoryAtAddress, bool(u_int64_t, u_int32_t *));
-  MOCK_CONST_METHOD2(GetMemoryAtAddress, bool(u_int64_t, u_int64_t *));
+  MOCK_CONST_METHOD0(GetBase, uint64_t());
+  MOCK_CONST_METHOD0(GetSize, uint32_t());
+  MOCK_CONST_METHOD2(GetMemoryAtAddress, bool(uint64_t, uint8_t *));
+  MOCK_CONST_METHOD2(GetMemoryAtAddress, bool(uint64_t, uint16_t *));
+  MOCK_CONST_METHOD2(GetMemoryAtAddress, bool(uint64_t, uint32_t *));
+  MOCK_CONST_METHOD2(GetMemoryAtAddress, bool(uint64_t, uint64_t *));
 };
 
 // Handy definitions for all tests.
 struct CFIFixture {
 
   // Set up the mock memory object to expect no references.
   void ExpectNoMemoryReferences() {
     EXPECT_CALL(memory, GetBase()).Times(0);
     EXPECT_CALL(memory, GetSize()).Times(0);
-    EXPECT_CALL(memory, GetMemoryAtAddress(_, A<u_int8_t *>())).Times(0);
-    EXPECT_CALL(memory, GetMemoryAtAddress(_, A<u_int16_t *>())).Times(0);
-    EXPECT_CALL(memory, GetMemoryAtAddress(_, A<u_int32_t *>())).Times(0);
-    EXPECT_CALL(memory, GetMemoryAtAddress(_, A<u_int64_t *>())).Times(0);
+    EXPECT_CALL(memory, GetMemoryAtAddress(_, A<uint8_t *>())).Times(0);
+    EXPECT_CALL(memory, GetMemoryAtAddress(_, A<uint16_t *>())).Times(0);
+    EXPECT_CALL(memory, GetMemoryAtAddress(_, A<uint32_t *>())).Times(0);
+    EXPECT_CALL(memory, GetMemoryAtAddress(_, A<uint64_t *>())).Times(0);
   }
 
   CFIFrameInfo cfi;
   MockMemoryRegion memory;
-  CFIFrameInfo::RegisterValueMap<u_int64_t> registers, caller_registers;
+  CFIFrameInfo::RegisterValueMap<uint64_t> registers, caller_registers;
 };
 
 class Simple: public CFIFixture, public Test { };
 
 // FindCallerRegs should fail if no .cfa rule is provided.
 TEST_F(Simple, NoCFA) {
   ExpectNoMemoryReferences();
 
   cfi.SetRARule("0");
-  ASSERT_FALSE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_FALSE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                              &caller_registers));
   ASSERT_EQ(".ra: 0", cfi.Serialize());
 }
 
 // FindCallerRegs should fail if no .ra rule is provided.
 TEST_F(Simple, NoRA) {
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule("0");
-  ASSERT_FALSE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_FALSE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                              &caller_registers));
   ASSERT_EQ(".cfa: 0", cfi.Serialize());
 }
 
 TEST_F(Simple, SetCFAAndRARule) {
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule("330903416631436410");
   cfi.SetRARule("5870666104170902211");
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
   ASSERT_EQ(2U, caller_registers.size());
   ASSERT_EQ(330903416631436410ULL, caller_registers[".cfa"]);
   ASSERT_EQ(5870666104170902211ULL, caller_registers[".ra"]);
 
   ASSERT_EQ(".cfa: 330903416631436410 .ra: 5870666104170902211",
             cfi.Serialize());
 }
@@ -121,17 +121,17 @@
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule("$temp1 68737028 = $temp2 61072337 = $temp1 $temp2 -");
   cfi.SetRARule(".cfa 99804755 +");
   cfi.SetRegisterRule("register1", ".cfa 54370437 *");
   cfi.SetRegisterRule("vodkathumbscrewingly", "24076308 .cfa +");
   cfi.SetRegisterRule("pubvexingfjordschmaltzy", ".cfa 29801007 -");
   cfi.SetRegisterRule("uncopyrightables", "92642917 .cfa /");
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
   ASSERT_EQ(6U, caller_registers.size());
   ASSERT_EQ(7664691U,           caller_registers[".cfa"]);
   ASSERT_EQ(107469446U,         caller_registers[".ra"]);
   ASSERT_EQ(416732599139967ULL, caller_registers["register1"]);
   ASSERT_EQ(31740999U,          caller_registers["vodkathumbscrewingly"]);
   ASSERT_EQ(-22136316ULL,       caller_registers["pubvexingfjordschmaltzy"]);
   ASSERT_EQ(12U,                caller_registers["uncopyrightables"]);
@@ -145,152 +145,152 @@
 }
 
 TEST_F(Simple, RulesOverride) {
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule("330903416631436410");
   cfi.SetRARule("5870666104170902211");
   cfi.SetCFARule("2828089117179001");
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
   ASSERT_EQ(2U, caller_registers.size());
   ASSERT_EQ(2828089117179001ULL, caller_registers[".cfa"]);
   ASSERT_EQ(5870666104170902211ULL, caller_registers[".ra"]);
   ASSERT_EQ(".cfa: 2828089117179001 .ra: 5870666104170902211",
             cfi.Serialize());
 }
 
 class Scope: public CFIFixture, public Test { };
 
 // There should be no value for .cfa in scope when evaluating the CFA rule.
 TEST_F(Scope, CFALacksCFA) {
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule(".cfa");
   cfi.SetRARule("0");
-  ASSERT_FALSE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_FALSE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                              &caller_registers));
 }
 
 // There should be no value for .ra in scope when evaluating the CFA rule.
 TEST_F(Scope, CFALacksRA) {
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule(".ra");
   cfi.SetRARule("0");
-  ASSERT_FALSE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_FALSE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                              &caller_registers));
 }
 
 // The current frame's registers should be in scope when evaluating
 // the CFA rule.
 TEST_F(Scope, CFASeesCurrentRegs) {
   ExpectNoMemoryReferences();
 
   registers[".baraminology"] = 0x06a7bc63e4f13893ULL;
   registers[".ornithorhynchus"] = 0x5e0bf850bafce9d2ULL;
   cfi.SetCFARule(".baraminology .ornithorhynchus +");
   cfi.SetRARule("0");
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
   ASSERT_EQ(2U, caller_registers.size());
   ASSERT_EQ(0x06a7bc63e4f13893ULL + 0x5e0bf850bafce9d2ULL,
             caller_registers[".cfa"]);
 }
 
 // .cfa should be in scope in the return address expression.
 TEST_F(Scope, RASeesCFA) {
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule("48364076");
   cfi.SetRARule(".cfa");
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
   ASSERT_EQ(2U, caller_registers.size());
   ASSERT_EQ(48364076U, caller_registers[".ra"]);
 }
 
 // There should be no value for .ra in scope when evaluating the CFA rule.
 TEST_F(Scope, RALacksRA) {
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule("0");
   cfi.SetRARule(".ra");
-  ASSERT_FALSE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_FALSE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                              &caller_registers));
 }
 
 // The current frame's registers should be in scope in the return
 // address expression.
 TEST_F(Scope, RASeesCurrentRegs) {
   ExpectNoMemoryReferences();
 
   registers["noachian"] = 0x54dc4a5d8e5eb503ULL;
   cfi.SetCFARule("10359370");
   cfi.SetRARule("noachian");
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
   ASSERT_EQ(2U, caller_registers.size());
   ASSERT_EQ(0x54dc4a5d8e5eb503ULL, caller_registers[".ra"]);
 }
 
 // .cfa should be in scope for register rules.
 TEST_F(Scope, RegistersSeeCFA) {
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule("6515179");
   cfi.SetRARule(".cfa");
   cfi.SetRegisterRule("rogerian", ".cfa");
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
   ASSERT_EQ(3U, caller_registers.size());
   ASSERT_EQ(6515179U, caller_registers["rogerian"]);
 }
 
 // The return address should not be in scope for register rules.
 TEST_F(Scope, RegsLackRA) {
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule("42740329");
   cfi.SetRARule("27045204");
   cfi.SetRegisterRule("$r1", ".ra");
-  ASSERT_FALSE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_FALSE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                              &caller_registers));
 }
 
 // Register rules can see the current frame's register values.
 TEST_F(Scope, RegsSeeRegs) {
   ExpectNoMemoryReferences();
 
   registers["$r1"] = 0x6ed3582c4bedb9adULL;
   registers["$r2"] = 0xd27d9e742b8df6d0ULL;
   cfi.SetCFARule("88239303");
   cfi.SetRARule("30503835");
   cfi.SetRegisterRule("$r1", "$r1 42175211 = $r2");
   cfi.SetRegisterRule("$r2", "$r2 21357221 = $r1");
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
   ASSERT_EQ(4U, caller_registers.size());
   ASSERT_EQ(0xd27d9e742b8df6d0ULL, caller_registers["$r1"]);
   ASSERT_EQ(0x6ed3582c4bedb9adULL, caller_registers["$r2"]);
 }
 
 // Each rule's temporaries are separate.
 TEST_F(Scope, SeparateTempsRA) {
   ExpectNoMemoryReferences();
 
   cfi.SetCFARule("$temp1 76569129 = $temp1");
   cfi.SetRARule("0");
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
 
   cfi.SetCFARule("$temp1 76569129 = $temp1");
   cfi.SetRARule("$temp1");
-  ASSERT_FALSE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_FALSE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                              &caller_registers));
 }
 
 class MockCFIRuleParserHandler: public CFIRuleParser::Handler {
  public:
   MOCK_METHOD1(CFARule, void(const string &));
   MOCK_METHOD1(RARule,  void(const string &));
   MOCK_METHOD2(RegisterRule, void(const string &, const string &));
@@ -422,53 +422,53 @@
 
 class ParseHandler: public ParseHandlerFixture, public Test { };
 
 TEST_F(ParseHandler, CFARARule) {
   handler.CFARule("reg-for-cfa");
   handler.RARule("reg-for-ra");
   registers["reg-for-cfa"] = 0x268a9a4a3821a797ULL;
   registers["reg-for-ra"] = 0x6301b475b8b91c02ULL;
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
   ASSERT_EQ(0x268a9a4a3821a797ULL, caller_registers[".cfa"]);
   ASSERT_EQ(0x6301b475b8b91c02ULL, caller_registers[".ra"]);
 }
 
 TEST_F(ParseHandler, RegisterRules) {
   handler.CFARule("reg-for-cfa");
   handler.RARule("reg-for-ra");
   handler.RegisterRule("reg1", "reg-for-reg1");
   handler.RegisterRule("reg2", "reg-for-reg2");
   registers["reg-for-cfa"] = 0x268a9a4a3821a797ULL;
   registers["reg-for-ra"] = 0x6301b475b8b91c02ULL;
   registers["reg-for-reg1"] = 0x06cde8e2ff062481ULL;
   registers["reg-for-reg2"] = 0xff0c4f76403173e2ULL;
-  ASSERT_TRUE(cfi.FindCallerRegs<u_int64_t>(registers, memory,
+  ASSERT_TRUE(cfi.FindCallerRegs<uint64_t>(registers, memory,
                                             &caller_registers));
   ASSERT_EQ(0x268a9a4a3821a797ULL, caller_registers[".cfa"]);
   ASSERT_EQ(0x6301b475b8b91c02ULL, caller_registers[".ra"]);
   ASSERT_EQ(0x06cde8e2ff062481ULL, caller_registers["reg1"]);
   ASSERT_EQ(0xff0c4f76403173e2ULL, caller_registers["reg2"]);
 }
 
 struct SimpleCFIWalkerFixture {
   struct RawContext {
-    u_int64_t r0, r1, r2, r3, r4, sp, pc;
+    uint64_t r0, r1, r2, r3, r4, sp, pc;
   };
   enum Validity {
     R0_VALID = 0x01,
     R1_VALID = 0x02,
     R2_VALID = 0x04,
     R3_VALID = 0x08,
     R4_VALID = 0x10,
     SP_VALID = 0x20,
     PC_VALID = 0x40
   };
-  typedef SimpleCFIWalker<u_int64_t, RawContext> CFIWalker;
+  typedef SimpleCFIWalker<uint64_t, RawContext> CFIWalker;
 
   SimpleCFIWalkerFixture()
       : walker(register_map,
                sizeof(register_map) / sizeof(register_map[0])) { }
 
   static CFIWalker::RegisterSet register_map[7];
   CFIFrameInfo call_frame_info;
   CFIWalker walker;
@@ -499,26 +499,26 @@
   // cfa -> 
   //
   // r0 has been saved on the stack.
   // r1 has been saved in r2.
   // r2 and r3 are not recoverable.
   // r4 is not recoverable, even though it is a callee-saves register.
   //    Some earlier frame's unwinder must have failed to recover it.
 
-  u_int64_t stack_top = 0x83254944b20d5512ULL;
+  uint64_t stack_top = 0x83254944b20d5512ULL;
 
   // Saved r0.
   EXPECT_CALL(memory,
-              GetMemoryAtAddress(stack_top, A<u_int64_t *>()))
+              GetMemoryAtAddress(stack_top, A<uint64_t *>()))
       .WillRepeatedly(DoAll(SetArgumentPointee<1>(0xdc1975eba8602302ULL),
                             Return(true)));
   // Saved return address.
   EXPECT_CALL(memory,
-              GetMemoryAtAddress(stack_top + 16, A<u_int64_t *>()))
+              GetMemoryAtAddress(stack_top + 16, A<uint64_t *>()))
       .WillRepeatedly(DoAll(SetArgumentPointee<1>(0xba5ad6d9acce28deULL),
                             Return(true)));
 
   call_frame_info.SetCFARule("sp 24 +");
   call_frame_info.SetRARule(".cfa 8 - ^");
   call_frame_info.SetRegisterRule("r0", ".cfa 24 - ^");
   call_frame_info.SetRegisterRule("r1", "r2");
 
diff --git a/src/processor/disassembler_x86.cc b/src/processor/disassembler_x86.cc
--- a/src/processor/disassembler_x86.cc
+++ b/src/processor/disassembler_x86.cc
@@ -26,19 +26,19 @@
 
 #include "processor/disassembler_x86.h"
 
 #include <string.h>
 #include <unistd.h>
 
 namespace google_breakpad {
 
-DisassemblerX86::DisassemblerX86(const u_int8_t *bytecode,
-                                 u_int32_t size,
-                                 u_int32_t virtual_address) :
+DisassemblerX86::DisassemblerX86(const uint8_t *bytecode,
+                                 uint32_t size,
+                                 uint32_t virtual_address) :
                                      bytecode_(bytecode),
                                      size_(size),
                                      virtual_address_(virtual_address),
                                      current_byte_offset_(0),
                                      current_inst_offset_(0),
                                      instr_valid_(false),
                                      register_valid_(false),
                                      pushed_bad_value_(false),
@@ -49,25 +49,25 @@
 
 DisassemblerX86::~DisassemblerX86() {
   if (instr_valid_)
     libdis::x86_oplist_free(&current_instr_);
 
   libdis::x86_cleanup();
 }
 
-u_int32_t DisassemblerX86::NextInstruction() {
+uint32_t DisassemblerX86::NextInstruction() {
   if (instr_valid_)
     libdis::x86_oplist_free(&current_instr_);
 
   if (current_byte_offset_ >= size_) {
     instr_valid_ = false;
     return 0;
   }
-  u_int32_t instr_size = 0;
+  uint32_t instr_size = 0;
   instr_size = libdis::x86_disasm((unsigned char *)bytecode_, size_,
                           virtual_address_, current_byte_offset_,
                           &current_instr_);
   if (instr_size == 0) {
     instr_valid_ = false;
     return 0;
   }
 
diff --git a/src/processor/disassembler_x86.h b/src/processor/disassembler_x86.h
--- a/src/processor/disassembler_x86.h
+++ b/src/processor/disassembler_x86.h
@@ -32,16 +32,17 @@
 // tests to be run against bytecode to test for various properties.
 //
 // Author: Cris Neckar
 
 #ifndef GOOGLE_BREAKPAD_PROCESSOR_DISASSEMBLER_X86_H_
 #define GOOGLE_BREAKPAD_PROCESSOR_DISASSEMBLER_X86_H_
 
 #include <stddef.h>
+#include <sys/types.h>
 
 #include "google_breakpad/common/breakpad_types.h"
 
 namespace libdis {
 #include "third_party/libdisasm/libdis.h"
 }
 
 namespace google_breakpad {
@@ -57,25 +58,25 @@
   DISX86_BAD_COMPARISON =       0x40
 };
 
 class DisassemblerX86 {
   public:
     // TODO(cdn): Modify this class to take a MemoryRegion instead of just
     // a raw buffer. This will make it easier to use this on arbitrary
     // minidumps without first copying out the code segment.
-    DisassemblerX86(const u_int8_t *bytecode, u_int32_t, u_int32_t);
+    DisassemblerX86(const uint8_t *bytecode, uint32_t, uint32_t);
     ~DisassemblerX86();
 
     // This walks to the next instruction in the memory region and
     // sets flags based on the type of instruction and previous state
     // including any registers marked as bad through setBadRead()
     // or setBadWrite(). This method can be called in a loop to
     // disassemble until the end of a region.
-    u_int32_t NextInstruction();
+    uint32_t NextInstruction();
 
     // Indicates whether the current disassembled instruction was valid.
     bool currentInstructionValid() { return instr_valid_; }
 
     // Returns the current instruction as defined in libdis.h,
     // or NULL if the current instruction is not valid.
     const libdis::x86_insn_t* currentInstruction() {
       return instr_valid_ ? &current_instr_ : NULL;
@@ -85,42 +86,42 @@
     libdis::x86_insn_group currentInstructionGroup() {
       return current_instr_.group;
     }
 
     // Indicates whether a return instruction has been encountered.
     bool endOfBlock() { return end_of_block_; }
 
     // The flags set so far for the disassembly.
-    u_int16_t flags() { return flags_; }
+    uint16_t flags() { return flags_; }
 
     // This sets an indicator that the register used to determine
     // src or dest for the current instruction is tainted. These can
     // be used after examining the current instruction to indicate,
     // for example that a bad read or write occurred and the pointer
     // stored in the register is currently invalid.
     bool setBadRead();
     bool setBadWrite();
 
   protected:
-    const u_int8_t *bytecode_;
-    u_int32_t size_;
-    u_int32_t virtual_address_;
-    u_int32_t current_byte_offset_;
-    u_int32_t current_inst_offset_;
+    const uint8_t *bytecode_;
+    uint32_t size_;
+    uint32_t virtual_address_;
+    uint32_t current_byte_offset_;
+    uint32_t current_inst_offset_;
 
     bool instr_valid_;
     libdis::x86_insn_t current_instr_;
 
     // TODO(cdn): Maybe also track an expression's index register.
     // ex: mov eax, [ebx + ecx]; ebx is base, ecx is index.
     bool register_valid_;
     libdis::x86_reg_t bad_register_;
 
     bool pushed_bad_value_;
     bool end_of_block_;
 
-    u_int16_t flags_;
+    uint16_t flags_;
 };
 
 }  // namespace google_breakpad
 
 #endif  // GOOGLE_BREAKPAD_PROCESSOR_DISASSEMBLER_X86_H_
diff --git a/src/processor/exploitability.cc b/src/processor/exploitability.cc
--- a/src/processor/exploitability.cc
+++ b/src/processor/exploitability.cc
@@ -87,19 +87,19 @@
   }
 
   BPLOG_IF(ERROR, !platform_exploitability) <<
     "No Exploitability module for platform: " <<
     process_state->system_info()->os;
   return platform_exploitability;
 }
 
-bool Exploitability::AddressIsAscii(u_int64_t address) {
+bool Exploitability::AddressIsAscii(uint64_t address) {
   for (int i = 0; i < 8; i++) {
-    u_int8_t byte = (address >> (8*i)) & 0xff;
+    uint8_t byte = (address >> (8*i)) & 0xff;
     if ((byte >= ' ' && byte <= '~') || byte == 0)
       continue;
     return false;
   }
   return true;
 }
 
 }  // namespace google_breakpad
diff --git a/src/processor/exploitability_win.cc b/src/processor/exploitability_win.cc
--- a/src/processor/exploitability_win.cc
+++ b/src/processor/exploitability_win.cc
@@ -45,18 +45,18 @@
 #include "processor/logging.h"
 
 #include "third_party/libdisasm/libdis.h"
 
 namespace google_breakpad {
 
 // The cutoff that we use to judge if and address is likely an offset
 // from various interesting addresses.
-static const u_int64_t kProbableNullOffset = 4096;
-static const u_int64_t kProbableStackOffset = 8192;
+static const uint64_t kProbableNullOffset = 4096;
+static const uint64_t kProbableStackOffset = 8192;
 
 // The various cutoffs for the different ratings.
 static const size_t kHighCutoff        = 100;
 static const size_t kMediumCutoff      = 80;
 static const size_t kLowCutoff         = 50;
 static const size_t kInterestingCutoff = 25;
 
 // Predefined incremental values for conditional weighting.
@@ -93,24 +93,24 @@
   }
 
   MinidumpMemoryList *memory_list = dump_->GetMemoryList();
   bool memory_available = true;
   if (!memory_list) {
     BPLOG(INFO) << "Minidump memory segments not available.";
     memory_available = false;
   }
-  u_int64_t address = process_state_->crash_address();
-  u_int32_t exception_code = raw_exception->exception_record.exception_code;
+  uint64_t address = process_state_->crash_address();
+  uint32_t exception_code = raw_exception->exception_record.exception_code;
 
-  u_int32_t exploitability_weight = 0;
+  uint32_t exploitability_weight = 0;
 
-  u_int64_t stack_ptr = 0;
-  u_int64_t instruction_ptr = 0;
-  u_int64_t this_ptr = 0;
+  uint64_t stack_ptr = 0;
+  uint64_t instruction_ptr = 0;
+  uint64_t this_ptr = 0;
 
   switch (context->GetContextCPU()) {
     case MD_CONTEXT_X86:
       stack_ptr = context->GetContextX86()->esp;
       instruction_ptr = context->GetContextX86()->eip;
       this_ptr = context->GetContextX86()->ecx;
       break;
     case MD_CONTEXT_AMD64:
@@ -206,24 +206,24 @@
         if (memory_available) {
           instruction_region =
               memory_list->GetMemoryRegionForAddress(instruction_ptr);
         }
         if (!near_null && instruction_region &&
             context->GetContextCPU() == MD_CONTEXT_X86 &&
             (bad_read || bad_write)) {
           // Perform checks related to memory around instruction pointer.
-          u_int32_t memory_offset =
+          uint32_t memory_offset =
               instruction_ptr - instruction_region->GetBase();
-          u_int32_t available_memory =
+          uint32_t available_memory =
               instruction_region->GetSize() - memory_offset;
           available_memory = available_memory > kDisassembleBytesBeyondPC ?
               kDisassembleBytesBeyondPC : available_memory;
           if (available_memory) {
-            const u_int8_t *raw_memory =
+            const uint8_t *raw_memory =
                 instruction_region->GetMemory() + memory_offset;
             DisassemblerX86 disassembler(raw_memory,
                                          available_memory,
                                          instruction_ptr);
             disassembler.NextInstruction();
             if (bad_read)
               disassembler.setBadRead();
             else
diff --git a/src/processor/fast_source_line_resolver.cc b/src/processor/fast_source_line_resolver.cc
--- a/src/processor/fast_source_line_resolver.cc
+++ b/src/processor/fast_source_line_resolver.cc
@@ -111,25 +111,25 @@
 WindowsFrameInfo FastSourceLineResolver::CopyWFI(const char *raw) {
   const WindowsFrameInfo::StackInfoTypes type =
      static_cast<const WindowsFrameInfo::StackInfoTypes>(
          *reinterpret_cast<const int32_t*>(raw));
 
   // The first 8 bytes of int data are unused.
   // They correspond to "StackInfoTypes type_;" and "int valid;"
   // data member of WFI.
-  const u_int32_t *para_uint32 = reinterpret_cast<const u_int32_t*>(
+  const uint32_t *para_uint32 = reinterpret_cast<const uint32_t*>(
       raw + 2 * sizeof(int32_t));
 
-  u_int32_t prolog_size = para_uint32[0];;
-  u_int32_t epilog_size = para_uint32[1];
-  u_int32_t parameter_size = para_uint32[2];
-  u_int32_t saved_register_size = para_uint32[3];
-  u_int32_t local_size = para_uint32[4];
-  u_int32_t max_stack_size = para_uint32[5];
+  uint32_t prolog_size = para_uint32[0];;
+  uint32_t epilog_size = para_uint32[1];
+  uint32_t parameter_size = para_uint32[2];
+  uint32_t saved_register_size = para_uint32[3];
+  uint32_t local_size = para_uint32[4];
+  uint32_t max_stack_size = para_uint32[5];
   const char *boolean = reinterpret_cast<const char*>(para_uint32 + 6);
   bool allocates_base_pointer = (*boolean != 0);
   string program_string = boolean + 1;
 
   return WindowsFrameInfo(type,
                           prolog_size,
                           epilog_size,
                           parameter_size,
@@ -141,17 +141,17 @@
 }
 
 // Loads a map from the given buffer in char* type.
 // Does NOT take ownership of mem_buffer.
 // In addition, treat mem_buffer as const char*.
 bool FastSourceLineResolver::Module::LoadMapFromMemory(char *mem_buffer) {
   if (!mem_buffer) return false;
 
-  const u_int32_t *map_sizes = reinterpret_cast<const u_int32_t*>(mem_buffer);
+  const uint32_t *map_sizes = reinterpret_cast<const uint32_t*>(mem_buffer);
 
   unsigned int header_size = kNumberMaps_ * sizeof(unsigned int);
 
   // offsets[]: an array of offset addresses (with respect to mem_buffer),
   // for each "Static***Map" component of Module.
   // "Static***Map": static version of std::map or map wrapper, i.e., StaticMap,
   // StaticAddressMap, StaticContainedRangeMap, and StaticRangeMap.
   unsigned int offsets[kNumberMaps_];
diff --git a/src/processor/fast_source_line_resolver_unittest.cc b/src/processor/fast_source_line_resolver_unittest.cc
--- a/src/processor/fast_source_line_resolver_unittest.cc
+++ b/src/processor/fast_source_line_resolver_unittest.cc
@@ -66,77 +66,77 @@
 using google_breakpad::linked_ptr;
 using google_breakpad::scoped_ptr;
 
 class TestCodeModule : public CodeModule {
  public:
   explicit TestCodeModule(string code_file) : code_file_(code_file) {}
   virtual ~TestCodeModule() {}
 
-  virtual u_int64_t base_address() const { return 0; }
-  virtual u_int64_t size() const { return 0xb000; }
+  virtual uint64_t base_address() const { return 0; }
+  virtual uint64_t size() const { return 0xb000; }
   virtual string code_file() const { return code_file_; }
   virtual string code_identifier() const { return ""; }
   virtual string debug_file() const { return ""; }
   virtual string debug_identifier() const { return ""; }
   virtual string version() const { return ""; }
   virtual const CodeModule* Copy() const {
     return new TestCodeModule(code_file_);
   }
 
  private:
   string code_file_;
 };
 
 // A mock memory region object, for use by the STACK CFI tests.
 class MockMemoryRegion: public MemoryRegion {
-  u_int64_t GetBase() const { return 0x10000; }
-  u_int32_t GetSize() const { return 0x01000; }
-  bool GetMemoryAtAddress(u_int64_t address, u_int8_t *value) const {
+  uint64_t GetBase() const { return 0x10000; }
+  uint32_t GetSize() const { return 0x01000; }
+  bool GetMemoryAtAddress(uint64_t address, uint8_t *value) const {
     *value = address & 0xff;
     return true;
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int16_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint16_t *value) const {
     *value = address & 0xffff;
     return true;
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int32_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint32_t *value) const {
     switch (address) {
       case 0x10008: *value = 0x98ecadc3; break;  // saved %ebx
       case 0x1000c: *value = 0x878f7524; break;  // saved %esi
       case 0x10010: *value = 0x6312f9a5; break;  // saved %edi
       case 0x10014: *value = 0x10038;    break;  // caller's %ebp
       case 0x10018: *value = 0xf6438648; break;  // return address
       default: *value = 0xdeadbeef;      break;  // junk
     }
     return true;
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int64_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint64_t *value) const {
     *value = address;
     return true;
   }
 };
 
 // Verify that, for every association in ACTUAL, EXPECTED has the same
 // association. (That is, ACTUAL's associations should be a subset of
 // EXPECTED's.) Also verify that ACTUAL has associations for ".ra" and
 // ".cfa".
 static bool VerifyRegisters(
     const char *file, int line,
-    const CFIFrameInfo::RegisterValueMap<u_int32_t> &expected,
-    const CFIFrameInfo::RegisterValueMap<u_int32_t> &actual) {
-  CFIFrameInfo::RegisterValueMap<u_int32_t>::const_iterator a;
+    const CFIFrameInfo::RegisterValueMap<uint32_t> &expected,
+    const CFIFrameInfo::RegisterValueMap<uint32_t> &actual) {
+  CFIFrameInfo::RegisterValueMap<uint32_t>::const_iterator a;
   a = actual.find(".cfa");
   if (a == actual.end())
     return false;
   a = actual.find(".ra");
   if (a == actual.end())
     return false;
   for (a = actual.begin(); a != actual.end(); a++) {
-    CFIFrameInfo::RegisterValueMap<u_int32_t>::const_iterator e =
+    CFIFrameInfo::RegisterValueMap<uint32_t>::const_iterator e =
       expected.find(a->first);
     if (e == expected.end()) {
       fprintf(stderr, "%s:%d: unexpected register '%s' recovered, value 0x%x\n",
               file, line, a->first.c_str(), a->second);
       return false;
     }
     if (e->second != a->second) {
       fprintf(stderr,
@@ -275,19 +275,19 @@
   cfi_frame_info.reset(fast_resolver.FindCFIFrameInfo(&frame));
   ASSERT_FALSE(cfi_frame_info.get());
 
   frame.instruction = 0x3e9f;
   frame.module = &module1;
   cfi_frame_info.reset(fast_resolver.FindCFIFrameInfo(&frame));
   ASSERT_FALSE(cfi_frame_info.get());
 
-  CFIFrameInfo::RegisterValueMap<u_int32_t> current_registers;
-  CFIFrameInfo::RegisterValueMap<u_int32_t> caller_registers;
-  CFIFrameInfo::RegisterValueMap<u_int32_t> expected_caller_registers;
+  CFIFrameInfo::RegisterValueMap<uint32_t> current_registers;
+  CFIFrameInfo::RegisterValueMap<uint32_t> caller_registers;
+  CFIFrameInfo::RegisterValueMap<uint32_t> expected_caller_registers;
   MockMemoryRegion memory;
 
   // Regardless of which instruction evaluation takes place at, it
   // should produce the same values for the caller's registers.
   expected_caller_registers[".cfa"] = 0x1001c;
   expected_caller_registers[".ra"]  = 0xf6438648;
   expected_caller_registers["$ebp"] = 0x10038;
   expected_caller_registers["$ebx"] = 0x98ecadc3;
@@ -300,67 +300,67 @@
   current_registers["$esp"] = 0x10018;
   current_registers["$ebp"] = 0x10038;
   current_registers["$ebx"] = 0x98ecadc3;
   current_registers["$esi"] = 0x878f7524;
   current_registers["$edi"] = 0x6312f9a5;
   cfi_frame_info.reset(fast_resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   ASSERT_TRUE(VerifyRegisters(__FILE__, __LINE__,
                               expected_caller_registers, caller_registers));
 
   frame.instruction = 0x3d41;
   current_registers["$esp"] = 0x10014;
   cfi_frame_info.reset(fast_resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   ASSERT_TRUE(VerifyRegisters(__FILE__, __LINE__,
                               expected_caller_registers, caller_registers));
 
   frame.instruction = 0x3d43;
   current_registers["$ebp"] = 0x10014;
   cfi_frame_info.reset(fast_resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   VerifyRegisters(__FILE__, __LINE__,
                   expected_caller_registers, caller_registers);
 
   frame.instruction = 0x3d54;
   current_registers["$ebx"] = 0x6864f054U;
   cfi_frame_info.reset(fast_resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   VerifyRegisters(__FILE__, __LINE__,
                   expected_caller_registers, caller_registers);
 
   frame.instruction = 0x3d5a;
   current_registers["$esi"] = 0x6285f79aU;
   cfi_frame_info.reset(fast_resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   VerifyRegisters(__FILE__, __LINE__,
                   expected_caller_registers, caller_registers);
 
   frame.instruction = 0x3d84;
   current_registers["$edi"] = 0x64061449U;
   cfi_frame_info.reset(fast_resolver.FindCFIFrameInfo(&frame));
   ASSERT_TRUE(cfi_frame_info.get());
   ASSERT_TRUE(cfi_frame_info.get()
-              ->FindCallerRegs<u_int32_t>(current_registers, memory,
+              ->FindCallerRegs<uint32_t>(current_registers, memory,
                                           &caller_registers));
   VerifyRegisters(__FILE__, __LINE__,
                   expected_caller_registers, caller_registers);
 
   frame.instruction = 0x2900;
   frame.module = &module1;
   fast_resolver.FillSourceLineInfo(&frame);
   ASSERT_EQ(frame.function_name, string("PublicSymbol"));
diff --git a/src/processor/logging.cc b/src/processor/logging.cc
--- a/src/processor/logging.cc
+++ b/src/processor/logging.cc
@@ -78,23 +78,23 @@
   stream_ << time_string << ": " << PathnameStripper::File(file) << ":" <<
              line << ": " << severity_string << ": ";
 }
 
 LogStream::~LogStream() {
   stream_ << std::endl;
 }
 
-string HexString(u_int32_t number) {
+string HexString(uint32_t number) {
   char buffer[11];
   snprintf(buffer, sizeof(buffer), "0x%x", number);
   return string(buffer);
 }
 
-string HexString(u_int64_t number) {
+string HexString(uint64_t number) {
   char buffer[19];
   snprintf(buffer, sizeof(buffer), "0x%" PRIx64, number);
   return string(buffer);
 }
 
 string HexString(int number) {
   char buffer[19];
   snprintf(buffer, sizeof(buffer), "0x%x", number);
diff --git a/src/processor/logging.h b/src/processor/logging.h
--- a/src/processor/logging.h
+++ b/src/processor/logging.h
@@ -114,18 +114,18 @@
   LogMessageVoidify() {}
 
   // This has to be an operator with a precedence lower than << but higher
   // than ?:
   void operator&(std::ostream &) {}
 };
 
 // Returns number formatted as a hexadecimal string, such as "0x7b".
-string HexString(u_int32_t number);
-string HexString(u_int64_t number);
+string HexString(uint32_t number);
+string HexString(uint64_t number);
 string HexString(int number);
 
 // Returns the error code as set in the global errno variable, and sets
 // error_string, a required argument, to a string describing that error
 // code.
 int ErrnoString(string *error_string);
 
 }  // namespace google_breakpad
diff --git a/src/processor/map_serializers-inl.h b/src/processor/map_serializers-inl.h
--- a/src/processor/map_serializers-inl.h
+++ b/src/processor/map_serializers-inl.h
@@ -50,17 +50,17 @@
 #include "processor/logging.h"
 
 namespace google_breakpad {
 
 template<typename Key, typename Value>
 size_t StdMapSerializer<Key, Value>::SizeOf(
     const std::map<Key, Value> &m) const {
   size_t size = 0;
-  size_t header_size = (1 + m.size()) * sizeof(u_int32_t);
+  size_t header_size = (1 + m.size()) * sizeof(uint32_t);
   size += header_size;
 
   typename std::map<Key, Value>::const_iterator iter;
   for (iter = m.begin(); iter != m.end(); ++iter) {
     size += key_serializer_.SizeOf(iter->first);
     size += value_serializer_.SizeOf(iter->second);
   }
   return size;
@@ -72,29 +72,29 @@
   if (!dest) {
     BPLOG(ERROR) << "StdMapSerializer failed: write to NULL address.";
     return NULL;
   }
   char *start_address = dest;
 
   // Write header:
   // Number of nodes.
-  dest = SimpleSerializer<u_int32_t>::Write(m.size(), dest);
+  dest = SimpleSerializer<uint32_t>::Write(m.size(), dest);
   // Nodes offsets.
-  u_int32_t *offsets = reinterpret_cast<u_int32_t*>(dest);
-  dest += sizeof(u_int32_t) * m.size();
+  uint32_t *offsets = reinterpret_cast<uint32_t*>(dest);
+  dest += sizeof(uint32_t) * m.size();
 
   char *key_address = dest;
   dest += sizeof(Key) * m.size();
 
   // Traverse map.
   typename std::map<Key, Value>::const_iterator iter;
   int index = 0;
   for (iter = m.begin(); iter != m.end(); ++iter, ++index) {
-    offsets[index] = static_cast<u_int32_t>(dest - start_address);
+    offsets[index] = static_cast<uint32_t>(dest - start_address);
     key_address = key_serializer_.Write(iter->first, key_address);
     dest = value_serializer_.Write(iter->second, dest);
   }
   return dest;
 }
 
 template<typename Key, typename Value>
 char *StdMapSerializer<Key, Value>::Serialize(
@@ -114,17 +114,17 @@
   if (size) *size = size_to_alloc;
   return serialized_data;
 }
 
 template<typename Address, typename Entry>
 size_t RangeMapSerializer<Address, Entry>::SizeOf(
     const RangeMap<Address, Entry> &m) const {
   size_t size = 0;
-  size_t header_size = (1 + m.map_.size()) * sizeof(u_int32_t);
+  size_t header_size = (1 + m.map_.size()) * sizeof(uint32_t);
   size += header_size;
 
   typename std::map<Address, Range>::const_iterator iter;
   for (iter = m.map_.begin(); iter != m.map_.end(); ++iter) {
     // Size of key (high address).
     size += address_serializer_.SizeOf(iter->first);
     // Size of base (low address).
     size += address_serializer_.SizeOf(iter->second.base());
@@ -140,29 +140,29 @@
   if (!dest) {
     BPLOG(ERROR) << "RangeMapSerializer failed: write to NULL address.";
     return NULL;
   }
   char *start_address = dest;
 
   // Write header:
   // Number of nodes.
-  dest = SimpleSerializer<u_int32_t>::Write(m.map_.size(), dest);
+  dest = SimpleSerializer<uint32_t>::Write(m.map_.size(), dest);
   // Nodes offsets.
-  u_int32_t *offsets = reinterpret_cast<u_int32_t*>(dest);
-  dest += sizeof(u_int32_t) * m.map_.size();
+  uint32_t *offsets = reinterpret_cast<uint32_t*>(dest);
+  dest += sizeof(uint32_t) * m.map_.size();
 
   char *key_address = dest;
   dest += sizeof(Address) * m.map_.size();
 
   // Traverse map.
   typename std::map<Address, Range>::const_iterator iter;
   int index = 0;
   for (iter = m.map_.begin(); iter != m.map_.end(); ++iter, ++index) {
-    offsets[index] = static_cast<u_int32_t>(dest - start_address);
+    offsets[index] = static_cast<uint32_t>(dest - start_address);
     key_address = address_serializer_.Write(iter->first, key_address);
     dest = address_serializer_.Write(iter->second.base(), dest);
     dest = entry_serializer_.Write(iter->second.entry(), dest);
   }
   return dest;
 }
 
 template<typename Address, typename Entry>
@@ -187,22 +187,22 @@
 
 
 template<class AddrType, class EntryType>
 size_t ContainedRangeMapSerializer<AddrType, EntryType>::SizeOf(
     const ContainedRangeMap<AddrType, EntryType> *m) const {
   size_t size = 0;
   size_t header_size = addr_serializer_.SizeOf(m->base_)
                        + entry_serializer_.SizeOf(m->entry_)
-                       + sizeof(u_int32_t);
+                       + sizeof(uint32_t);
   size += header_size;
   // In case m.map_ == NULL, we treat it as an empty map:
-  size += sizeof(u_int32_t);
+  size += sizeof(uint32_t);
   if (m->map_) {
-    size += m->map_->size() * sizeof(u_int32_t);
+    size += m->map_->size() * sizeof(uint32_t);
     typename Map::const_iterator iter;
     for (iter = m->map_->begin(); iter != m->map_->end(); ++iter) {
       size += addr_serializer_.SizeOf(iter->first);
       // Recursive calculation of size:
       size += SizeOf(iter->second);
     }
   }
   return size;
@@ -211,37 +211,37 @@
 template<class AddrType, class EntryType>
 char *ContainedRangeMapSerializer<AddrType, EntryType>::Write(
     const ContainedRangeMap<AddrType, EntryType> *m, char *dest) const {
   if (!dest) {
     BPLOG(ERROR) << "StdMapSerializer failed: write to NULL address.";
     return NULL;
   }
   dest = addr_serializer_.Write(m->base_, dest);
-  dest = SimpleSerializer<u_int32_t>::Write(entry_serializer_.SizeOf(m->entry_),
+  dest = SimpleSerializer<uint32_t>::Write(entry_serializer_.SizeOf(m->entry_),
                                             dest);
   dest = entry_serializer_.Write(m->entry_, dest);
 
   // Write map<<AddrType, ContainedRangeMap*>:
   char *map_address = dest;
   if (m->map_ == NULL) {
-    dest = SimpleSerializer<u_int32_t>::Write(0, dest);
+    dest = SimpleSerializer<uint32_t>::Write(0, dest);
   } else {
-    dest = SimpleSerializer<u_int32_t>::Write(m->map_->size(), dest);
-    u_int32_t *offsets = reinterpret_cast<u_int32_t*>(dest);
-    dest += sizeof(u_int32_t) * m->map_->size();
+    dest = SimpleSerializer<uint32_t>::Write(m->map_->size(), dest);
+    uint32_t *offsets = reinterpret_cast<uint32_t*>(dest);
+    dest += sizeof(uint32_t) * m->map_->size();
 
     char *key_address = dest;
     dest += sizeof(AddrType) * m->map_->size();
 
     // Traverse map.
     typename Map::const_iterator iter;
     int index = 0;
     for (iter = m->map_->begin(); iter != m->map_->end(); ++iter, ++index) {
-      offsets[index] = static_cast<u_int32_t>(dest - map_address);
+      offsets[index] = static_cast<uint32_t>(dest - map_address);
       key_address = addr_serializer_.Write(iter->first, key_address);
       // Recursively write.
       dest = Write(iter->second, dest);
     }
   }
   return dest;
 }
 
diff --git a/src/processor/map_serializers_unittest.cc b/src/processor/map_serializers_unittest.cc
--- a/src/processor/map_serializers_unittest.cc
+++ b/src/processor/map_serializers_unittest.cc
@@ -59,23 +59,23 @@
   }
 
   void TearDown() {
     delete [] serialized_data_;
   }
 
   std::map<AddrType, EntryType> std_map_;
   google_breakpad::StdMapSerializer<AddrType, EntryType> serializer_;
-  u_int32_t serialized_size_;
+  uint32_t serialized_size_;
   char *serialized_data_;
 };
 
 TEST_F(TestStdMapSerializer, EmptyMapTestCase) {
   const int32_t correct_data[] = { 0 };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   // std_map_ is empty.
   serialized_data_ = serializer_.Serialize(std_map_, &serialized_size_);
 
   EXPECT_EQ(correct_size, serialized_size_);
   EXPECT_EQ(memcmp(correct_data, serialized_data_, correct_size), 0);
 }
 
@@ -85,17 +85,17 @@
       2,
       // Offsets
       20, 24,
       // Keys
       1, 3,
       // Values
       2, 6
   };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   std_map_.insert(std::make_pair(1, 2));
   std_map_.insert(std::make_pair(3, 6));
 
   serialized_data_ = serializer_.Serialize(std_map_, &serialized_size_);
 
   EXPECT_EQ(correct_size, serialized_size_);
   EXPECT_EQ(memcmp(correct_data, serialized_data_, correct_size), 0);
@@ -107,17 +107,17 @@
       5,
       // Offsets
       44, 48, 52, 56, 60,
       // Keys
       1, 2, 3, 4, 5,
       // Values
       11, 12, 13, 14, 15
   };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   for (int i = 1; i < 6; ++i)
     std_map_.insert(std::make_pair(i, 10 + i));
 
   serialized_data_ = serializer_.Serialize(std_map_, &serialized_size_);
 
   EXPECT_EQ(correct_size, serialized_size_);
   EXPECT_EQ(memcmp(correct_data, serialized_data_, correct_size), 0);
@@ -131,23 +131,23 @@
   }
 
   void TearDown() {
     delete [] serialized_data_;
   }
 
   google_breakpad::AddressMap<AddrType, EntryType> address_map_;
   google_breakpad::AddressMapSerializer<AddrType, EntryType> serializer_;
-  u_int32_t serialized_size_;
+  uint32_t serialized_size_;
   char *serialized_data_;
 };
 
 TEST_F(TestAddressMapSerializer, EmptyMapTestCase) {
   const int32_t correct_data[] = { 0 };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   // std_map_ is empty.
   serialized_data_ = serializer_.Serialize(address_map_, &serialized_size_);
 
   EXPECT_EQ(correct_size, serialized_size_);
   EXPECT_EQ(memcmp(correct_data, serialized_data_, correct_size), 0);
 }
 
@@ -157,17 +157,17 @@
       2,
       // Offsets
       20, 24,
       // Keys
       1, 3,
       // Values
       2, 6
   };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   address_map_.Store(1, 2);
   address_map_.Store(3, 6);
 
   serialized_data_ = serializer_.Serialize(address_map_, &serialized_size_);
 
   EXPECT_EQ(correct_size, serialized_size_);
   EXPECT_EQ(memcmp(correct_data, serialized_data_, correct_size), 0);
@@ -179,17 +179,17 @@
       4,
       // Offsets
       36, 40, 44, 48,
       // Keys
       -6, -4, 8, 123,
       // Values
       2, 3, 5, 8
   };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   address_map_.Store(-6, 2);
   address_map_.Store(-4, 3);
   address_map_.Store(8, 5);
   address_map_.Store(123, 8);
 
   serialized_data_ = serializer_.Serialize(address_map_, &serialized_size_);
 
@@ -206,23 +206,23 @@
   }
 
   void TearDown() {
     delete [] serialized_data_;
   }
 
   google_breakpad::RangeMap<AddrType, EntryType> range_map_;
   google_breakpad::RangeMapSerializer<AddrType, EntryType> serializer_;
-  u_int32_t serialized_size_;
+  uint32_t serialized_size_;
   char *serialized_data_;
 };
 
 TEST_F(TestRangeMapSerializer, EmptyMapTestCase) {
   const int32_t correct_data[] = { 0 };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   // range_map_ is empty.
   serialized_data_ = serializer_.Serialize(range_map_, &serialized_size_);
 
   EXPECT_EQ(correct_size, serialized_size_);
   EXPECT_EQ(memcmp(correct_data, serialized_data_, correct_size), 0);
 }
 
@@ -232,17 +232,17 @@
       1,
       // Offsets
       12,
       // Keys: high address
       10,
       // Values: (low address, entry) pairs
       1, 6
   };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   range_map_.StoreRange(1, 10, 6);
 
   serialized_data_ = serializer_.Serialize(range_map_, &serialized_size_);
 
   EXPECT_EQ(correct_size, serialized_size_);
   EXPECT_EQ(memcmp(correct_data, serialized_data_, correct_size), 0);
 }
@@ -253,17 +253,17 @@
       3,
       // Offsets
       28,    36,    44,
       // Keys: high address
       5,     9,     20,
       // Values: (low address, entry) pairs
       2, 1,  6, 2,  10, 3
   };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   ASSERT_TRUE(range_map_.StoreRange(2, 4, 1));
   ASSERT_TRUE(range_map_.StoreRange(6, 4, 2));
   ASSERT_TRUE(range_map_.StoreRange(10, 11, 3));
 
   serialized_data_ = serializer_.Serialize(range_map_, &serialized_size_);
 
   EXPECT_EQ(correct_size, serialized_size_);
@@ -279,28 +279,28 @@
   }
 
   void TearDown() {
     delete [] serialized_data_;
   }
 
   google_breakpad::ContainedRangeMap<AddrType, EntryType> crm_map_;
   google_breakpad::ContainedRangeMapSerializer<AddrType, EntryType> serializer_;
-  u_int32_t serialized_size_;
+  uint32_t serialized_size_;
   char *serialized_data_;
 };
 
 TEST_F(TestContainedRangeMapSerializer, EmptyMapTestCase) {
   const int32_t correct_data[] = {
       0,  // base address of root
       4,  // size of entry
       0,  // entry stored at root
       0   // empty map stored at root
   };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   // crm_map_ is empty.
   serialized_data_ = serializer_.Serialize(&crm_map_, &serialized_size_);
 
   EXPECT_EQ(correct_size, serialized_size_);
   EXPECT_EQ(memcmp(correct_data, serialized_data_, correct_size), 0);
 }
 
@@ -314,17 +314,17 @@
       12, // offset
       9,  // key
       // value: a child ContainedRangeMap
       3,  // base address of child CRM
       4,  // size of entry
       -1, // entry stored in child CRM
       0   // empty sub-map stored in child CRM
   };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   crm_map_.StoreRange(3, 7, -1);
 
   serialized_data_ = serializer_.Serialize(&crm_map_, &serialized_size_);
 
   EXPECT_EQ(correct_size, serialized_size_);
   EXPECT_EQ(memcmp(correct_data, serialized_data_, correct_size), 0);
 }
@@ -356,17 +356,17 @@
         6, 4, -1, 0,
       // child2: base, entry_size, entry:
       10, 4, -1,
       // child2's map: # of nodes, offset1, key1
       1, 12, 20,
         // grandchild3: base, entry_size, entry, empty_map
         16, 4, -1, 0
   };
-  u_int32_t correct_size = sizeof(correct_data);
+  uint32_t correct_size = sizeof(correct_data);
 
   // Store child1.
   ASSERT_TRUE(crm_map_.StoreRange(2, 7, -1));
   // Store child2.
   ASSERT_TRUE(crm_map_.StoreRange(10, 11, -1));
   // Store grandchild1.
   ASSERT_TRUE(crm_map_.StoreRange(3, 2, -1));
   // Store grandchild2.
diff --git a/src/processor/minidump.cc b/src/processor/minidump.cc
old mode 100644
new mode 100755
--- a/src/processor/minidump.cc
+++ b/src/processor/minidump.cc
@@ -38,17 +38,19 @@
 #include <assert.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <string.h>
 #include <time.h>
 
 #ifdef _WIN32
 #include <io.h>
+#if _MSC_VER < 1600
 typedef SSIZE_T ssize_t;
+#endif
 #define PRIx64 "llx"
 #define PRIx32 "lx"
 #define snprintf _snprintf
 #else  // _WIN32
 #include <unistd.h>
 #define O_BINARY 0
 #endif  // _WIN32
 
@@ -81,68 +83,68 @@
 //
 // Inlining these doesn't increase code size significantly, and it saves
 // a whole lot of unnecessary jumping back and forth.
 //
 
 
 // Swapping an 8-bit quantity is a no-op.  This function is only provided
 // to account for certain templatized operations that require swapping for
-// wider types but handle u_int8_t too
+// wider types but handle uint8_t too
 // (MinidumpMemoryRegion::GetMemoryAtAddressInternal).
-static inline void Swap(u_int8_t* value) {
+static inline void Swap(uint8_t* value) {
 }
 
 
 // Optimization: don't need to AND the furthest right shift, because we're
 // shifting an unsigned quantity.  The standard requires zero-filling in this
 // case.  If the quantities were signed, a bitmask whould be needed for this
 // right shift to avoid an arithmetic shift (which retains the sign bit).
 // The furthest left shift never needs to be ANDed bitmask.
 
 
-static inline void Swap(u_int16_t* value) {
+static inline void Swap(uint16_t* value) {
   *value = (*value >> 8) |
            (*value << 8);
 }
 
 
-static inline void Swap(u_int32_t* value) {
+static inline void Swap(uint32_t* value) {
   *value =  (*value >> 24) |
            ((*value >> 8)  & 0x0000ff00) |
            ((*value << 8)  & 0x00ff0000) |
             (*value << 24);
 }
 
 
-static inline void Swap(u_int64_t* value) {
-  u_int32_t* value32 = reinterpret_cast<u_int32_t*>(value);
+static inline void Swap(uint64_t* value) {
+  uint32_t* value32 = reinterpret_cast<uint32_t*>(value);
   Swap(&value32[0]);
   Swap(&value32[1]);
-  u_int32_t temp = value32[0];
+  uint32_t temp = value32[0];
   value32[0] = value32[1];
   value32[1] = temp;
 }
 
 
 // Given a pointer to a 128-bit int in the minidump data, set the "low"
 // and "high" fields appropriately.
-static void Normalize128(u_int128_t* value, bool is_big_endian) {
+static void Normalize128(uint128_t* value, bool is_big_endian) {
   // The struct format is [high, low], so if the format is big-endian,
   // the most significant bytes will already be in the high field.
   if (!is_big_endian) {
-    u_int64_t temp = value->low;
+    uint64_t temp = value->low;
     value->low = value->high;
     value->high = temp;
   }
 }
 
 // This just swaps each int64 half of the 128-bit value.
 // The value should also be normalized by calling Normalize128().
-static void Swap(u_int128_t* value) {
+static void Swap(uint128_t* value) {
   Swap(&value->low);
   Swap(&value->high);
 }
 
 
 static inline void Swap(MDLocationDescriptor* location_descriptor) {
   Swap(&location_descriptor->data_size);
   Swap(&location_descriptor->rva);
@@ -172,48 +174,48 @@
 // idea of what width a wide character should be: some use 16 bits, and
 // some use 32 bits.  For the purposes of a minidump, wide strings are
 // always represented with 16-bit UTF-16 chracters.  iconv isn't available
 // everywhere, and its interface varies where it is available.  iconv also
 // deals purely with char* pointers, so in addition to considering the swap
 // parameter, a converter that uses iconv would also need to take the host
 // CPU's endianness into consideration.  It doesn't seems worth the trouble
 // of making it a dependency when we don't care about anything but UTF-16.
-static string* UTF16ToUTF8(const vector<u_int16_t>& in,
+static string* UTF16ToUTF8(const vector<uint16_t>& in,
                            bool                     swap) {
   scoped_ptr<string> out(new string());
 
   // Set the string's initial capacity to the number of UTF-16 characters,
   // because the UTF-8 representation will always be at least this long.
   // If the UTF-8 representation is longer, the string will grow dynamically.
   out->reserve(in.size());
 
-  for (vector<u_int16_t>::const_iterator iterator = in.begin();
+  for (vector<uint16_t>::const_iterator iterator = in.begin();
        iterator != in.end();
        ++iterator) {
     // Get a 16-bit value from the input
-    u_int16_t in_word = *iterator;
+    uint16_t in_word = *iterator;
     if (swap)
       Swap(&in_word);
 
     // Convert the input value (in_word) into a Unicode code point (unichar).
-    u_int32_t unichar;
+    uint32_t unichar;
     if (in_word >= 0xdc00 && in_word <= 0xdcff) {
       BPLOG(ERROR) << "UTF16ToUTF8 found low surrogate " <<
                       HexString(in_word) << " without high";
       return NULL;
     } else if (in_word >= 0xd800 && in_word <= 0xdbff) {
       // High surrogate.
       unichar = (in_word - 0xd7c0) << 10;
       if (++iterator == in.end()) {
         BPLOG(ERROR) << "UTF16ToUTF8 found high surrogate " <<
                         HexString(in_word) << " at end of string";
         return NULL;
       }
-      u_int32_t high_word = in_word;
+      uint32_t high_word = in_word;
       in_word = *iterator;
       if (in_word < 0xdc00 || in_word > 0xdcff) {
         BPLOG(ERROR) << "UTF16ToUTF8 found high surrogate " <<
                         HexString(high_word) << " without low " <<
                         HexString(in_word);
         return NULL;
       }
       unichar |= in_word & 0x03ff;
@@ -246,17 +248,17 @@
     }
   }
 
   return out.release();
 }
 
 // Return the smaller of the number of code units in the UTF-16 string,
 // not including the terminating null word, or maxlen.
-static size_t UTF16codeunits(const u_int16_t *string, size_t maxlen) {
+static size_t UTF16codeunits(const uint16_t *string, size_t maxlen) {
   size_t count = 0;
   while (count < maxlen && string[count] != 0)
     count++;
   return count;
 }
 
 
 //
@@ -292,17 +294,17 @@
 }
 
 
 MinidumpContext::~MinidumpContext() {
   FreeContext();
 }
 
 
-bool MinidumpContext::Read(u_int32_t expected_size) {
+bool MinidumpContext::Read(uint32_t expected_size) {
   valid_ = false;
 
   FreeContext();
 
   // First, figure out what type of CPU this context structure is for.
   // For some reason, the AMD64 Context doesn't have context_flags
   // at the beginning of the structure, so special case it here.
   if (expected_size == sizeof(MDRawContextAMD64)) {
@@ -313,17 +315,17 @@
                               sizeof(MDRawContextAMD64))) {
       BPLOG(ERROR) << "MinidumpContext could not read amd64 context";
       return false;
     }
 
     if (minidump_->swap())
       Swap(&context_amd64->context_flags);
 
-    u_int32_t cpu_type = context_amd64->context_flags & MD_CONTEXT_CPU_MASK;
+    uint32_t cpu_type = context_amd64->context_flags & MD_CONTEXT_CPU_MASK;
     if (cpu_type == 0) {
       if (minidump_->GetContextCPUFlagsFromSystemInfo(&cpu_type)) {
         context_amd64->context_flags |= cpu_type;
       } else {
         BPLOG(ERROR) << "Failed to preserve the current stream position";
         return false;
       }
     }
@@ -405,25 +407,25 @@
       Swap(&context_amd64->last_exception_from_rip);
     }
 
     context_flags_ = context_amd64->context_flags;
 
     context_.amd64 = context_amd64.release();
   }
   else {
-    u_int32_t context_flags;
+    uint32_t context_flags;
     if (!minidump_->ReadBytes(&context_flags, sizeof(context_flags))) {
       BPLOG(ERROR) << "MinidumpContext could not read context flags";
       return false;
     }
     if (minidump_->swap())
       Swap(&context_flags);
 
-    u_int32_t cpu_type = context_flags & MD_CONTEXT_CPU_MASK;
+    uint32_t cpu_type = context_flags & MD_CONTEXT_CPU_MASK;
     if (cpu_type == 0) {
       // Unfortunately the flag for MD_CONTEXT_ARM that was taken
       // from a Windows CE SDK header conflicts in practice with
       // the CONTEXT_XSTATE flag. MD_CONTEXT_ARM has been renumbered,
       // but handle dumps with the legacy value gracefully here.
       if (context_flags & MD_CONTEXT_ARM_OLD) {
         context_flags |= MD_CONTEXT_ARM;
         context_flags &= ~MD_CONTEXT_ARM_OLD;
@@ -455,18 +457,18 @@
         scoped_ptr<MDRawContextX86> context_x86(new MDRawContextX86());
 
         // Set the context_flags member, which has already been read, and
         // read the rest of the structure beginning with the first member
         // after context_flags.
         context_x86->context_flags = context_flags;
 
         size_t flags_size = sizeof(context_x86->context_flags);
-        u_int8_t* context_after_flags =
-          reinterpret_cast<u_int8_t*>(context_x86.get()) + flags_size;
+        uint8_t* context_after_flags =
+          reinterpret_cast<uint8_t*>(context_x86.get()) + flags_size;
         if (!minidump_->ReadBytes(context_after_flags,
                                   sizeof(MDRawContextX86) - flags_size)) {
           BPLOG(ERROR) << "MinidumpContext could not read x86 context";
           return false;
         }
 
         // Do this after reading the entire MDRawContext structure because
         // GetSystemInfo may seek minidump to a new position.
@@ -528,18 +530,18 @@
         scoped_ptr<MDRawContextPPC> context_ppc(new MDRawContextPPC());
 
         // Set the context_flags member, which has already been read, and
         // read the rest of the structure beginning with the first member
         // after context_flags.
         context_ppc->context_flags = context_flags;
 
         size_t flags_size = sizeof(context_ppc->context_flags);
-        u_int8_t* context_after_flags =
-          reinterpret_cast<u_int8_t*>(context_ppc.get()) + flags_size;
+        uint8_t* context_after_flags =
+          reinterpret_cast<uint8_t*>(context_ppc.get()) + flags_size;
         if (!minidump_->ReadBytes(context_after_flags,
                                   sizeof(MDRawContextPPC) - flags_size)) {
           BPLOG(ERROR) << "MinidumpContext could not read ppc context";
           return false;
         }
 
         // Do this after reading the entire MDRawContext structure because
         // GetSystemInfo may seek minidump to a new position.
@@ -604,18 +606,18 @@
         scoped_ptr<MDRawContextSPARC> context_sparc(new MDRawContextSPARC());
 
         // Set the context_flags member, which has already been read, and
         // read the rest of the structure beginning with the first member
         // after context_flags.
         context_sparc->context_flags = context_flags;
 
         size_t flags_size = sizeof(context_sparc->context_flags);
-        u_int8_t* context_after_flags =
-            reinterpret_cast<u_int8_t*>(context_sparc.get()) + flags_size;
+        uint8_t* context_after_flags =
+            reinterpret_cast<uint8_t*>(context_sparc.get()) + flags_size;
         if (!minidump_->ReadBytes(context_after_flags,
                                   sizeof(MDRawContextSPARC) - flags_size)) {
           BPLOG(ERROR) << "MinidumpContext could not read sparc context";
           return false;
         }
 
         // Do this after reading the entire MDRawContext structure because
         // GetSystemInfo may seek minidump to a new position.
@@ -660,18 +662,18 @@
         scoped_ptr<MDRawContextARM> context_arm(new MDRawContextARM());
 
         // Set the context_flags member, which has already been read, and
         // read the rest of the structure beginning with the first member
         // after context_flags.
         context_arm->context_flags = context_flags;
 
         size_t flags_size = sizeof(context_arm->context_flags);
-        u_int8_t* context_after_flags =
-            reinterpret_cast<u_int8_t*>(context_arm.get()) + flags_size;
+        uint8_t* context_after_flags =
+            reinterpret_cast<uint8_t*>(context_arm.get()) + flags_size;
         if (!minidump_->ReadBytes(context_after_flags,
                                   sizeof(MDRawContextARM) - flags_size)) {
           BPLOG(ERROR) << "MinidumpContext could not read arm context";
           return false;
         }
 
         // Do this after reading the entire MDRawContext structure because
         // GetSystemInfo may seek minidump to a new position.
@@ -717,27 +719,27 @@
     context_flags_ = context_flags;
   }
 
   valid_ = true;
   return true;
 }
 
 
-u_int32_t MinidumpContext::GetContextCPU() const {
+uint32_t MinidumpContext::GetContextCPU() const {
   if (!valid_) {
     // Don't log a message, GetContextCPU can be legitimately called with
     // valid_ false by FreeContext, which is called by Read.
     return 0;
   }
 
   return context_flags_ & MD_CONTEXT_CPU_MASK;
 }
 
-bool MinidumpContext::GetInstructionPointer(u_int64_t* ip) const {
+bool MinidumpContext::GetInstructionPointer(uint64_t* ip) const {
   BPLOG_IF(ERROR, !ip) << "MinidumpContext::GetInstructionPointer "
                           "requires |ip|";
   assert(ip);
   *ip = 0;
 
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpContext for GetInstructionPointer";
     return false;
@@ -843,17 +845,17 @@
       break;
   }
 
   context_flags_ = 0;
   context_.base = NULL;
 }
 
 
-bool MinidumpContext::CheckAgainstSystemInfo(u_int32_t context_cpu_type) {
+bool MinidumpContext::CheckAgainstSystemInfo(uint32_t context_cpu_type) {
   // It's OK if the minidump doesn't contain an MD_SYSTEM_INFO_STREAM,
   // as this function just implements a sanity check.
   MinidumpSystemInfo* system_info = minidump_->GetSystemInfo();
   if (!system_info) {
     BPLOG(INFO) << "MinidumpContext could not be compared against "
                    "MinidumpSystemInfo";
     return true;
   }
@@ -1142,17 +1144,17 @@
 }
 
 
 //
 // MinidumpMemoryRegion
 //
 
 
-u_int32_t MinidumpMemoryRegion::max_bytes_ = 1024 * 1024;  // 1MB
+uint32_t MinidumpMemoryRegion::max_bytes_ = 1024 * 1024;  // 1MB
 
 
 MinidumpMemoryRegion::MinidumpMemoryRegion(Minidump* minidump)
     : MinidumpObject(minidump),
       descriptor_(NULL),
       memory_(NULL) {
 }
 
@@ -1161,22 +1163,22 @@
   delete memory_;
 }
 
 
 void MinidumpMemoryRegion::SetDescriptor(MDMemoryDescriptor* descriptor) {
   descriptor_ = descriptor;
   valid_ = descriptor &&
            descriptor_->memory.data_size <=
-               numeric_limits<u_int64_t>::max() -
+               numeric_limits<uint64_t>::max() -
                descriptor_->start_of_memory_range;
 }
 
 
-const u_int8_t* MinidumpMemoryRegion::GetMemory() const {
+const uint8_t* MinidumpMemoryRegion::GetMemory() const {
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpMemoryRegion for GetMemory";
     return NULL;
   }
 
   if (!memory_) {
     if (descriptor_->memory.data_size == 0) {
       BPLOG(ERROR) << "MinidumpMemoryRegion is empty";
@@ -1190,84 +1192,84 @@
 
     if (descriptor_->memory.data_size > max_bytes_) {
       BPLOG(ERROR) << "MinidumpMemoryRegion size " <<
                       descriptor_->memory.data_size << " exceeds maximum " <<
                       max_bytes_;
       return NULL;
     }
 
-    scoped_ptr< vector<u_int8_t> > memory(
-        new vector<u_int8_t>(descriptor_->memory.data_size));
+    scoped_ptr< vector<uint8_t> > memory(
+        new vector<uint8_t>(descriptor_->memory.data_size));
 
     if (!minidump_->ReadBytes(&(*memory)[0], descriptor_->memory.data_size)) {
       BPLOG(ERROR) << "MinidumpMemoryRegion could not read memory region";
       return NULL;
     }
 
     memory_ = memory.release();
   }
 
   return &(*memory_)[0];
 }
 
 
-u_int64_t MinidumpMemoryRegion::GetBase() const {
+uint64_t MinidumpMemoryRegion::GetBase() const {
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpMemoryRegion for GetBase";
-    return static_cast<u_int64_t>(-1);
+    return static_cast<uint64_t>(-1);
   }
 
   return descriptor_->start_of_memory_range;
 }
 
 
-u_int32_t MinidumpMemoryRegion::GetSize() const {
+uint32_t MinidumpMemoryRegion::GetSize() const {
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpMemoryRegion for GetSize";
     return 0;
   }
 
   return descriptor_->memory.data_size;
 }
 
 
 void MinidumpMemoryRegion::FreeMemory() {
   delete memory_;
   memory_ = NULL;
 }
 
 
 template<typename T>
-bool MinidumpMemoryRegion::GetMemoryAtAddressInternal(u_int64_t address,
+bool MinidumpMemoryRegion::GetMemoryAtAddressInternal(uint64_t address,
                                                       T*        value) const {
   BPLOG_IF(ERROR, !value) << "MinidumpMemoryRegion::GetMemoryAtAddressInternal "
                              "requires |value|";
   assert(value);
   *value = 0;
 
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpMemoryRegion for "
                     "GetMemoryAtAddressInternal";
     return false;
   }
 
   // Common failure case
   if (address < descriptor_->start_of_memory_range ||
-      sizeof(T) > numeric_limits<u_int64_t>::max() - address ||
+      sizeof(T) > numeric_limits<uint64_t>::max() - address ||
       address + sizeof(T) > descriptor_->start_of_memory_range +
                             descriptor_->memory.data_size) {
     BPLOG(INFO) << "MinidumpMemoryRegion request out of range: " <<
                     HexString(address) << "+" << sizeof(T) << "/" <<
                     HexString(descriptor_->start_of_memory_range) << "+" <<
                     HexString(descriptor_->memory.data_size);
     return false;
   }
 
-  const u_int8_t* memory = GetMemory();
+  const uint8_t* memory = GetMemory();
   if (!memory) {
     // GetMemory already logged a perfectly good message.
     return false;
   }
 
   // If the CPU requires memory accesses to be aligned, this can crash.
   // x86 and ppc are able to cope, though.
   *value = *reinterpret_cast<const T*>(
@@ -1275,47 +1277,47 @@
 
   if (minidump_->swap())
     Swap(value);
 
   return true;
 }
 
 
-bool MinidumpMemoryRegion::GetMemoryAtAddress(u_int64_t  address,
-                                              u_int8_t*  value) const {
+bool MinidumpMemoryRegion::GetMemoryAtAddress(uint64_t  address,
+                                              uint8_t*  value) const {
   return GetMemoryAtAddressInternal(address, value);
 }
 
 
-bool MinidumpMemoryRegion::GetMemoryAtAddress(u_int64_t  address,
-                                              u_int16_t* value) const {
+bool MinidumpMemoryRegion::GetMemoryAtAddress(uint64_t  address,
+                                              uint16_t* value) const {
   return GetMemoryAtAddressInternal(address, value);
 }
 
 
-bool MinidumpMemoryRegion::GetMemoryAtAddress(u_int64_t  address,
-                                              u_int32_t* value) const {
+bool MinidumpMemoryRegion::GetMemoryAtAddress(uint64_t  address,
+                                              uint32_t* value) const {
   return GetMemoryAtAddressInternal(address, value);
 }
 
 
-bool MinidumpMemoryRegion::GetMemoryAtAddress(u_int64_t  address,
-                                              u_int64_t* value) const {
+bool MinidumpMemoryRegion::GetMemoryAtAddress(uint64_t  address,
+                                              uint64_t* value) const {
   return GetMemoryAtAddressInternal(address, value);
 }
 
 
 void MinidumpMemoryRegion::Print() {
   if (!valid_) {
     BPLOG(ERROR) << "MinidumpMemoryRegion cannot print invalid data";
     return;
   }
 
-  const u_int8_t* memory = GetMemory();
+  const uint8_t* memory = GetMemory();
   if (memory) {
     printf("0x");
     for (unsigned int byte_index = 0;
          byte_index < descriptor_->memory.data_size;
          byte_index++) {
       printf("%02x", memory[byte_index]);
     }
     printf("\n");
@@ -1365,17 +1367,17 @@
     Swap(&thread_.priority);
     Swap(&thread_.teb);
     Swap(&thread_.stack);
     Swap(&thread_.thread_context);
   }
 
   // Check for base + size overflow or undersize.
   if (thread_.stack.memory.data_size == 0 ||
-      thread_.stack.memory.data_size > numeric_limits<u_int64_t>::max() -
+      thread_.stack.memory.data_size > numeric_limits<uint64_t>::max() -
                                        thread_.stack.start_of_memory_range) {
     // This is ok, but log an error anyway.
     BPLOG(ERROR) << "MinidumpThread has a memory region problem, " <<
                     HexString(thread_.stack.start_of_memory_range) << "+" <<
                     HexString(thread_.stack.memory.data_size);
   } else {
     memory_ = new MinidumpMemoryRegion(minidump_);
     memory_->SetDescriptor(&thread_.stack);
@@ -1417,17 +1419,17 @@
 
     context_ = context.release();
   }
 
   return context_;
 }
 
 
-bool MinidumpThread::GetThreadID(u_int32_t *thread_id) const {
+bool MinidumpThread::GetThreadID(uint32_t *thread_id) const {
   BPLOG_IF(ERROR, !thread_id) << "MinidumpThread::GetThreadID requires "
                                  "|thread_id|";
   assert(thread_id);
   *thread_id = 0;
 
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpThread for GetThreadID";
     return false;
@@ -1480,67 +1482,67 @@
 }
 
 
 //
 // MinidumpThreadList
 //
 
 
-u_int32_t MinidumpThreadList::max_threads_ = 4096;
+uint32_t MinidumpThreadList::max_threads_ = 4096;
 
 
 MinidumpThreadList::MinidumpThreadList(Minidump* minidump)
     : MinidumpStream(minidump),
       id_to_thread_map_(),
       threads_(NULL),
       thread_count_(0) {
 }
 
 
 MinidumpThreadList::~MinidumpThreadList() {
   delete threads_;
 }
 
 
-bool MinidumpThreadList::Read(u_int32_t expected_size) {
+bool MinidumpThreadList::Read(uint32_t expected_size) {
   // Invalidate cached data.
   id_to_thread_map_.clear();
   delete threads_;
   threads_ = NULL;
   thread_count_ = 0;
 
   valid_ = false;
 
-  u_int32_t thread_count;
+  uint32_t thread_count;
   if (expected_size < sizeof(thread_count)) {
     BPLOG(ERROR) << "MinidumpThreadList count size mismatch, " <<
                     expected_size << " < " << sizeof(thread_count);
     return false;
   }
   if (!minidump_->ReadBytes(&thread_count, sizeof(thread_count))) {
     BPLOG(ERROR) << "MinidumpThreadList cannot read thread count";
     return false;
   }
 
   if (minidump_->swap())
     Swap(&thread_count);
 
-  if (thread_count > numeric_limits<u_int32_t>::max() / sizeof(MDRawThread)) {
+  if (thread_count > numeric_limits<uint32_t>::max() / sizeof(MDRawThread)) {
     BPLOG(ERROR) << "MinidumpThreadList thread count " << thread_count <<
                     " would cause multiplication overflow";
     return false;
   }
 
   if (expected_size != sizeof(thread_count) +
                        thread_count * sizeof(MDRawThread)) {
     // may be padded with 4 bytes on 64bit ABIs for alignment
     if (expected_size == sizeof(thread_count) + 4 +
                          thread_count * sizeof(MDRawThread)) {
-      u_int32_t useless;
+      uint32_t useless;
       if (!minidump_->ReadBytes(&useless, 4)) {
         BPLOG(ERROR) << "MinidumpThreadList cannot read threadlist padded bytes";
         return false;
       }
     } else {
       BPLOG(ERROR) << "MinidumpThreadList size mismatch, " << expected_size <<
                     " != " << sizeof(thread_count) +
                     thread_count * sizeof(MDRawThread);
@@ -1566,17 +1568,17 @@
 
       // Assume that the file offset is correct after the last read.
       if (!thread->Read()) {
         BPLOG(ERROR) << "MinidumpThreadList cannot read thread " <<
                         thread_index << "/" << thread_count;
         return false;
       }
 
-      u_int32_t thread_id;
+      uint32_t thread_id;
       if (!thread->GetThreadID(&thread_id)) {
         BPLOG(ERROR) << "MinidumpThreadList cannot get thread ID for thread " <<
                         thread_index << "/" << thread_count;
         return false;
       }
 
       if (GetThreadByID(thread_id)) {
         // Another thread with this ID is already in the list.  Data error.
@@ -1610,17 +1612,17 @@
                     index << "/" << thread_count_;
     return NULL;
   }
 
   return &(*threads_)[index];
 }
 
 
-MinidumpThread* MinidumpThreadList::GetThreadByID(u_int32_t thread_id) {
+MinidumpThread* MinidumpThreadList::GetThreadByID(uint32_t thread_id) {
   // Don't check valid_.  Read calls this method before everything is
   // validated.  It is safe to not check valid_ here.
   return id_to_thread_map_[thread_id];
 }
 
 
 void MinidumpThreadList::Print() {
   if (!valid_) {
@@ -1642,18 +1644,18 @@
 }
 
 
 //
 // MinidumpModule
 //
 
 
-u_int32_t MinidumpModule::max_cv_bytes_ = 32768;
-u_int32_t MinidumpModule::max_misc_bytes_ = 32768;
+uint32_t MinidumpModule::max_cv_bytes_ = 32768;
+uint32_t MinidumpModule::max_misc_bytes_ = 32768;
 
 
 MinidumpModule::MinidumpModule(Minidump* minidump)
     : MinidumpObject(minidump),
       module_valid_(false),
       has_debug_info_(false),
       module_(),
       name_(NULL),
@@ -1712,17 +1714,17 @@
     Swap(&module_.misc_record);
     // Don't swap reserved fields because their contents are unknown (as
     // are their proper widths).
   }
 
   // Check for base + size overflow or undersize.
   if (module_.size_of_image == 0 ||
       module_.size_of_image >
-          numeric_limits<u_int64_t>::max() - module_.base_of_image) {
+          numeric_limits<uint64_t>::max() - module_.base_of_image) {
     BPLOG(ERROR) << "MinidumpModule has a module problem, " <<
                     HexString(module_.base_of_image) << "+" <<
                     HexString(module_.size_of_image);
     return false;
   }
 
   module_valid_ = true;
   return true;
@@ -1887,19 +1889,19 @@
         // that this method (and all other methods in the Minidump family)
         // return.
 
         unsigned int bytes =
             module_.misc_record.data_size - MDImageDebugMisc_minsize;
         if (bytes % 2 == 0) {
           unsigned int utf16_words = bytes / 2;
 
-          // UTF16ToUTF8 expects a vector<u_int16_t>, so create a temporary one
+          // UTF16ToUTF8 expects a vector<uint16_t>, so create a temporary one
           // and copy the UTF-16 data into it.
-          vector<u_int16_t> string_utf16(utf16_words);
+          vector<uint16_t> string_utf16(utf16_words);
           if (utf16_words)
             memcpy(&string_utf16[0], &misc_record->data, bytes);
 
           // GetMiscRecord already byte-swapped the data[] field if it contains
           // UTF-16, so pass false as the swap argument.
           scoped_ptr<string> new_file(UTF16ToUTF8(string_utf16, false));
           file = *new_file;
         }
@@ -2016,17 +2018,17 @@
 }
 
 
 const CodeModule* MinidumpModule::Copy() const {
   return new BasicCodeModule(this);
 }
 
 
-const u_int8_t* MinidumpModule::GetCVRecord(u_int32_t* size) {
+const uint8_t* MinidumpModule::GetCVRecord(uint32_t* size) {
   if (!module_valid_) {
     BPLOG(ERROR) << "Invalid MinidumpModule for GetCVRecord";
     return NULL;
   }
 
   if (!cv_record_) {
     // This just guards against 0-sized CodeView records; more specific checks
     // are used when the signature is checked against various structure types.
@@ -2042,31 +2044,31 @@
     if (module_.cv_record.data_size > max_cv_bytes_) {
       BPLOG(ERROR) << "MinidumpModule CodeView record size " <<
                       module_.cv_record.data_size << " exceeds maximum " <<
                       max_cv_bytes_;
       return NULL;
     }
 
     // Allocating something that will be accessed as MDCVInfoPDB70 or
-    // MDCVInfoPDB20 but is allocated as u_int8_t[] can cause alignment
+    // MDCVInfoPDB20 but is allocated as uint8_t[] can cause alignment
     // problems.  x86 and ppc are able to cope, though.  This allocation
     // style is needed because the MDCVInfoPDB70 or MDCVInfoPDB20 are
     // variable-sized due to their pdb_file_name fields; these structures
     // are not MDCVInfoPDB70_minsize or MDCVInfoPDB20_minsize and treating
     // them as such would result in incomplete structures or overruns.
-    scoped_ptr< vector<u_int8_t> > cv_record(
-        new vector<u_int8_t>(module_.cv_record.data_size));
+    scoped_ptr< vector<uint8_t> > cv_record(
+        new vector<uint8_t>(module_.cv_record.data_size));
 
     if (!minidump_->ReadBytes(&(*cv_record)[0], module_.cv_record.data_size)) {
       BPLOG(ERROR) << "MinidumpModule could not read CodeView record";
       return NULL;
     }
 
-    u_int32_t signature = MD_CVINFOUNKNOWN_SIGNATURE;
+    uint32_t signature = MD_CVINFOUNKNOWN_SIGNATURE;
     if (module_.cv_record.data_size > sizeof(signature)) {
       MDCVInfoPDB70* cv_record_signature =
           reinterpret_cast<MDCVInfoPDB70*>(&(*cv_record)[0]);
       signature = cv_record_signature->cv_signature;
       if (minidump_->swap())
         Swap(&signature);
     }
 
@@ -2126,29 +2128,29 @@
 
     // If the signature doesn't match something above, it's not something
     // that Breakpad can presently handle directly.  Because some modules in
     // the wild contain such CodeView records as MD_CVINFOCV50_SIGNATURE,
     // don't bail out here - allow the data to be returned to the user,
     // although byte-swapping can't be done.
 
     // Store the vector type because that's how storage was allocated, but
-    // return it casted to u_int8_t*.
+    // return it casted to uint8_t*.
     cv_record_ = cv_record.release();
     cv_record_signature_ = signature;
   }
 
   if (size)
     *size = module_.cv_record.data_size;
 
   return &(*cv_record_)[0];
 }
 
 
-const MDImageDebugMisc* MinidumpModule::GetMiscRecord(u_int32_t* size) {
+const MDImageDebugMisc* MinidumpModule::GetMiscRecord(uint32_t* size) {
   if (!module_valid_) {
     BPLOG(ERROR) << "Invalid MinidumpModule for GetMiscRecord";
     return NULL;
   }
 
   if (!misc_record_) {
     if (module_.misc_record.data_size == 0) {
       return NULL;
@@ -2170,23 +2172,23 @@
     if (module_.misc_record.data_size > max_misc_bytes_) {
       BPLOG(ERROR) << "MinidumpModule miscellaneous debugging record size " <<
                       module_.misc_record.data_size << " exceeds maximum " <<
                       max_misc_bytes_;
       return NULL;
     }
 
     // Allocating something that will be accessed as MDImageDebugMisc but
-    // is allocated as u_int8_t[] can cause alignment problems.  x86 and
+    // is allocated as uint8_t[] can cause alignment problems.  x86 and
     // ppc are able to cope, though.  This allocation style is needed
     // because the MDImageDebugMisc is variable-sized due to its data field;
     // this structure is not MDImageDebugMisc_minsize and treating it as such
     // would result in an incomplete structure or an overrun.
-    scoped_ptr< vector<u_int8_t> > misc_record_mem(
-        new vector<u_int8_t>(module_.misc_record.data_size));
+    scoped_ptr< vector<uint8_t> > misc_record_mem(
+        new vector<uint8_t>(module_.misc_record.data_size));
     MDImageDebugMisc* misc_record =
         reinterpret_cast<MDImageDebugMisc*>(&(*misc_record_mem)[0]);
 
     if (!minidump_->ReadBytes(misc_record, module_.misc_record.data_size)) {
       BPLOG(ERROR) << "MinidumpModule could not read miscellaneous debugging "
                       "record";
       return NULL;
     }
@@ -2195,17 +2197,17 @@
       Swap(&misc_record->data_type);
       Swap(&misc_record->length);
       // Don't swap misc_record.unicode because it's an 8-bit quantity.
       // Don't swap the reserved fields for the same reason, and because
       // they don't contain any valid data.
       if (misc_record->unicode) {
         // There is a potential alignment problem, but shouldn't be a problem
         // in practice due to the layout of MDImageDebugMisc.
-        u_int16_t* data16 = reinterpret_cast<u_int16_t*>(&(misc_record->data));
+        uint16_t* data16 = reinterpret_cast<uint16_t*>(&(misc_record->data));
         unsigned int dataBytes = module_.misc_record.data_size -
                                  MDImageDebugMisc_minsize;
         unsigned int dataLength = dataBytes / 2;
         for (unsigned int characterIndex = 0;
              characterIndex < dataLength;
              ++characterIndex) {
           Swap(&data16[characterIndex]);
         }
@@ -2279,18 +2281,18 @@
          module_.misc_record.data_size);
   printf("  misc_record.rva                 = 0x%x\n",
          module_.misc_record.rva);
 
   printf("  (code_file)                     = \"%s\"\n", code_file().c_str());
   printf("  (code_identifier)               = \"%s\"\n",
          code_identifier().c_str());
 
-  u_int32_t cv_record_size;
-  const u_int8_t *cv_record = GetCVRecord(&cv_record_size);
+  uint32_t cv_record_size;
+  const uint8_t *cv_record = GetCVRecord(&cv_record_size);
   if (cv_record) {
     if (cv_record_signature_ == MD_CVINFOPDB70_SIGNATURE) {
       const MDCVInfoPDB70* cv_record_70 =
           reinterpret_cast<const MDCVInfoPDB70*>(cv_record);
       assert(cv_record_70->cv_signature == MD_CVINFOPDB70_SIGNATURE);
 
       printf("  (cv_record).cv_signature        = 0x%x\n",
              cv_record_70->cv_signature);
@@ -2365,68 +2367,68 @@
 }
 
 
 //
 // MinidumpModuleList
 //
 
 
-u_int32_t MinidumpModuleList::max_modules_ = 1024;
+uint32_t MinidumpModuleList::max_modules_ = 1024;
 
 
 MinidumpModuleList::MinidumpModuleList(Minidump* minidump)
     : MinidumpStream(minidump),
-      range_map_(new RangeMap<u_int64_t, unsigned int>()),
+      range_map_(new RangeMap<uint64_t, unsigned int>()),
       modules_(NULL),
       module_count_(0) {
 }
 
 
 MinidumpModuleList::~MinidumpModuleList() {
   delete range_map_;
   delete modules_;
 }
 
 
-bool MinidumpModuleList::Read(u_int32_t expected_size) {
+bool MinidumpModuleList::Read(uint32_t expected_size) {
   // Invalidate cached data.
   range_map_->Clear();
   delete modules_;
   modules_ = NULL;
   module_count_ = 0;
 
   valid_ = false;
 
-  u_int32_t module_count;
+  uint32_t module_count;
   if (expected_size < sizeof(module_count)) {
     BPLOG(ERROR) << "MinidumpModuleList count size mismatch, " <<
                     expected_size << " < " << sizeof(module_count);
     return false;
   }
   if (!minidump_->ReadBytes(&module_count, sizeof(module_count))) {
     BPLOG(ERROR) << "MinidumpModuleList could not read module count";
     return false;
   }
 
   if (minidump_->swap())
     Swap(&module_count);
 
-  if (module_count > numeric_limits<u_int32_t>::max() / MD_MODULE_SIZE) {
+  if (module_count > numeric_limits<uint32_t>::max() / MD_MODULE_SIZE) {
     BPLOG(ERROR) << "MinidumpModuleList module count " << module_count <<
                     " would cause multiplication overflow";
     return false;
   }
 
   if (expected_size != sizeof(module_count) +
                        module_count * MD_MODULE_SIZE) {
     // may be padded with 4 bytes on 64bit ABIs for alignment
     if (expected_size == sizeof(module_count) + 4 +
                          module_count * MD_MODULE_SIZE) {
-      u_int32_t useless;
+      uint32_t useless;
       if (!minidump_->ReadBytes(&useless, 4)) {
         BPLOG(ERROR) << "MinidumpModuleList cannot read modulelist padded bytes";
         return false;
       }
     } else {
       BPLOG(ERROR) << "MinidumpModuleList size mismatch, " << expected_size <<
                       " != " << sizeof(module_count) +
                       module_count * MD_MODULE_SIZE;
@@ -2477,19 +2479,19 @@
                         "auxiliary data for module " <<
                         module_index << "/" << module_count;
         return false;
       }
 
       // It is safe to use module->code_file() after successfully calling
       // module->ReadAuxiliaryData or noting that the module is valid.
 
-      u_int64_t base_address = module->base_address();
-      u_int64_t module_size = module->size();
-      if (base_address == static_cast<u_int64_t>(-1)) {
+      uint64_t base_address = module->base_address();
+      uint64_t module_size = module->size();
+      if (base_address == static_cast<uint64_t>(-1)) {
         BPLOG(ERROR) << "MinidumpModuleList found bad base address "
                         "for module " << module_index << "/" << module_count <<
                         ", " << module->code_file();
         return false;
       }
 
       if (!range_map_->StoreRange(base_address, module_size, module_index)) {
         BPLOG(ERROR) << "MinidumpModuleList could not store module " <<
@@ -2507,17 +2509,17 @@
   module_count_ = module_count;
 
   valid_ = true;
   return true;
 }
 
 
 const MinidumpModule* MinidumpModuleList::GetModuleForAddress(
-    u_int64_t address) const {
+    uint64_t address) const {
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpModuleList for GetModuleForAddress";
     return NULL;
   }
 
   unsigned int module_index;
   if (!range_map_->RetrieveRange(address, &module_index, NULL, NULL)) {
     BPLOG(INFO) << "MinidumpModuleList has no module at " <<
@@ -2606,73 +2608,73 @@
 }
 
 
 //
 // MinidumpMemoryList
 //
 
 
-u_int32_t MinidumpMemoryList::max_regions_ = 4096;
+uint32_t MinidumpMemoryList::max_regions_ = 4096;
 
 
 MinidumpMemoryList::MinidumpMemoryList(Minidump* minidump)
     : MinidumpStream(minidump),
-      range_map_(new RangeMap<u_int64_t, unsigned int>()),
+      range_map_(new RangeMap<uint64_t, unsigned int>()),
       descriptors_(NULL),
       regions_(NULL),
       region_count_(0) {
 }
 
 
 MinidumpMemoryList::~MinidumpMemoryList() {
   delete range_map_;
   delete descriptors_;
   delete regions_;
 }
 
 
-bool MinidumpMemoryList::Read(u_int32_t expected_size) {
+bool MinidumpMemoryList::Read(uint32_t expected_size) {
   // Invalidate cached data.
   delete descriptors_;
   descriptors_ = NULL;
   delete regions_;
   regions_ = NULL;
   range_map_->Clear();
   region_count_ = 0;
 
   valid_ = false;
 
-  u_int32_t region_count;
+  uint32_t region_count;
   if (expected_size < sizeof(region_count)) {
     BPLOG(ERROR) << "MinidumpMemoryList count size mismatch, " <<
                     expected_size << " < " << sizeof(region_count);
     return false;
   }
   if (!minidump_->ReadBytes(&region_count, sizeof(region_count))) {
     BPLOG(ERROR) << "MinidumpMemoryList could not read memory region count";
     return false;
   }
 
   if (minidump_->swap())
     Swap(&region_count);
 
   if (region_count >
-          numeric_limits<u_int32_t>::max() / sizeof(MDMemoryDescriptor)) {
+          numeric_limits<uint32_t>::max() / sizeof(MDMemoryDescriptor)) {
     BPLOG(ERROR) << "MinidumpMemoryList region count " << region_count <<
                     " would cause multiplication overflow";
     return false;
   }
 
   if (expected_size != sizeof(region_count) +
                        region_count * sizeof(MDMemoryDescriptor)) {
     // may be padded with 4 bytes on 64bit ABIs for alignment
     if (expected_size == sizeof(region_count) + 4 +
                          region_count * sizeof(MDMemoryDescriptor)) {
-      u_int32_t useless;
+      uint32_t useless;
       if (!minidump_->ReadBytes(&useless, 4)) {
         BPLOG(ERROR) << "MinidumpMemoryList cannot read memorylist padded bytes";
         return false;
       }
     } else {
       BPLOG(ERROR) << "MinidumpMemoryList size mismatch, " << expected_size <<
                       " != " << sizeof(region_count) + 
                       region_count * sizeof(MDMemoryDescriptor);
@@ -2704,22 +2706,22 @@
     for (unsigned int region_index = 0;
          region_index < region_count;
          ++region_index) {
       MDMemoryDescriptor* descriptor = &(*descriptors)[region_index];
 
       if (minidump_->swap())
         Swap(descriptor);
 
-      u_int64_t base_address = descriptor->start_of_memory_range;
-      u_int32_t region_size = descriptor->memory.data_size;
+      uint64_t base_address = descriptor->start_of_memory_range;
+      uint32_t region_size = descriptor->memory.data_size;
 
       // Check for base + size overflow or undersize.
       if (region_size == 0 ||
-          region_size > numeric_limits<u_int64_t>::max() - base_address) {
+          region_size > numeric_limits<uint64_t>::max() - base_address) {
         BPLOG(ERROR) << "MinidumpMemoryList has a memory region problem, " <<
                         " region " << region_index << "/" << region_count <<
                         ", " << HexString(base_address) << "+" <<
                         HexString(region_size);
         return false;
       }
 
       if (!range_map_->StoreRange(base_address, region_size, region_index)) {
@@ -2757,17 +2759,17 @@
     return NULL;
   }
 
   return &(*regions_)[index];
 }
 
 
 MinidumpMemoryRegion* MinidumpMemoryList::GetMemoryRegionForAddress(
-    u_int64_t address) {
+    uint64_t address) {
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpMemoryList for GetMemoryRegionForAddress";
     return NULL;
   }
 
   unsigned int region_index;
   if (!range_map_->RetrieveRange(address, &region_index, NULL, NULL)) {
     BPLOG(INFO) << "MinidumpMemoryList has no memory region at " <<
@@ -2823,17 +2825,17 @@
 }
 
 
 MinidumpException::~MinidumpException() {
   delete context_;
 }
 
 
-bool MinidumpException::Read(u_int32_t expected_size) {
+bool MinidumpException::Read(uint32_t expected_size) {
   // Invalidate cached data.
   delete context_;
   context_ = NULL;
 
   valid_ = false;
 
   if (expected_size != sizeof(exception_)) {
     BPLOG(ERROR) << "MinidumpException size mismatch, " << expected_size <<
@@ -2865,17 +2867,17 @@
     Swap(&exception_.thread_context);
   }
 
   valid_ = true;
   return true;
 }
 
 
-bool MinidumpException::GetThreadID(u_int32_t *thread_id) const {
+bool MinidumpException::GetThreadID(uint32_t *thread_id) const {
   BPLOG_IF(ERROR, !thread_id) << "MinidumpException::GetThreadID requires "
                                  "|thread_id|";
   assert(thread_id);
   *thread_id = 0;
 
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpException for GetThreadID";
     return false;
@@ -2967,17 +2969,17 @@
       file_() {
 }
 
 
 MinidumpAssertion::~MinidumpAssertion() {
 }
 
 
-bool MinidumpAssertion::Read(u_int32_t expected_size) {
+bool MinidumpAssertion::Read(uint32_t expected_size) {
   // Invalidate cached data.
   valid_ = false;
 
   if (expected_size != sizeof(assertion_)) {
     BPLOG(ERROR) << "MinidumpAssertion size mismatch, " << expected_size <<
                     " != " << sizeof(assertion_);
     return false;
   }
@@ -2988,48 +2990,48 @@
   }
 
   // Each of {expression, function, file} is a UTF-16 string,
   // we'll convert them to UTF-8 for ease of use.
   // expression
   // Since we don't have an explicit byte length for each string,
   // we use UTF16codeunits to calculate word length, then derive byte
   // length from that.
-  u_int32_t word_length = UTF16codeunits(assertion_.expression,
+  uint32_t word_length = UTF16codeunits(assertion_.expression,
                                          sizeof(assertion_.expression));
   if (word_length > 0) {
-    u_int32_t byte_length = word_length * 2;
-    vector<u_int16_t> expression_utf16(word_length);
+    uint32_t byte_length = word_length * 2;
+    vector<uint16_t> expression_utf16(word_length);
     memcpy(&expression_utf16[0], &assertion_.expression[0], byte_length);
 
     scoped_ptr<string> new_expression(UTF16ToUTF8(expression_utf16,
                                                   minidump_->swap()));
     if (new_expression.get())
       expression_ = *new_expression;
   }
   
   // assertion
   word_length = UTF16codeunits(assertion_.function,
                                sizeof(assertion_.function));
   if (word_length) {
-    u_int32_t byte_length = word_length * 2;
-    vector<u_int16_t> function_utf16(word_length);
+    uint32_t byte_length = word_length * 2;
+    vector<uint16_t> function_utf16(word_length);
     memcpy(&function_utf16[0], &assertion_.function[0], byte_length);
     scoped_ptr<string> new_function(UTF16ToUTF8(function_utf16,
                                                 minidump_->swap()));
     if (new_function.get())
       function_ = *new_function;
   }
 
   // file
   word_length = UTF16codeunits(assertion_.file,
                                sizeof(assertion_.file));
   if (word_length > 0) {
-    u_int32_t byte_length = word_length * 2;
-    vector<u_int16_t> file_utf16(word_length);
+    uint32_t byte_length = word_length * 2;
+    vector<uint16_t> file_utf16(word_length);
     memcpy(&file_utf16[0], &assertion_.file[0], byte_length);
     scoped_ptr<string> new_file(UTF16ToUTF8(file_utf16,
                                             minidump_->swap()));
     if (new_file.get())
       file_ = *new_file;
   }
 
   if (minidump_->swap()) {
@@ -3075,17 +3077,17 @@
 
 
 MinidumpSystemInfo::~MinidumpSystemInfo() {
   delete csd_version_;
   delete cpu_vendor_;
 }
 
 
-bool MinidumpSystemInfo::Read(u_int32_t expected_size) {
+bool MinidumpSystemInfo::Read(uint32_t expected_size) {
   // Invalidate cached data.
   delete csd_version_;
   csd_version_ = NULL;
   delete cpu_vendor_;
   cpu_vendor_ = NULL;
 
   valid_ = false;
 
@@ -3327,17 +3329,17 @@
 
 
 MinidumpMiscInfo::MinidumpMiscInfo(Minidump* minidump)
     : MinidumpStream(minidump),
       misc_info_() {
 }
 
 
-bool MinidumpMiscInfo::Read(u_int32_t expected_size) {
+bool MinidumpMiscInfo::Read(uint32_t expected_size) {
   valid_ = false;
 
   if (expected_size != MD_MISCINFO_SIZE &&
       expected_size != MD_MISCINFO2_SIZE) {
     BPLOG(ERROR) << "MinidumpMiscInfo size mismatch, " << expected_size <<
                     " != " << MD_MISCINFO_SIZE << ", " << MD_MISCINFO2_SIZE <<
                     ")";
     return false;
@@ -3413,17 +3415,17 @@
 
 
 MinidumpBreakpadInfo::MinidumpBreakpadInfo(Minidump* minidump)
     : MinidumpStream(minidump),
       breakpad_info_() {
 }
 
 
-bool MinidumpBreakpadInfo::Read(u_int32_t expected_size) {
+bool MinidumpBreakpadInfo::Read(uint32_t expected_size) {
   valid_ = false;
 
   if (expected_size != sizeof(breakpad_info_)) {
     BPLOG(ERROR) << "MinidumpBreakpadInfo size mismatch, " << expected_size <<
                     " != " << sizeof(breakpad_info_);
     return false;
   }
 
@@ -3438,17 +3440,17 @@
     Swap(&breakpad_info_.requesting_thread_id);
   }
 
   valid_ = true;
   return true;
 }
 
 
-bool MinidumpBreakpadInfo::GetDumpThreadID(u_int32_t *thread_id) const {
+bool MinidumpBreakpadInfo::GetDumpThreadID(uint32_t *thread_id) const {
   BPLOG_IF(ERROR, !thread_id) << "MinidumpBreakpadInfo::GetDumpThreadID "
                                  "requires |thread_id|";
   assert(thread_id);
   *thread_id = 0;
 
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpBreakpadInfo for GetDumpThreadID";
     return false;
@@ -3459,17 +3461,17 @@
     return false;
   }
 
   *thread_id = breakpad_info_.dump_thread_id;
   return true;
 }
 
 
-bool MinidumpBreakpadInfo::GetRequestingThreadID(u_int32_t *thread_id)
+bool MinidumpBreakpadInfo::GetRequestingThreadID(uint32_t *thread_id)
     const {
   BPLOG_IF(ERROR, !thread_id) << "MinidumpBreakpadInfo::GetRequestingThreadID "
                                  "requires |thread_id|";
   assert(thread_id);
   *thread_id = 0;
 
   if (!thread_id || !valid_) {
     BPLOG(ERROR) << "Invalid MinidumpBreakpadInfo for GetRequestingThreadID";
@@ -3520,26 +3522,26 @@
 
 MinidumpMemoryInfo::MinidumpMemoryInfo(Minidump* minidump)
     : MinidumpObject(minidump),
       memory_info_() {
 }
 
 
 bool MinidumpMemoryInfo::IsExecutable() const {
-  u_int32_t protection =
+  uint32_t protection =
       memory_info_.protection & MD_MEMORY_PROTECTION_ACCESS_MASK;
   return protection == MD_MEMORY_PROTECT_EXECUTE ||
       protection == MD_MEMORY_PROTECT_EXECUTE_READ ||
       protection == MD_MEMORY_PROTECT_EXECUTE_READWRITE;
 }
 
 
 bool MinidumpMemoryInfo::IsWritable() const {
-  u_int32_t protection =
+  uint32_t protection =
       memory_info_.protection & MD_MEMORY_PROTECTION_ACCESS_MASK;
   return protection == MD_MEMORY_PROTECT_READWRITE ||
     protection == MD_MEMORY_PROTECT_WRITECOPY ||
     protection == MD_MEMORY_PROTECT_EXECUTE_READWRITE ||
     protection == MD_MEMORY_PROTECT_EXECUTE_WRITECOPY;
 }
 
 
@@ -3558,17 +3560,17 @@
     Swap(&memory_info_.region_size);
     Swap(&memory_info_.state);
     Swap(&memory_info_.protection);
     Swap(&memory_info_.type);
   }
 
   // Check for base + size overflow or undersize.
   if (memory_info_.region_size == 0 ||
-      memory_info_.region_size > numeric_limits<u_int64_t>::max() -
+      memory_info_.region_size > numeric_limits<uint64_t>::max() -
                                      memory_info_.base_address) {
     BPLOG(ERROR) << "MinidumpMemoryInfo has a memory region problem, " <<
                     HexString(memory_info_.base_address) << "+" <<
                     HexString(memory_info_.region_size);
     return false;
   }
 
   valid_ = true;
@@ -3598,29 +3600,29 @@
 
 //
 // MinidumpMemoryInfoList
 //
 
 
 MinidumpMemoryInfoList::MinidumpMemoryInfoList(Minidump* minidump)
     : MinidumpStream(minidump),
-      range_map_(new RangeMap<u_int64_t, unsigned int>()),
+      range_map_(new RangeMap<uint64_t, unsigned int>()),
       infos_(NULL),
       info_count_(0) {
 }
 
 
 MinidumpMemoryInfoList::~MinidumpMemoryInfoList() {
   delete range_map_;
   delete infos_;
 }
 
 
-bool MinidumpMemoryInfoList::Read(u_int32_t expected_size) {
+bool MinidumpMemoryInfoList::Read(uint32_t expected_size) {
   // Invalidate cached data.
   delete infos_;
   infos_ = NULL;
   range_map_->Clear();
   info_count_ = 0;
 
   valid_ = false;
 
@@ -3655,17 +3657,17 @@
   if (header.size_of_entry != sizeof(MDRawMemoryInfo)) {
     BPLOG(ERROR) << "MinidumpMemoryInfoList entry size mismatch, " <<
                     header.size_of_entry << " != " <<
                     sizeof(MDRawMemoryInfo);
     return false;
   }
 
   if (header.number_of_entries >
-          numeric_limits<u_int32_t>::max() / sizeof(MDRawMemoryInfo)) {
+          numeric_limits<uint32_t>::max() / sizeof(MDRawMemoryInfo)) {
     BPLOG(ERROR) << "MinidumpMemoryInfoList info count " <<
                     header.number_of_entries <<
                     " would cause multiplication overflow";
     return false;
   }
 
   if (expected_size != sizeof(MDRawMemoryInfoList) +
                         header.number_of_entries * sizeof(MDRawMemoryInfo)) {
@@ -3687,18 +3689,18 @@
 
       // Assume that the file offset is correct after the last read.
       if (!info->Read()) {
         BPLOG(ERROR) << "MinidumpMemoryInfoList cannot read info " <<
                         index << "/" << header.number_of_entries;
         return false;
       }
 
-      u_int64_t base_address = info->GetBase();
-      u_int32_t region_size = info->GetSize();
+      uint64_t base_address = info->GetBase();
+      uint32_t region_size = info->GetSize();
 
       if (!range_map_->StoreRange(base_address, region_size, index)) {
         BPLOG(ERROR) << "MinidumpMemoryInfoList could not store"
                         " memory region " <<
                         index << "/" << header.number_of_entries << ", " <<
                         HexString(base_address) << "+" <<
                         HexString(region_size);
         return false;
@@ -3728,17 +3730,17 @@
     return NULL;
   }
 
   return &(*infos_)[index];
 }
 
 
 const MinidumpMemoryInfo* MinidumpMemoryInfoList::GetMemoryInfoForAddress(
-    u_int64_t address) const {
+    uint64_t address) const {
   if (!valid_) {
     BPLOG(ERROR) << "Invalid MinidumpMemoryInfoList for"
                     " GetMemoryInfoForAddress";
     return NULL;
   }
 
   unsigned int info_index;
   if (!range_map_->RetrieveRange(address, &info_index, NULL, NULL)) {
@@ -3771,17 +3773,17 @@
 }
 
 
 //
 // Minidump
 //
 
 
-u_int32_t Minidump::max_streams_ = 128;
+uint32_t Minidump::max_streams_ = 128;
 unsigned int Minidump::max_string_length_ = 1024;
 
 
 Minidump::Minidump(const string& path)
     : header_(),
       directory_(NULL),
       stream_map_(new MinidumpStreamMap()),
       path_(path),
@@ -3829,17 +3831,17 @@
                     ", error " << error_code << ": " << error_string;
     return false;
   }
 
   BPLOG(INFO) << "Minidump opened minidump " << path_;
   return true;
 }
 
-bool Minidump::GetContextCPUFlagsFromSystemInfo(u_int32_t *context_cpu_flags) {
+bool Minidump::GetContextCPUFlagsFromSystemInfo(uint32_t *context_cpu_flags) {
   // Initialize output parameters
   *context_cpu_flags = 0;
 
   // Save the current stream position
   off_t saved_position = Tell();
   if (saved_position == -1) {
     // Failed to save the current stream position.
     // Returns true because the current position of the stream is preserved.
@@ -3919,17 +3921,17 @@
     return false;
   }
 
   if (header_.signature != MD_HEADER_SIGNATURE) {
     // The file may be byte-swapped.  Under the present architecture, these
     // classes don't know or need to know what CPU (or endianness) the
     // minidump was produced on in order to parse it.  Use the signature as
     // a byte order marker.
-    u_int32_t signature_swapped = header_.signature;
+    uint32_t signature_swapped = header_.signature;
     Swap(&signature_swapped);
     if (signature_swapped != MD_HEADER_SIGNATURE) {
       // This isn't a minidump or a byte-swapped minidump.
       BPLOG(ERROR) << "Minidump header signature mismatch: (" <<
                       HexString(header_.signature) << ", " <<
                       HexString(signature_swapped) << ") != " <<
                       HexString(MD_HEADER_SIGNATURE);
       return false;
@@ -4123,17 +4125,17 @@
     printf("  location.rva       = 0x%x\n", directory_entry->location.rva);
     printf("\n");
   }
 
   printf("Streams:\n");
   for (MinidumpStreamMap::const_iterator iterator = stream_map_->begin();
        iterator != stream_map_->end();
        ++iterator) {
-    u_int32_t stream_type = iterator->first;
+    uint32_t stream_type = iterator->first;
     MinidumpStreamInfo info = iterator->second;
     printf("  stream type 0x%x at index %d\n", stream_type, info.stream_index);
   }
   printf("\n");
 }
 
 
 const MDRawDirectory* Minidump::GetDirectoryEntryAtIndex(unsigned int index)
@@ -4205,17 +4207,17 @@
     BPLOG(ERROR) << "Invalid Minidump for ReadString";
     return NULL;
   }
   if (!SeekSet(offset)) {
     BPLOG(ERROR) << "ReadString could not seek to string at offset " << offset;
     return NULL;
   }
 
-  u_int32_t bytes;
+  uint32_t bytes;
   if (!ReadBytes(&bytes, sizeof(bytes))) {
     BPLOG(ERROR) << "ReadString could not read string size at offset " <<
                     offset;
     return NULL;
   }
   if (swap_)
     Swap(&bytes);
 
@@ -4228,32 +4230,32 @@
 
   if (utf16_words > max_string_length_) {
     BPLOG(ERROR) << "ReadString string length " << utf16_words <<
                     " exceeds maximum " << max_string_length_ <<
                     " at offset " << offset;
     return NULL;
   }
 
-  vector<u_int16_t> string_utf16(utf16_words);
+  vector<uint16_t> string_utf16(utf16_words);
 
   if (utf16_words) {
     if (!ReadBytes(&string_utf16[0], bytes)) {
       BPLOG(ERROR) << "ReadString could not read " << bytes <<
                       "-byte string at offset " << offset;
       return NULL;
     }
   }
 
   return UTF16ToUTF8(string_utf16, swap_);
 }
 
 
-bool Minidump::SeekToStreamType(u_int32_t  stream_type,
-                                u_int32_t* stream_length) {
+bool Minidump::SeekToStreamType(uint32_t  stream_type,
+                                uint32_t* stream_length) {
   BPLOG_IF(ERROR, !stream_length) << "Minidump::SeekToStreamType requires "
                                      "|stream_length|";
   assert(stream_length);
   *stream_length = 0;
 
   if (!valid_) {
     BPLOG(ERROR) << "Invalid Mindump for SeekToStreamType";
     return false;
@@ -4287,17 +4289,17 @@
 }
 
 
 template<typename T>
 T* Minidump::GetStream(T** stream) {
   // stream is a garbage parameter that's present only to account for C++'s
   // inability to overload a method based solely on its return type.
 
-  const u_int32_t stream_type = T::kStreamType;
+  const uint32_t stream_type = T::kStreamType;
 
   BPLOG_IF(ERROR, !stream) << "Minidump::GetStream type " << stream_type <<
                               " requires |stream|";
   assert(stream);
   *stream = NULL;
 
   if (!valid_) {
     BPLOG(ERROR) << "Invalid Minidump for GetStream type " << stream_type;
@@ -4316,17 +4318,17 @@
 
   if (info->stream) {
     // This cast is safe because info.stream is only populated by this
     // method, and there is a direct correlation between T and stream_type.
     *stream = static_cast<T*>(info->stream);
     return *stream;
   }
 
-  u_int32_t stream_length;
+  uint32_t stream_length;
   if (!SeekToStreamType(stream_type, &stream_length)) {
     BPLOG(ERROR) << "GetStream could not seek to stream type " << stream_type;
     return NULL;
   }
 
   scoped_ptr<T> new_stream(new T(this));
 
   if (!new_stream->Read(stream_length)) {
diff --git a/src/processor/minidump_dump.cc b/src/processor/minidump_dump.cc
--- a/src/processor/minidump_dump.cc
+++ b/src/processor/minidump_dump.cc
@@ -48,20 +48,20 @@
 using google_breakpad::MinidumpMemoryList;
 using google_breakpad::MinidumpException;
 using google_breakpad::MinidumpAssertion;
 using google_breakpad::MinidumpSystemInfo;
 using google_breakpad::MinidumpMiscInfo;
 using google_breakpad::MinidumpBreakpadInfo;
 
 static void DumpRawStream(Minidump *minidump,
-                          u_int32_t stream_type,
+                          uint32_t stream_type,
                           const char *stream_name,
                           int *errors) {
-  u_int32_t length = 0;
+  uint32_t length = 0;
   if (!minidump->SeekToStreamType(stream_type, &length)) {
     return;
   }
 
   printf("Stream %s:\n", stream_name);
 
   if (length == 0) {
     printf("\n");
@@ -73,17 +73,17 @@
     BPLOG(ERROR) << "minidump.ReadBytes failed";
     return;
   }
   size_t current_offset = 0;
   while (current_offset < length) {
     size_t remaining = length - current_offset;
     // Printf requires an int and direct casting from size_t results
     // in compatibility warnings.
-    u_int32_t int_remaining = remaining;
+    uint32_t int_remaining = remaining;
     printf("%.*s", int_remaining, &contents[current_offset]);
     char *next_null = reinterpret_cast<char *>(
         memchr(&contents[current_offset], 0, remaining));
     if (next_null == NULL)
       break;
     printf("\\0\n");
     size_t null_offset = next_null - &contents[0];
     current_offset = null_offset + 1;
diff --git a/src/processor/minidump_processor.cc b/src/processor/minidump_processor.cc
--- a/src/processor/minidump_processor.cc
+++ b/src/processor/minidump_processor.cc
@@ -82,19 +82,19 @@
     BPLOG(ERROR) << "Minidump " << dump->path() << " has no header";
     return PROCESS_ERROR_NO_MINIDUMP_HEADER;
   }
   process_state->time_date_stamp_ = header->time_date_stamp;
 
   bool has_cpu_info = GetCPUInfo(dump, &process_state->system_info_);
   bool has_os_info = GetOSInfo(dump, &process_state->system_info_);
 
-  u_int32_t dump_thread_id = 0;
+  uint32_t dump_thread_id = 0;
   bool has_dump_thread = false;
-  u_int32_t requesting_thread_id = 0;
+  uint32_t requesting_thread_id = 0;
   bool has_requesting_thread = false;
 
   MinidumpBreakpadInfo *breakpad_info = dump->GetBreakpadInfo();
   if (breakpad_info) {
     has_dump_thread = breakpad_info->GetDumpThreadID(&dump_thread_id);
     has_requesting_thread =
         breakpad_info->GetRequestingThreadID(&requesting_thread_id);
   }
@@ -151,17 +151,17 @@
     string thread_string = dump->path() + ":" + thread_string_buffer;
 
     MinidumpThread *thread = threads->GetThreadAtIndex(thread_index);
     if (!thread) {
       BPLOG(ERROR) << "Could not get thread for " << thread_string;
       return PROCESS_ERROR_GETTING_THREAD;
     }
 
-    u_int32_t thread_id;
+    uint32_t thread_id;
     if (!thread->GetThreadID(&thread_id)) {
       BPLOG(ERROR) << "Could not get thread ID for " << thread_string;
       return PROCESS_ERROR_GETTING_THREAD_ID;
     }
 
     thread_string += " id " + HexString(thread_id);
     BPLOG(INFO) << "Looking at thread " << thread_string;
 
@@ -445,35 +445,35 @@
     info->os_version.append(" ");
     info->os_version.append(*csd_version);
   }
 
   return true;
 }
 
 // static
-string MinidumpProcessor::GetCrashReason(Minidump *dump, u_int64_t *address) {
+string MinidumpProcessor::GetCrashReason(Minidump *dump, uint64_t *address) {
   MinidumpException *exception = dump->GetException();
   if (!exception)
     return "";
 
   const MDRawExceptionStream *raw_exception = exception->exception();
   if (!raw_exception)
     return "";
 
   if (address)
     *address = raw_exception->exception_record.exception_address;
 
   // The reason value is OS-specific and possibly CPU-specific.  Set up
   // sensible numeric defaults for the reason string in case we can't
   // map the codes to a string (because there's no system info, or because
   // it's an unrecognized platform, or because it's an unrecognized code.)
   char reason_string[24];
-  u_int32_t exception_code = raw_exception->exception_record.exception_code;
-  u_int32_t exception_flags = raw_exception->exception_record.exception_flags;
+  uint32_t exception_code = raw_exception->exception_record.exception_code;
+  uint32_t exception_flags = raw_exception->exception_record.exception_flags;
   snprintf(reason_string, sizeof(reason_string), "0x%08x / 0x%08x",
            exception_code, exception_flags);
   string reason = reason_string;
 
   const MDRawSystemInfo *raw_system_info = GetSystemInfo(dump, NULL);
   if (!raw_system_info)
     return reason;
 
diff --git a/src/processor/minidump_processor_unittest.cc b/src/processor/minidump_processor_unittest.cc
--- a/src/processor/minidump_processor_unittest.cc
+++ b/src/processor/minidump_processor_unittest.cc
@@ -79,43 +79,43 @@
   MOCK_CONST_METHOD0(thread_count, unsigned int());
   MOCK_CONST_METHOD1(GetThreadAtIndex, MinidumpThread*(unsigned int));
 };
 
 class MockMinidumpThread : public MinidumpThread {
  public:
   MockMinidumpThread() : MinidumpThread(NULL) {}
 
-  MOCK_CONST_METHOD1(GetThreadID, bool(u_int32_t*));
+  MOCK_CONST_METHOD1(GetThreadID, bool(uint32_t*));
   MOCK_METHOD0(GetContext, MinidumpContext*());
   MOCK_METHOD0(GetMemory, MinidumpMemoryRegion*());
 };
 
 // This is crappy, but MinidumpProcessor really does want a
 // MinidumpMemoryRegion.
 class MockMinidumpMemoryRegion : public MinidumpMemoryRegion {
  public:
-  MockMinidumpMemoryRegion(u_int64_t base, const string& contents) :
+  MockMinidumpMemoryRegion(uint64_t base, const string& contents) :
       MinidumpMemoryRegion(NULL) {
     region_.Init(base, contents);
   }
 
-  u_int64_t GetBase() const { return region_.GetBase(); }
-  u_int32_t GetSize() const { return region_.GetSize(); }
+  uint64_t GetBase() const { return region_.GetBase(); }
+  uint32_t GetSize() const { return region_.GetSize(); }
 
-  bool GetMemoryAtAddress(u_int64_t address, u_int8_t  *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint8_t  *value) const {
     return region_.GetMemoryAtAddress(address, value);
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int16_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint16_t *value) const {
     return region_.GetMemoryAtAddress(address, value);
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int32_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint32_t *value) const {
     return region_.GetMemoryAtAddress(address, value);
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int64_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint64_t *value) const {
     return region_.GetMemoryAtAddress(address, value);
   }
 
   MockMemoryRegion region_;
 };
 
 }  // namespace google_breakpad
 
@@ -470,17 +470,17 @@
                          Return(true)));
   EXPECT_CALL(no_memory_thread, GetMemory()).
     WillRepeatedly(Return((MinidumpMemoryRegion*)NULL));
 
   MDRawContextX86 no_memory_thread_raw_context;
   memset(&no_memory_thread_raw_context, 0,
          sizeof(no_memory_thread_raw_context));
   no_memory_thread_raw_context.context_flags = MD_CONTEXT_X86_FULL;
-  const u_int32_t kExpectedEIP = 0xabcd1234;
+  const uint32_t kExpectedEIP = 0xabcd1234;
   no_memory_thread_raw_context.eip = kExpectedEIP;
   TestMinidumpContext no_memory_thread_context(no_memory_thread_raw_context);
   EXPECT_CALL(no_memory_thread, GetContext()).
     WillRepeatedly(Return(&no_memory_thread_context));
 
   EXPECT_CALL(thread_list, thread_count()).
     WillRepeatedly(Return(1));
   EXPECT_CALL(thread_list, GetThreadAtIndex(0)).
diff --git a/src/processor/minidump_stackwalk.cc b/src/processor/minidump_stackwalk.cc
--- a/src/processor/minidump_stackwalk.cc
+++ b/src/processor/minidump_stackwalk.cc
@@ -79,31 +79,31 @@
 // PrintRegister prints a register's name and value to stdout.  It will
 // print four registers on a line.  For the first register in a set,
 // pass 0 for |start_col|.  For registers in a set, pass the most recent
 // return value of PrintRegister.
 // The caller is responsible for printing the final newline after a set
 // of registers is completely printed, regardless of the number of calls
 // to PrintRegister.
 static const int kMaxWidth = 80;  // optimize for an 80-column terminal
-static int PrintRegister(const char *name, u_int32_t value, int start_col) {
+static int PrintRegister(const char *name, uint32_t value, int start_col) {
   char buffer[64];
   snprintf(buffer, sizeof(buffer), " %5s = 0x%08x", name, value);
 
   if (start_col + static_cast<ssize_t>(strlen(buffer)) > kMaxWidth) {
     start_col = 0;
     printf("\n ");
   }
   fputs(buffer, stdout);
 
   return start_col + strlen(buffer);
 }
 
 // PrintRegister64 does the same thing, but for 64-bit registers.
-static int PrintRegister64(const char *name, u_int64_t value, int start_col) {
+static int PrintRegister64(const char *name, uint64_t value, int start_col) {
   char buffer[64];
   snprintf(buffer, sizeof(buffer), " %5s = 0x%016" PRIx64 , name, value);
 
   if (start_col + static_cast<ssize_t>(strlen(buffer)) > kMaxWidth) {
     start_col = 0;
     printf("\n ");
   }
   fputs(buffer, stdout);
@@ -139,17 +139,17 @@
   int frame_count = stack->frames()->size();
   if (frame_count == 0) {
     printf(" <no frames>\n");
   }
   for (int frame_index = 0; frame_index < frame_count; ++frame_index) {
     const StackFrame *frame = stack->frames()->at(frame_index);
     printf("%2d  ", frame_index);
 
-    u_int64_t instruction_address = frame->ReturnAddress();
+    uint64_t instruction_address = frame->ReturnAddress();
 
     if (frame->module) {
       printf("%s", PathnameStripper::File(frame->module->code_file()).c_str());
       if (!frame->function_name.empty()) {
         printf("!%s", frame->function_name.c_str());
         if (!frame->source_file_name.empty()) {
           string source_file = PathnameStripper::File(frame->source_file_name);
           printf(" [%s : %d + 0x%" PRIx64 "]",
@@ -283,17 +283,17 @@
 // PrintStack above.
 static void PrintStackMachineReadable(int thread_num, const CallStack *stack) {
   int frame_count = stack->frames()->size();
   for (int frame_index = 0; frame_index < frame_count; ++frame_index) {
     const StackFrame *frame = stack->frames()->at(frame_index);
     printf("%d%c%d%c", thread_num, kOutputSeparator, frame_index,
            kOutputSeparator);
 
-    u_int64_t instruction_address = frame->ReturnAddress();
+    uint64_t instruction_address = frame->ReturnAddress();
 
     if (frame->module) {
       assert(!frame->module->code_file().empty());
       printf("%s", StripSeparator(PathnameStripper::File(
                      frame->module->code_file())).c_str());
       if (!frame->function_name.empty()) {
         printf("%c%s", kOutputSeparator,
                StripSeparator(frame->function_name).c_str());
@@ -335,28 +335,28 @@
 
 static void PrintModules(const CodeModules *modules) {
   if (!modules)
     return;
 
   printf("\n");
   printf("Loaded modules:\n");
 
-  u_int64_t main_address = 0;
+  uint64_t main_address = 0;
   const CodeModule *main_module = modules->GetMainModule();
   if (main_module) {
     main_address = main_module->base_address();
   }
 
   unsigned int module_count = modules->module_count();
   for (unsigned int module_sequence = 0;
        module_sequence < module_count;
        ++module_sequence) {
     const CodeModule *module = modules->GetModuleAtSequence(module_sequence);
-    u_int64_t base_address = module->base_address();
+    uint64_t base_address = module->base_address();
     printf("0x%08" PRIx64 " - 0x%08" PRIx64 "  %s  %s%s\n",
            base_address, base_address + module->size() - 1,
            PathnameStripper::File(module->code_file()).c_str(),
            module->version().empty() ? "???" : module->version().c_str(),
            main_module != NULL && base_address == main_address ?
                "  (main)" : "");
   }
 }
@@ -365,28 +365,28 @@
 // one per line, in the following machine-readable pipe-delimited
 // text format:
 // Module|{Module Filename}|{Version}|{Debug Filename}|{Debug Identifier}|
 // {Base Address}|{Max Address}|{Main}
 static void PrintModulesMachineReadable(const CodeModules *modules) {
   if (!modules)
     return;
 
-  u_int64_t main_address = 0;
+  uint64_t main_address = 0;
   const CodeModule *main_module = modules->GetMainModule();
   if (main_module) {
     main_address = main_module->base_address();
   }
 
   unsigned int module_count = modules->module_count();
   for (unsigned int module_sequence = 0;
        module_sequence < module_count;
        ++module_sequence) {
     const CodeModule *module = modules->GetModuleAtSequence(module_sequence);
-    u_int64_t base_address = module->base_address();
+    uint64_t base_address = module->base_address();
     printf("Module%c%s%c%s%c%s%c%s%c0x%08" PRIx64 "%c0x%08" PRIx64 "%c%d\n",
            kOutputSeparator,
            StripSeparator(PathnameStripper::File(module->code_file())).c_str(),
            kOutputSeparator, StripSeparator(module->version()).c_str(),
            kOutputSeparator,
            StripSeparator(PathnameStripper::File(module->debug_file())).c_str(),
            kOutputSeparator,
            StripSeparator(module->debug_identifier()).c_str(),
diff --git a/src/processor/minidump_unittest.cc b/src/processor/minidump_unittest.cc
--- a/src/processor/minidump_unittest.cc
+++ b/src/processor/minidump_unittest.cc
@@ -84,17 +84,17 @@
 };
 
 TEST_F(MinidumpTest, TestMinidumpFromFile) {
   Minidump minidump(minidump_file_);
   ASSERT_EQ(minidump.path(), minidump_file_);
   ASSERT_TRUE(minidump.Read());
   const MDRawHeader* header = minidump.header();
   ASSERT_NE(header, (MDRawHeader*)NULL);
-  ASSERT_EQ(header->signature, u_int32_t(MD_HEADER_SIGNATURE));
+  ASSERT_EQ(header->signature, uint32_t(MD_HEADER_SIGNATURE));
   //TODO: add more checks here
 }
 
 TEST_F(MinidumpTest, TestMinidumpFromStream) {
   // read minidump contents into memory, construct a stringstream around them
   ifstream file_stream(minidump_file_.c_str(), std::ios::in);
   ASSERT_TRUE(file_stream.good());
   vector<char> bytes;
@@ -110,17 +110,17 @@
   ASSERT_TRUE(stream.good());
 
   // now read minidump from stringstream
   Minidump minidump(stream);
   ASSERT_EQ(minidump.path(), "");
   ASSERT_TRUE(minidump.Read());
   const MDRawHeader* header = minidump.header();
   ASSERT_NE(header, (MDRawHeader*)NULL);
-  ASSERT_EQ(header->signature, u_int32_t(MD_HEADER_SIGNATURE));
+  ASSERT_EQ(header->signature, uint32_t(MD_HEADER_SIGNATURE));
   //TODO: add more checks here
 }
 
 TEST(Dump, ReadBackEmpty) {
   Dump dump(0);
   dump.Finish();
   string contents;
   ASSERT_TRUE(dump.GetContents(&contents));
@@ -154,17 +154,17 @@
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());
 
   const MDRawDirectory *dir = minidump.GetDirectoryEntryAtIndex(0);
   ASSERT_TRUE(dir != NULL);
   EXPECT_EQ(0xfbb7fa2bU, dir->stream_type);
 
-  u_int32_t stream_length;
+  uint32_t stream_length;
   ASSERT_TRUE(minidump.SeekToStreamType(0xfbb7fa2bU, &stream_length));
   ASSERT_EQ(15U, stream_length);
   char stream_contents[15];
   ASSERT_TRUE(minidump.ReadBytes(stream_contents, sizeof(stream_contents)));
   EXPECT_EQ(string("stream contents"),
             string(stream_contents, sizeof(stream_contents)));
 
   EXPECT_FALSE(minidump.GetThreadList());
@@ -188,37 +188,37 @@
   ASSERT_TRUE(dump.GetContents(&contents));
   istringstream minidump_stream(contents);
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());
 
   const MDRawDirectory *dir = minidump.GetDirectoryEntryAtIndex(0);
   ASSERT_TRUE(dir != NULL);
-  EXPECT_EQ((u_int32_t) MD_MEMORY_LIST_STREAM, dir->stream_type);
+  EXPECT_EQ((uint32_t) MD_MEMORY_LIST_STREAM, dir->stream_type);
 
   MinidumpMemoryList *memory_list = minidump.GetMemoryList();
   ASSERT_TRUE(memory_list != NULL);
   ASSERT_EQ(1U, memory_list->region_count());
 
   MinidumpMemoryRegion *region1 = memory_list->GetMemoryRegionAtIndex(0);
   ASSERT_EQ(0x309d68010bd21b2cULL, region1->GetBase());
   ASSERT_EQ(15U, region1->GetSize());
-  const u_int8_t *region1_bytes = region1->GetMemory();
+  const uint8_t *region1_bytes = region1->GetMemory();
   ASSERT_TRUE(memcmp("memory contents", region1_bytes, 15) == 0);
 }
 
 // One thread --- and its requisite entourage.
 TEST(Dump, OneThread) {
   Dump dump(0, kLittleEndian);
   Memory stack(dump, 0x2326a0fa);
   stack.Append("stack for thread");
 
   MDRawContextX86 raw_context;
-  const u_int32_t kExpectedEIP = 0x6913f540;
+  const uint32_t kExpectedEIP = 0x6913f540;
   raw_context.context_flags = MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL;
   raw_context.edi = 0x3ecba80d;
   raw_context.esi = 0x382583b9;
   raw_context.ebx = 0x7fccc03f;
   raw_context.edx = 0xf62f8ec2;
   raw_context.ecx = 0x46a6a6a8;
   raw_context.eax = 0x6a5025e2;
   raw_context.ebp = 0xd9fabb4a;
@@ -247,46 +247,46 @@
 
   MinidumpMemoryList *md_memory_list = minidump.GetMemoryList();
   ASSERT_TRUE(md_memory_list != NULL);
   ASSERT_EQ(1U, md_memory_list->region_count());
 
   MinidumpMemoryRegion *md_region = md_memory_list->GetMemoryRegionAtIndex(0);
   ASSERT_EQ(0x2326a0faU, md_region->GetBase());
   ASSERT_EQ(16U, md_region->GetSize());
-  const u_int8_t *region_bytes = md_region->GetMemory();
+  const uint8_t *region_bytes = md_region->GetMemory();
   ASSERT_TRUE(memcmp("stack for thread", region_bytes, 16) == 0);
 
   MinidumpThreadList *thread_list = minidump.GetThreadList();
   ASSERT_TRUE(thread_list != NULL);
   ASSERT_EQ(1U, thread_list->thread_count());
 
   MinidumpThread *md_thread = thread_list->GetThreadAtIndex(0);
   ASSERT_TRUE(md_thread != NULL);
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(md_thread->GetThreadID(&thread_id));
   ASSERT_EQ(0xa898f11bU, thread_id);
   MinidumpMemoryRegion *md_stack = md_thread->GetMemory();
   ASSERT_TRUE(md_stack != NULL);
   ASSERT_EQ(0x2326a0faU, md_stack->GetBase());
   ASSERT_EQ(16U, md_stack->GetSize());
-  const u_int8_t *md_stack_bytes = md_stack->GetMemory();
+  const uint8_t *md_stack_bytes = md_stack->GetMemory();
   ASSERT_TRUE(memcmp("stack for thread", md_stack_bytes, 16) == 0);
 
   MinidumpContext *md_context = md_thread->GetContext();
   ASSERT_TRUE(md_context != NULL);
-  ASSERT_EQ((u_int32_t) MD_CONTEXT_X86, md_context->GetContextCPU());
+  ASSERT_EQ((uint32_t) MD_CONTEXT_X86, md_context->GetContextCPU());
 
-  u_int64_t eip;
+  uint64_t eip;
   ASSERT_TRUE(md_context->GetInstructionPointer(&eip));
   EXPECT_EQ(kExpectedEIP, eip);
 
   const MDRawContextX86 *md_raw_context = md_context->GetContextX86();
   ASSERT_TRUE(md_raw_context != NULL);
-  ASSERT_EQ((u_int32_t) (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL),
+  ASSERT_EQ((uint32_t) (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL),
             (md_raw_context->context_flags
              & (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL)));
   EXPECT_EQ(0x3ecba80dU, raw_context.edi);
   EXPECT_EQ(0x382583b9U, raw_context.esi);
   EXPECT_EQ(0x7fccc03fU, raw_context.ebx);
   EXPECT_EQ(0xf62f8ec2U, raw_context.edx);
   EXPECT_EQ(0x46a6a6a8U, raw_context.ecx);
   EXPECT_EQ(0x6a5025e2U, raw_context.eax);
@@ -327,17 +327,17 @@
   // This should succeed even though the thread has no stack memory.
   MinidumpThreadList* thread_list = minidump.GetThreadList();
   ASSERT_TRUE(thread_list != NULL);
   ASSERT_EQ(1U, thread_list->thread_count());
 
   MinidumpThread* md_thread = thread_list->GetThreadAtIndex(0);
   ASSERT_TRUE(md_thread != NULL);
 
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(md_thread->GetThreadID(&thread_id));
   ASSERT_EQ(0xa898f11bU, thread_id);
 
   MinidumpContext* md_context = md_thread->GetContext();
   ASSERT_NE(reinterpret_cast<MinidumpContext*>(NULL), md_context);
 
   MinidumpMemoryRegion* md_stack = md_thread->GetMemory();
   ASSERT_EQ(reinterpret_cast<MinidumpMemoryRegion*>(NULL), md_stack);
@@ -370,17 +370,17 @@
   // This should succeed even though the thread has no stack memory.
   MinidumpThreadList* thread_list = minidump.GetThreadList();
   ASSERT_TRUE(thread_list != NULL);
   ASSERT_EQ(1U, thread_list->thread_count());
 
   MinidumpThread* md_thread = thread_list->GetThreadAtIndex(0);
   ASSERT_TRUE(md_thread != NULL);
 
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(md_thread->GetThreadID(&thread_id));
   ASSERT_EQ(0xa898f11bU, thread_id);
   MinidumpMemoryRegion* md_stack = md_thread->GetMemory();
   ASSERT_NE(reinterpret_cast<MinidumpMemoryRegion*>(NULL), md_stack);
 
   MinidumpContext* md_context = md_thread->GetContext();
   ASSERT_EQ(reinterpret_cast<MinidumpContext*>(NULL), md_context);
 }
@@ -419,17 +419,17 @@
   ASSERT_TRUE(dump.GetContents(&contents));
   istringstream minidump_stream(contents);
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());
 
   const MDRawDirectory *dir = minidump.GetDirectoryEntryAtIndex(0);
   ASSERT_TRUE(dir != NULL);
-  EXPECT_EQ((u_int32_t) MD_MODULE_LIST_STREAM, dir->stream_type);
+  EXPECT_EQ((uint32_t) MD_MODULE_LIST_STREAM, dir->stream_type);
 
   MinidumpModuleList *md_module_list = minidump.GetModuleList();
   ASSERT_TRUE(md_module_list != NULL);
   ASSERT_EQ(1U, md_module_list->module_count());
 
   const MinidumpModule *md_module = md_module_list->GetModuleAtIndex(0);
   ASSERT_TRUE(md_module != NULL);
   ASSERT_EQ(0xa90206ca83eb2852ULL, md_module->base_address());
@@ -457,17 +457,17 @@
   ASSERT_TRUE(dump.GetContents(&contents));
   istringstream minidump_stream(contents);
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());
 
   const MDRawDirectory *dir = minidump.GetDirectoryEntryAtIndex(0);
   ASSERT_TRUE(dir != NULL);
-  EXPECT_EQ((u_int32_t) MD_SYSTEM_INFO_STREAM, dir->stream_type);
+  EXPECT_EQ((uint32_t) MD_SYSTEM_INFO_STREAM, dir->stream_type);
 
   MinidumpSystemInfo *md_system_info = minidump.GetSystemInfo();
   ASSERT_TRUE(md_system_info != NULL);
   ASSERT_EQ("windows", md_system_info->GetOS());
   ASSERT_EQ("x86", md_system_info->GetCPU());
   ASSERT_EQ("Petulant Pierogi", *md_system_info->GetCSDVersion());
   ASSERT_EQ("GenuineIntel", *md_system_info->GetCPUVendor());
 }
@@ -571,17 +571,17 @@
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(4U, minidump.GetDirectoryEntryCount());
 
   // Check the threads.
   MinidumpThreadList *thread_list = minidump.GetThreadList();
   ASSERT_TRUE(thread_list != NULL);
   ASSERT_EQ(5U, thread_list->thread_count());
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(thread_list->GetThreadAtIndex(0)->GetThreadID(&thread_id));
   ASSERT_EQ(0xbbef4432U, thread_id);
   ASSERT_EQ(0x70b9ebfcU,
             thread_list->GetThreadAtIndex(0)->GetMemory()->GetBase());
   ASSERT_EQ(0xaf0709e4U,
             thread_list->GetThreadAtIndex(0)->GetContext()->GetContextX86()
             ->eip);
 
@@ -629,25 +629,25 @@
             md_module_list->GetModuleAtIndex(2)->base_address());
 }
 
 TEST(Dump, OneMemoryInfo) {
   Dump dump(0, kBigEndian);
   Stream stream(dump, MD_MEMORY_INFO_LIST_STREAM);
 
   // Add the MDRawMemoryInfoList header.
-  const u_int64_t kNumberOfEntries = 1;
+  const uint64_t kNumberOfEntries = 1;
   stream.D32(sizeof(MDRawMemoryInfoList))  // size_of_header
         .D32(sizeof(MDRawMemoryInfo))      // size_of_entry
         .D64(kNumberOfEntries);            // number_of_entries
 
   
   // Now add a MDRawMemoryInfo entry.
-  const u_int64_t kBaseAddress = 0x1000;
-  const u_int64_t kRegionSize = 0x2000;
+  const uint64_t kBaseAddress = 0x1000;
+  const uint64_t kRegionSize = 0x2000;
   stream.D64(kBaseAddress)                         // base_address
         .D64(kBaseAddress)                         // allocation_base
         .D32(MD_MEMORY_PROTECT_EXECUTE_READWRITE)  // allocation_protection
         .D32(0)                                    // __alignment1
         .D64(kRegionSize)                          // region_size
         .D32(MD_MEMORY_STATE_COMMIT)               // state
         .D32(MD_MEMORY_PROTECT_EXECUTE_READWRITE)  // protection
         .D32(MD_MEMORY_TYPE_PRIVATE)               // type
@@ -660,17 +660,17 @@
   ASSERT_TRUE(dump.GetContents(&contents));
   istringstream minidump_stream(contents);
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());
 
   const MDRawDirectory *dir = minidump.GetDirectoryEntryAtIndex(0);
   ASSERT_TRUE(dir != NULL);
-  EXPECT_EQ((u_int32_t) MD_MEMORY_INFO_LIST_STREAM, dir->stream_type);
+  EXPECT_EQ((uint32_t) MD_MEMORY_INFO_LIST_STREAM, dir->stream_type);
 
   MinidumpMemoryInfoList *info_list = minidump.GetMemoryInfoList();
   ASSERT_TRUE(info_list != NULL);
   ASSERT_EQ(1U, info_list->info_count());
 
   const MinidumpMemoryInfo *info1 = info_list->GetMemoryInfoAtIndex(0);
   ASSERT_EQ(kBaseAddress, info1->GetBase());
   ASSERT_EQ(kRegionSize, info1->GetSize());
@@ -719,33 +719,33 @@
   istringstream minidump_stream(contents);
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());
 
   MinidumpException *md_exception = minidump.GetException();
   ASSERT_TRUE(md_exception != NULL);
 
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(md_exception->GetThreadID(&thread_id));
   ASSERT_EQ(0x1234abcdU, thread_id);
 
   const MDRawExceptionStream* raw_exception = md_exception->exception();
   ASSERT_TRUE(raw_exception != NULL);
   EXPECT_EQ(0xdcba4321, raw_exception->exception_record.exception_code);
   EXPECT_EQ(0xf0e0d0c0, raw_exception->exception_record.exception_flags);
   EXPECT_EQ(0x0919a9b9c9d9e9f9ULL,
             raw_exception->exception_record.exception_address);
 
   MinidumpContext *md_context = md_exception->GetContext();
   ASSERT_TRUE(md_context != NULL);
-  ASSERT_EQ((u_int32_t) MD_CONTEXT_X86, md_context->GetContextCPU());
+  ASSERT_EQ((uint32_t) MD_CONTEXT_X86, md_context->GetContextCPU());
   const MDRawContextX86 *md_raw_context = md_context->GetContextX86();
   ASSERT_TRUE(md_raw_context != NULL);
-  ASSERT_EQ((u_int32_t) (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL),
+  ASSERT_EQ((uint32_t) (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL),
             (md_raw_context->context_flags
              & (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL)));
   EXPECT_EQ(0x3ecba80dU, raw_context.edi);
   EXPECT_EQ(0x382583b9U, raw_context.esi);
   EXPECT_EQ(0x7fccc03fU, raw_context.ebx);
   EXPECT_EQ(0xf62f8ec2U, raw_context.edx);
   EXPECT_EQ(0x46a6a6a8U, raw_context.ecx);
   EXPECT_EQ(0x6a5025e2U, raw_context.eax);
@@ -793,33 +793,33 @@
   istringstream minidump_stream(contents);
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());
 
   MinidumpException *md_exception = minidump.GetException();
   ASSERT_TRUE(md_exception != NULL);
 
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(md_exception->GetThreadID(&thread_id));
   ASSERT_EQ(0x1234abcdU, thread_id);
 
   const MDRawExceptionStream* raw_exception = md_exception->exception();
   ASSERT_TRUE(raw_exception != NULL);
   EXPECT_EQ(0xdcba4321, raw_exception->exception_record.exception_code);
   EXPECT_EQ(0xf0e0d0c0, raw_exception->exception_record.exception_flags);
   EXPECT_EQ(0x0919a9b9c9d9e9f9ULL,
             raw_exception->exception_record.exception_address);
 
   MinidumpContext *md_context = md_exception->GetContext();
   ASSERT_TRUE(md_context != NULL);
-  ASSERT_EQ((u_int32_t) MD_CONTEXT_X86, md_context->GetContextCPU());
+  ASSERT_EQ((uint32_t) MD_CONTEXT_X86, md_context->GetContextCPU());
   const MDRawContextX86 *md_raw_context = md_context->GetContextX86();
   ASSERT_TRUE(md_raw_context != NULL);
-  ASSERT_EQ((u_int32_t) (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL),
+  ASSERT_EQ((uint32_t) (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL),
             (md_raw_context->context_flags
              & (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL)));
   EXPECT_EQ(0x3ecba80dU, raw_context.edi);
   EXPECT_EQ(0x382583b9U, raw_context.esi);
   EXPECT_EQ(0x7fccc03fU, raw_context.ebx);
   EXPECT_EQ(0xf62f8ec2U, raw_context.edx);
   EXPECT_EQ(0x46a6a6a8U, raw_context.ecx);
   EXPECT_EQ(0x6a5025e2U, raw_context.eax);
@@ -878,38 +878,38 @@
   istringstream minidump_stream(contents);
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(2U, minidump.GetDirectoryEntryCount());
 
   MinidumpException *md_exception = minidump.GetException();
   ASSERT_TRUE(md_exception != NULL);
 
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(md_exception->GetThreadID(&thread_id));
   ASSERT_EQ(0x1234abcdU, thread_id);
 
   const MDRawExceptionStream* raw_exception = md_exception->exception();
   ASSERT_TRUE(raw_exception != NULL);
   EXPECT_EQ(0xdcba4321, raw_exception->exception_record.exception_code);
   EXPECT_EQ(0xf0e0d0c0, raw_exception->exception_record.exception_flags);
   EXPECT_EQ(0x0919a9b9c9d9e9f9ULL,
             raw_exception->exception_record.exception_address);
 
   MinidumpContext *md_context = md_exception->GetContext();
   ASSERT_TRUE(md_context != NULL);
 
-  ASSERT_EQ((u_int32_t) MD_CONTEXT_X86, md_context->GetContextCPU());
+  ASSERT_EQ((uint32_t) MD_CONTEXT_X86, md_context->GetContextCPU());
   const MDRawContextX86 *md_raw_context = md_context->GetContextX86();
   ASSERT_TRUE(md_raw_context != NULL);
 
   // Even though the CPU flags were missing from the context_flags, the
   // GetContext call above is expected to load the missing CPU flags from the
   // system info stream and set the CPU type bits in context_flags.
-  ASSERT_EQ((u_int32_t) (MD_CONTEXT_X86), md_raw_context->context_flags);
+  ASSERT_EQ((uint32_t) (MD_CONTEXT_X86), md_raw_context->context_flags);
 
   EXPECT_EQ(0x3ecba80dU, raw_context.edi);
   EXPECT_EQ(0x382583b9U, raw_context.esi);
   EXPECT_EQ(0x7fccc03fU, raw_context.ebx);
   EXPECT_EQ(0xf62f8ec2U, raw_context.edx);
   EXPECT_EQ(0x46a6a6a8U, raw_context.ecx);
   EXPECT_EQ(0x6a5025e2U, raw_context.eax);
   EXPECT_EQ(0xd9fabb4aU, raw_context.ebp);
@@ -960,17 +960,17 @@
   istringstream minidump_stream(contents);
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());
 
   MinidumpException *md_exception = minidump.GetException();
   ASSERT_TRUE(md_exception != NULL);
 
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(md_exception->GetThreadID(&thread_id));
   ASSERT_EQ(0x1234abcdU, thread_id);
 
   const MDRawExceptionStream* raw_exception = md_exception->exception();
   ASSERT_TRUE(raw_exception != NULL);
   EXPECT_EQ(0xdcba4321, raw_exception->exception_record.exception_code);
   EXPECT_EQ(0xf0e0d0c0, raw_exception->exception_record.exception_flags);
   EXPECT_EQ(0x0919a9b9c9d9e9f9ULL,
@@ -1023,33 +1023,33 @@
   istringstream minidump_stream(contents);
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());
 
   MinidumpException *md_exception = minidump.GetException();
   ASSERT_TRUE(md_exception != NULL);
 
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(md_exception->GetThreadID(&thread_id));
   ASSERT_EQ(0x1234abcdU, thread_id);
 
   const MDRawExceptionStream* raw_exception = md_exception->exception();
   ASSERT_TRUE(raw_exception != NULL);
   EXPECT_EQ(0xdcba4321, raw_exception->exception_record.exception_code);
   EXPECT_EQ(0xf0e0d0c0, raw_exception->exception_record.exception_flags);
   EXPECT_EQ(0x0919a9b9c9d9e9f9ULL,
             raw_exception->exception_record.exception_address);
 
   MinidumpContext *md_context = md_exception->GetContext();
   ASSERT_TRUE(md_context != NULL);
-  ASSERT_EQ((u_int32_t) MD_CONTEXT_ARM, md_context->GetContextCPU());
+  ASSERT_EQ((uint32_t) MD_CONTEXT_ARM, md_context->GetContextCPU());
   const MDRawContextARM *md_raw_context = md_context->GetContextARM();
   ASSERT_TRUE(md_raw_context != NULL);
-  ASSERT_EQ((u_int32_t) MD_CONTEXT_ARM_INTEGER,
+  ASSERT_EQ((uint32_t) MD_CONTEXT_ARM_INTEGER,
             (md_raw_context->context_flags
              & MD_CONTEXT_ARM_INTEGER));
   EXPECT_EQ(0x3ecba80dU, raw_context.iregs[0]);
   EXPECT_EQ(0x382583b9U, raw_context.iregs[1]);
   EXPECT_EQ(0x7fccc03fU, raw_context.iregs[2]);
   EXPECT_EQ(0xf62f8ec2U, raw_context.iregs[3]);
   EXPECT_EQ(0x46a6a6a8U, raw_context.iregs[4]);
   EXPECT_EQ(0x6a5025e2U, raw_context.iregs[5]);
@@ -1107,33 +1107,33 @@
   istringstream minidump_stream(contents);
   Minidump minidump(minidump_stream);
   ASSERT_TRUE(minidump.Read());
   ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());
 
   MinidumpException *md_exception = minidump.GetException();
   ASSERT_TRUE(md_exception != NULL);
 
-  u_int32_t thread_id;
+  uint32_t thread_id;
   ASSERT_TRUE(md_exception->GetThreadID(&thread_id));
   ASSERT_EQ(0x1234abcdU, thread_id);
 
   const MDRawExceptionStream* raw_exception = md_exception->exception();
   ASSERT_TRUE(raw_exception != NULL);
   EXPECT_EQ(0xdcba4321, raw_exception->exception_record.exception_code);
   EXPECT_EQ(0xf0e0d0c0, raw_exception->exception_record.exception_flags);
   EXPECT_EQ(0x0919a9b9c9d9e9f9ULL,
             raw_exception->exception_record.exception_address);
 
   MinidumpContext *md_context = md_exception->GetContext();
   ASSERT_TRUE(md_context != NULL);
-  ASSERT_EQ((u_int32_t) MD_CONTEXT_ARM, md_context->GetContextCPU());
+  ASSERT_EQ((uint32_t) MD_CONTEXT_ARM, md_context->GetContextCPU());
   const MDRawContextARM *md_raw_context = md_context->GetContextARM();
   ASSERT_TRUE(md_raw_context != NULL);
-  ASSERT_EQ((u_int32_t) MD_CONTEXT_ARM_INTEGER,
+  ASSERT_EQ((uint32_t) MD_CONTEXT_ARM_INTEGER,
             (md_raw_context->context_flags
              & MD_CONTEXT_ARM_INTEGER));
   EXPECT_EQ(0x3ecba80dU, raw_context.iregs[0]);
   EXPECT_EQ(0x382583b9U, raw_context.iregs[1]);
   EXPECT_EQ(0x7fccc03fU, raw_context.iregs[2]);
   EXPECT_EQ(0xf62f8ec2U, raw_context.iregs[3]);
   EXPECT_EQ(0x46a6a6a8U, raw_context.iregs[4]);
   EXPECT_EQ(0x6a5025e2U, raw_context.iregs[5]);
diff --git a/src/processor/module_serializer.cc b/src/processor/module_serializer.cc
--- a/src/processor/module_serializer.cc
+++ b/src/processor/module_serializer.cc
@@ -60,32 +60,32 @@
    map_sizes_[map_index++] =
        wfi_serializer_.SizeOf(&(module.windows_frame_info_[i]));
   map_sizes_[map_index++] = cfi_init_rules_serializer_.SizeOf(
      module.cfi_initial_rules_);
   map_sizes_[map_index++] = cfi_delta_rules_serializer_.SizeOf(
      module.cfi_delta_rules_);
 
   // Header size.
-  total_size_alloc_ = kNumberMaps_ * sizeof(u_int32_t);
+  total_size_alloc_ = kNumberMaps_ * sizeof(uint32_t);
 
   for (int i = 0; i < kNumberMaps_; ++i)
    total_size_alloc_ += map_sizes_[i];
 
   // Extra one byte for null terminator for C-string copy safety.
   ++total_size_alloc_;
 
   return total_size_alloc_;
 }
 
 char *ModuleSerializer::Write(const BasicSourceLineResolver::Module &module,
                               char *dest) {
   // Write header.
-  memcpy(dest, map_sizes_, kNumberMaps_ * sizeof(u_int32_t));
-  dest += kNumberMaps_ * sizeof(u_int32_t);
+  memcpy(dest, map_sizes_, kNumberMaps_ * sizeof(uint32_t));
+  dest += kNumberMaps_ * sizeof(uint32_t);
   // Write each map.
   dest = files_serializer_.Write(module.files_, dest);
   dest = functions_serializer_.Write(module.functions_, dest);
   dest = pubsym_serializer_.Write(module.public_symbols_, dest);
   for (int i = 0; i < WindowsFrameInfo::STACK_INFO_LAST; ++i)
     dest = wfi_serializer_.Write(&(module.windows_frame_info_[i]), dest);
   dest = cfi_init_rules_serializer_.Write(module.cfi_initial_rules_, dest);
   dest = cfi_delta_rules_serializer_.Write(module.cfi_delta_rules_, dest);
diff --git a/src/processor/module_serializer.h b/src/processor/module_serializer.h
--- a/src/processor/module_serializer.h
+++ b/src/processor/module_serializer.h
@@ -105,17 +105,17 @@
       const BasicSourceLineResolver::ModuleMap::const_iterator &iter,
       FastSourceLineResolver *fast_resolver);
 
   // Number of Maps that Module class contains.
   static const int32_t kNumberMaps_ =
       FastSourceLineResolver::Module::kNumberMaps_;
 
   // Memory sizes required to serialize map components in Module.
-  u_int32_t map_sizes_[kNumberMaps_];
+  uint32_t map_sizes_[kNumberMaps_];
 
   // Serializers for each individual map component in Module class.
   StdMapSerializer<int, string> files_serializer_;
   RangeMapSerializer<MemAddr, linked_ptr<Function> > functions_serializer_;
   AddressMapSerializer<MemAddr, linked_ptr<PublicSymbol> > pubsym_serializer_;
   ContainedRangeMapSerializer<MemAddr,
                               linked_ptr<WindowsFrameInfo> > wfi_serializer_;
   RangeMapSerializer<MemAddr, string> cfi_init_rules_serializer_;
diff --git a/src/processor/postfix_evaluator_unittest.cc b/src/processor/postfix_evaluator_unittest.cc
--- a/src/processor/postfix_evaluator_unittest.cc
+++ b/src/processor/postfix_evaluator_unittest.cc
@@ -52,31 +52,31 @@
 using google_breakpad::PostfixEvaluator;
 
 
 // FakeMemoryRegion is used to test PostfixEvaluator's dereference (^)
 // operator.  The result of dereferencing a value is one greater than
 // the value.
 class FakeMemoryRegion : public MemoryRegion {
  public:
-  virtual u_int64_t GetBase() const { return 0; }
-  virtual u_int32_t GetSize() const { return 0; }
-  virtual bool GetMemoryAtAddress(u_int64_t address, u_int8_t  *value) const {
+  virtual uint64_t GetBase() const { return 0; }
+  virtual uint32_t GetSize() const { return 0; }
+  virtual bool GetMemoryAtAddress(uint64_t address, uint8_t  *value) const {
     *value = address + 1;
     return true;
   }
-  virtual bool GetMemoryAtAddress(u_int64_t address, u_int16_t *value) const {
+  virtual bool GetMemoryAtAddress(uint64_t address, uint16_t *value) const {
     *value = address + 1;
     return true;
   }
-  virtual bool GetMemoryAtAddress(u_int64_t address, u_int32_t *value) const {
+  virtual bool GetMemoryAtAddress(uint64_t address, uint32_t *value) const {
     *value = address + 1;
     return true;
   }
-  virtual bool GetMemoryAtAddress(u_int64_t address, u_int64_t *value) const {
+  virtual bool GetMemoryAtAddress(uint64_t address, uint64_t *value) const {
     *value = address + 1;
     return true;
   }
 };
 
 
 struct EvaluateTest {
   // Expression passed to PostfixEvaluator::Evaluate.
diff --git a/src/processor/simple_serializer-inl.h b/src/processor/simple_serializer-inl.h
--- a/src/processor/simple_serializer-inl.h
+++ b/src/processor/simple_serializer-inl.h
@@ -129,36 +129,36 @@
 // Specializations of SimpleSerializer: WindowsFrameInfo
 template<>
 class SimpleSerializer<WindowsFrameInfo> {
  public:
   static size_t SizeOf(const WindowsFrameInfo &wfi) {
     unsigned int size = 0;
     size += sizeof(int32_t);  // wfi.type_
     size += SimpleSerializer<int32_t>::SizeOf(wfi.valid);
-    size += SimpleSerializer<u_int32_t>::SizeOf(wfi.prolog_size);
-    size += SimpleSerializer<u_int32_t>::SizeOf(wfi.epilog_size);
-    size += SimpleSerializer<u_int32_t>::SizeOf(wfi.parameter_size);
-    size += SimpleSerializer<u_int32_t>::SizeOf(wfi.saved_register_size);
-    size += SimpleSerializer<u_int32_t>::SizeOf(wfi.local_size);
-    size += SimpleSerializer<u_int32_t>::SizeOf(wfi.max_stack_size);
+    size += SimpleSerializer<uint32_t>::SizeOf(wfi.prolog_size);
+    size += SimpleSerializer<uint32_t>::SizeOf(wfi.epilog_size);
+    size += SimpleSerializer<uint32_t>::SizeOf(wfi.parameter_size);
+    size += SimpleSerializer<uint32_t>::SizeOf(wfi.saved_register_size);
+    size += SimpleSerializer<uint32_t>::SizeOf(wfi.local_size);
+    size += SimpleSerializer<uint32_t>::SizeOf(wfi.max_stack_size);
     size += SimpleSerializer<bool>::SizeOf(wfi.allocates_base_pointer);
     size += SimpleSerializer<string>::SizeOf(wfi.program_string);
     return size;
   }
   static char *Write(const WindowsFrameInfo &wfi, char *dest) {
     dest = SimpleSerializer<int32_t>::Write(
         static_cast<const int32_t>(wfi.type_), dest);
     dest = SimpleSerializer<int32_t>::Write(wfi.valid, dest);
-    dest = SimpleSerializer<u_int32_t>::Write(wfi.prolog_size, dest);
-    dest = SimpleSerializer<u_int32_t>::Write(wfi.epilog_size, dest);
-    dest = SimpleSerializer<u_int32_t>::Write(wfi.parameter_size, dest);
-    dest = SimpleSerializer<u_int32_t>::Write(wfi.saved_register_size, dest);
-    dest = SimpleSerializer<u_int32_t>::Write(wfi.local_size, dest);
-    dest = SimpleSerializer<u_int32_t>::Write(wfi.max_stack_size, dest);
+    dest = SimpleSerializer<uint32_t>::Write(wfi.prolog_size, dest);
+    dest = SimpleSerializer<uint32_t>::Write(wfi.epilog_size, dest);
+    dest = SimpleSerializer<uint32_t>::Write(wfi.parameter_size, dest);
+    dest = SimpleSerializer<uint32_t>::Write(wfi.saved_register_size, dest);
+    dest = SimpleSerializer<uint32_t>::Write(wfi.local_size, dest);
+    dest = SimpleSerializer<uint32_t>::Write(wfi.max_stack_size, dest);
     dest = SimpleSerializer<bool>::Write(wfi.allocates_base_pointer, dest);
     return SimpleSerializer<string>::Write(wfi.program_string, dest);
   }
 };
 
 // Specializations of SimpleSerializer: Linked_ptr version of
 // Line, Function, PublicSymbol, WindowsFrameInfo.
 template<>
diff --git a/src/processor/simple_serializer.h b/src/processor/simple_serializer.h
--- a/src/processor/simple_serializer.h
+++ b/src/processor/simple_serializer.h
@@ -33,21 +33,21 @@
 // All specializations of SimpleSerializer template are defined in the
 // "simple_serializer-inl.h" file.
 //
 // Author: Siyang Xie (lambxsy@google.com)
 
 #ifndef PROCESSOR_SIMPLE_SERIALIZER_H__
 #define PROCESSOR_SIMPLE_SERIALIZER_H__
 
-#include <sys/types.h>
+#include "google_breakpad/common/breakpad_types.h"
 
 namespace google_breakpad {
 
-typedef u_int64_t MemAddr;
+typedef uint64_t MemAddr;
 
 // Default implementation of SimpleSerializer template.
 // Specializations are defined in "simple_serializer-inl.h".
 template<class Type> class SimpleSerializer {
  public:
   // Calculate and return the size of the 'item'.
   static size_t SizeOf(const Type &item) { return sizeof(item); }
   // Write 'item' to memory location 'dest', and return to the "end" address of
diff --git a/src/processor/stackwalker.cc b/src/processor/stackwalker.cc
--- a/src/processor/stackwalker.cc
+++ b/src/processor/stackwalker.cc
@@ -51,17 +51,17 @@
 #include "processor/stackwalker_sparc.h"
 #include "processor/stackwalker_x86.h"
 #include "processor/stackwalker_amd64.h"
 #include "processor/stackwalker_arm.h"
 
 namespace google_breakpad {
 
 const int Stackwalker::kRASearchWords = 30;
-u_int32_t Stackwalker::max_frames_ = 1024;
+uint32_t Stackwalker::max_frames_ = 1024;
 
 Stackwalker::Stackwalker(const SystemInfo* system_info,
                          MemoryRegion* memory,
                          const CodeModules* modules,
                          StackFrameSymbolizer* frame_symbolizer)
     : system_info_(system_info),
       memory_(memory),
       modules_(modules),
@@ -120,17 +120,17 @@
     StackFrameSymbolizer* frame_symbolizer) {
   if (!context) {
     BPLOG(ERROR) << "Can't choose a stackwalker implementation without context";
     return NULL;
   }
 
   Stackwalker* cpu_stackwalker = NULL;
 
-  u_int32_t cpu = context->GetContextCPU();
+  uint32_t cpu = context->GetContextCPU();
   switch (cpu) {
     case MD_CONTEXT_X86:
       cpu_stackwalker = new StackwalkerX86(system_info,
                                            context->GetContextX86(),
                                            memory, modules, frame_symbolizer);
       break;
 
     case MD_CONTEXT_PPC:
@@ -163,17 +163,17 @@
   }
 
   BPLOG_IF(ERROR, !cpu_stackwalker) << "Unknown CPU type " << HexString(cpu) <<
                                        ", can't choose a stackwalker "
                                        "implementation";
   return cpu_stackwalker;
 }
 
-bool Stackwalker::InstructionAddressSeemsValid(u_int64_t address) {
+bool Stackwalker::InstructionAddressSeemsValid(uint64_t address) {
   StackFrame frame;
   frame.instruction = address;
   StackFrameSymbolizer::SymbolizerResult symbolizer_result =
       frame_symbolizer_->FillSourceLineInfo(modules_, system_info_, &frame);
 
   if (!frame.module) {
     // not inside any loaded module
     return false;
diff --git a/src/processor/stackwalker_amd64.cc b/src/processor/stackwalker_amd64.cc
--- a/src/processor/stackwalker_amd64.cc
+++ b/src/processor/stackwalker_amd64.cc
@@ -96,17 +96,17 @@
                                    const CodeModules* modules,
                                    StackFrameSymbolizer* resolver_helper)
     : Stackwalker(system_info, memory, modules, resolver_helper),
       context_(context),
       cfi_walker_(cfi_register_map_,
                   (sizeof(cfi_register_map_) / sizeof(cfi_register_map_[0]))) {
 }
 
-u_int64_t StackFrameAMD64::ReturnAddress() const
+uint64_t StackFrameAMD64::ReturnAddress() const
 {
   assert(context_validity & StackFrameAMD64::CONTEXT_VALID_RIP);
   return context.rip;   
 }
 
 StackFrame* StackwalkerAMD64::GetContextFrame() {
   if (!context_) {
     BPLOG(ERROR) << "Can't get context frame without context";
@@ -145,18 +145,18 @@
 
   frame->trust = StackFrame::FRAME_TRUST_CFI;
   return frame.release();
 }
 
 StackFrameAMD64* StackwalkerAMD64::GetCallerByStackScan(
     const vector<StackFrame*> &frames) {
   StackFrameAMD64* last_frame = static_cast<StackFrameAMD64*>(frames.back());
-  u_int64_t last_rsp = last_frame->context.rsp;
-  u_int64_t caller_rip_address, caller_rip;
+  uint64_t last_rsp = last_frame->context.rsp;
+  uint64_t caller_rip_address, caller_rip;
 
   if (!ScanForReturnAddress(last_rsp, &caller_rip_address, &caller_rip)) {
     // No plausible return address was found.
     return NULL;
   }
 
   // Create a new stack frame (ownership will be transferred to the caller)
   // and fill it in.
@@ -174,17 +174,17 @@
   // Other unwinders give up if they don't have an %rbp value, so see if we
   // can pass some plausible value on.
   if (last_frame->context_validity & StackFrameAMD64::CONTEXT_VALID_RBP) {
     // Functions typically push their caller's %rbp immediately upon entry,
     // and then set %rbp to point to that. So if the callee's %rbp is
     // pointing to the first word below the alleged return address, presume
     // that the caller's %rbp is saved there.
     if (caller_rip_address - 8 == last_frame->context.rbp) {
-      u_int64_t caller_rbp = 0;
+      uint64_t caller_rbp = 0;
       if (memory_->GetMemoryAtAddress(last_frame->context.rbp, &caller_rbp) &&
           caller_rbp > caller_rip_address) {
         frame->context.rbp = caller_rbp;
         frame->context_validity |= StackFrameAMD64::CONTEXT_VALID_RBP;
       }
     } else if (last_frame->context.rbp >= caller_rip_address + 8) {
       // If the callee's %rbp is plausible as a value for the caller's
       // %rbp, presume that the callee left it unchanged.
diff --git a/src/processor/stackwalker_amd64.h b/src/processor/stackwalker_amd64.h
--- a/src/processor/stackwalker_amd64.h
+++ b/src/processor/stackwalker_amd64.h
@@ -59,17 +59,17 @@
   StackwalkerAMD64(const SystemInfo* system_info,
                    const MDRawContextAMD64* context,
                    MemoryRegion* memory,
                    const CodeModules* modules,
                    StackFrameSymbolizer* frame_symbolizer);
 
  private:
   // A STACK CFI-driven frame walker for the AMD64
-  typedef SimpleCFIWalker<u_int64_t, MDRawContextAMD64> CFIWalker;
+  typedef SimpleCFIWalker<uint64_t, MDRawContextAMD64> CFIWalker;
 
   // Implementation of Stackwalker, using amd64 context (stack pointer in %rsp,
   // stack base in %rbp) and stack conventions (saved stack pointer at 0(%rbp))
   virtual StackFrame* GetContextFrame();
   virtual StackFrame* GetCallerFrame(const CallStack* stack);
 
   // Use cfi_frame_info (derived from STACK CFI records) to construct
   // the frame that called frames.back(). The caller takes ownership
diff --git a/src/processor/stackwalker_amd64_unittest.cc b/src/processor/stackwalker_amd64_unittest.cc
--- a/src/processor/stackwalker_amd64_unittest.cc
+++ b/src/processor/stackwalker_amd64_unittest.cc
@@ -104,19 +104,19 @@
   void RegionFromSection() {
     string contents;
     ASSERT_TRUE(stack_section.GetContents(&contents));
     stack_region.Init(stack_section.start().Value(), contents);
   }
 
   // Fill RAW_CONTEXT with pseudo-random data, for round-trip checking.
   void BrandContext(MDRawContextAMD64 *raw_context) {
-    u_int8_t x = 173;
+    uint8_t x = 173;
     for (size_t i = 0; i < sizeof(*raw_context); i++)
-      reinterpret_cast<u_int8_t *>(raw_context)[i] = (x += 17);
+      reinterpret_cast<uint8_t *>(raw_context)[i] = (x += 17);
   }
 
   SystemInfo system_info;
   MDRawContextAMD64 raw_context;
   Section stack_section;
   MockMemoryRegion stack_region;
   MockCodeModule module1;
   MockCodeModule module2;
@@ -194,18 +194,18 @@
 
 TEST_F(GetCallerFrame, ScanWithoutSymbols) {
   // When the stack walker resorts to scanning the stack,
   // only addresses located within loaded modules are
   // considered valid return addresses.
   // Force scanning through three frames to ensure that the
   // stack pointer is set properly in scan-recovered frames.
   stack_section.start() = 0x8000000080000000ULL;
-  u_int64_t return_address1 = 0x50000000b0000100ULL;
-  u_int64_t return_address2 = 0x50000000b0000900ULL;
+  uint64_t return_address1 = 0x50000000b0000100ULL;
+  uint64_t return_address2 = 0x50000000b0000900ULL;
   Label frame1_sp, frame2_sp, frame1_rbp;
   stack_section
     // frame 0
     .Append(16, 0)                      // space
 
     .D64(0x40000000b0000000ULL)         // junk that's not
     .D64(0x50000000d0000000ULL)         // a return address
 
@@ -265,17 +265,17 @@
 }
 
 TEST_F(GetCallerFrame, ScanWithFunctionSymbols) {
   // During stack scanning, if a potential return address
   // is located within a loaded module that has symbols,
   // it is only considered a valid return address if it
   // lies within a function's bounds.
   stack_section.start() = 0x8000000080000000ULL;
-  u_int64_t return_address = 0x50000000b0000110ULL;
+  uint64_t return_address = 0x50000000b0000110ULL;
   Label frame1_sp, frame1_rbp;
 
   stack_section
     // frame 0
     .Append(16, 0)                      // space
 
     .D64(0x40000000b0000000ULL)         // junk that's not
     .D64(0x50000000b0000000ULL)         // a return address
@@ -328,17 +328,17 @@
 }
 
 TEST_F(GetCallerFrame, CallerPushedRBP) {
   // Functions typically push their %rbp upon entry and set %rbp pointing
   // there.  If stackwalking finds a plausible address for the next frame's
   // %rbp directly below the return address, assume that it is indeed the
   // next frame's %rbp.
   stack_section.start() = 0x8000000080000000ULL;
-  u_int64_t return_address = 0x50000000b0000110ULL;
+  uint64_t return_address = 0x50000000b0000110ULL;
   Label frame0_rbp, frame1_sp, frame1_rbp;
 
   stack_section
     // frame 0
     .Append(16, 0)                      // space
 
     .D64(0x40000000b0000000ULL)         // junk that's not
     .D64(0x50000000b0000000ULL)         // a return address
diff --git a/src/processor/stackwalker_arm.cc b/src/processor/stackwalker_arm.cc
--- a/src/processor/stackwalker_arm.cc
+++ b/src/processor/stackwalker_arm.cc
@@ -85,31 +85,31 @@
     "r0",  "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
     "r8",  "r9",  "r10", "r11", "r12", "sp",  "lr",  "pc",
     "f0",  "f1",  "f2",  "f3",  "f4",  "f5",  "f6",  "f7",
     "fps", "cpsr",
     NULL
   };
 
   // Populate a dictionary with the valid register values in last_frame.
-  CFIFrameInfo::RegisterValueMap<u_int32_t> callee_registers;
+  CFIFrameInfo::RegisterValueMap<uint32_t> callee_registers;
   for (int i = 0; register_names[i]; i++)
     if (last_frame->context_validity & StackFrameARM::RegisterValidFlag(i))
       callee_registers[register_names[i]] = last_frame->context.iregs[i];
 
   // Use the STACK CFI data to recover the caller's register values.
-  CFIFrameInfo::RegisterValueMap<u_int32_t> caller_registers;
+  CFIFrameInfo::RegisterValueMap<uint32_t> caller_registers;
   if (!cfi_frame_info->FindCallerRegs(callee_registers, *memory_,
                                       &caller_registers))
     return NULL;
 
   // Construct a new stack frame given the values the CFI recovered.
   scoped_ptr<StackFrameARM> frame(new StackFrameARM());
   for (int i = 0; register_names[i]; i++) {
-    CFIFrameInfo::RegisterValueMap<u_int32_t>::iterator entry =
+    CFIFrameInfo::RegisterValueMap<uint32_t>::iterator entry =
       caller_registers.find(register_names[i]);
     if (entry != caller_registers.end()) {
       // We recovered the value of this register; fill the context with the
       // value from caller_registers.
       frame->context_validity |= StackFrameARM::RegisterValidFlag(i);
       frame->context.iregs[i] = entry->second;
     } else if (4 <= i && i <= 11 && (last_frame->context_validity &
                                      StackFrameARM::RegisterValidFlag(i))) {
@@ -118,17 +118,17 @@
       // Registers r4 through r11 are callee-saves, according to the Procedure
       // Call Standard for the ARM Architecture, which the Linux ABI follows.
       frame->context_validity |= StackFrameARM::RegisterValidFlag(i);
       frame->context.iregs[i] = last_frame->context.iregs[i];
     }
   }
   // If the CFI doesn't recover the PC explicitly, then use .ra.
   if (!(frame->context_validity & StackFrameARM::CONTEXT_VALID_PC)) {
-    CFIFrameInfo::RegisterValueMap<u_int32_t>::iterator entry =
+    CFIFrameInfo::RegisterValueMap<uint32_t>::iterator entry =
       caller_registers.find(".ra");
     if (entry != caller_registers.end()) {
       if (fp_register_ == -1) {
         frame->context_validity |= StackFrameARM::CONTEXT_VALID_PC;
         frame->context.iregs[MD_CONTEXT_ARM_REG_PC] = entry->second;
       } else {
         // The CFI updated the link register and not the program counter.
         // Handle getting the program counter from the link register.
@@ -137,17 +137,17 @@
         frame->context.iregs[MD_CONTEXT_ARM_REG_LR] = entry->second;
         frame->context.iregs[MD_CONTEXT_ARM_REG_PC] =
             last_frame->context.iregs[MD_CONTEXT_ARM_REG_LR];
       }
     }
   }
   // If the CFI doesn't recover the SP explicitly, then use .cfa.
   if (!(frame->context_validity & StackFrameARM::CONTEXT_VALID_SP)) {
-    CFIFrameInfo::RegisterValueMap<u_int32_t>::iterator entry =
+    CFIFrameInfo::RegisterValueMap<uint32_t>::iterator entry =
       caller_registers.find(".cfa");
     if (entry != caller_registers.end()) {
       frame->context_validity |= StackFrameARM::CONTEXT_VALID_SP;
       frame->context.iregs[MD_CONTEXT_ARM_REG_SP] = entry->second;
     }
   }
 
   // If we didn't recover the PC and the SP, then the frame isn't very useful.
@@ -158,18 +158,18 @@
 
   frame->trust = StackFrame::FRAME_TRUST_CFI;
   return frame.release();
 }
 
 StackFrameARM* StackwalkerARM::GetCallerByStackScan(
     const vector<StackFrame*> &frames) {
   StackFrameARM* last_frame = static_cast<StackFrameARM*>(frames.back());
-  u_int32_t last_sp = last_frame->context.iregs[MD_CONTEXT_ARM_REG_SP];
-  u_int32_t caller_sp, caller_pc;
+  uint32_t last_sp = last_frame->context.iregs[MD_CONTEXT_ARM_REG_SP];
+  uint32_t caller_sp, caller_pc;
 
   // When searching for the caller of the context frame,
   // allow the scanner to look farther down the stack.
   const int kRASearchWords = frames.size() == 1 ?
     Stackwalker::kRASearchWords * 4 :
     Stackwalker::kRASearchWords;
 
   if (!ScanForReturnAddress(last_sp, &caller_sp, &caller_pc,
@@ -201,33 +201,33 @@
     const vector<StackFrame*> &frames) {
   StackFrameARM* last_frame = static_cast<StackFrameARM*>(frames.back());
 
   if (!(last_frame->context_validity &
         StackFrameARM::RegisterValidFlag(fp_register_))) {
     return NULL;
   }
 
-  u_int32_t last_fp = last_frame->context.iregs[fp_register_];
+  uint32_t last_fp = last_frame->context.iregs[fp_register_];
 
-  u_int32_t caller_fp = 0;
+  uint32_t caller_fp = 0;
   if (last_fp && !memory_->GetMemoryAtAddress(last_fp, &caller_fp)) {
     BPLOG(ERROR) << "Unable to read caller_fp from last_fp: 0x"
                  << std::hex << last_fp;
     return NULL;
   }
 
-  u_int32_t caller_lr = 0;
+  uint32_t caller_lr = 0;
   if (last_fp && !memory_->GetMemoryAtAddress(last_fp + 4, &caller_lr)) {
     BPLOG(ERROR) << "Unable to read caller_lr from last_fp + 4: 0x"
                  << std::hex << (last_fp + 4);
     return NULL;
   }
 
-  u_int32_t caller_sp = last_fp ? last_fp + 8 :
+  uint32_t caller_sp = last_fp ? last_fp + 8 :
       last_frame->context.iregs[MD_CONTEXT_ARM_REG_SP];
 
   // Create a new stack frame (ownership will be transferred to the caller)
   // and fill it in.
   StackFrameARM* frame = new StackFrameARM();
 
   frame->trust = StackFrame::FRAME_TRUST_FP;
   frame->context = last_frame->context;
diff --git a/src/processor/stackwalker_arm_unittest.cc b/src/processor/stackwalker_arm_unittest.cc
--- a/src/processor/stackwalker_arm_unittest.cc
+++ b/src/processor/stackwalker_arm_unittest.cc
@@ -106,19 +106,19 @@
   void RegionFromSection() {
     string contents;
     ASSERT_TRUE(stack_section.GetContents(&contents));
     stack_region.Init(stack_section.start().Value(), contents);
   }
 
   // Fill RAW_CONTEXT with pseudo-random data, for round-trip checking.
   void BrandContext(MDRawContextARM *raw_context) {
-    u_int8_t x = 173;
+    uint8_t x = 173;
     for (size_t i = 0; i < sizeof(*raw_context); i++)
-      reinterpret_cast<u_int8_t *>(raw_context)[i] = (x += 17);
+      reinterpret_cast<uint8_t *>(raw_context)[i] = (x += 17);
   }
 
   SystemInfo system_info;
   MDRawContextARM raw_context;
   Section stack_section;
   MockMemoryRegion stack_region;
   MockCodeModule module1;
   MockCodeModule module2;
@@ -185,18 +185,18 @@
 
 TEST_F(GetCallerFrame, ScanWithoutSymbols) {
   // When the stack walker resorts to scanning the stack,
   // only addresses located within loaded modules are
   // considered valid return addresses.
   // Force scanning through three frames to ensure that the
   // stack pointer is set properly in scan-recovered frames.
   stack_section.start() = 0x80000000;
-  u_int32_t return_address1 = 0x50000100;
-  u_int32_t return_address2 = 0x50000900;
+  uint32_t return_address1 = 0x50000100;
+  uint32_t return_address2 = 0x50000900;
   Label frame1_sp, frame2_sp;
   stack_section
     // frame 0
     .Append(16, 0)                      // space
 
     .D32(0x40090000)                    // junk that's not
     .D32(0x60000000)                    // a return address
 
@@ -247,17 +247,17 @@
 }
 
 TEST_F(GetCallerFrame, ScanWithFunctionSymbols) {
   // During stack scanning, if a potential return address
   // is located within a loaded module that has symbols,
   // it is only considered a valid return address if it
   // lies within a function's bounds.
   stack_section.start() = 0x80000000;
-  u_int32_t return_address = 0x50000200;
+  uint32_t return_address = 0x50000200;
   Label frame1_sp;
 
   stack_section
     // frame 0
     .Append(16, 0)                      // space
 
     .D32(0x40090000)                    // junk that's not
     .D32(0x60000000)                    // a return address
@@ -305,18 +305,18 @@
   EXPECT_EQ("marsupial", frame1->function_name);
   EXPECT_EQ(0x50000100U, frame1->function_base);
 }
 
 TEST_F(GetCallerFrame, ScanFirstFrame) {
   // If the stackwalker resorts to stack scanning, it will scan much
   // farther to find the caller of the context frame.
   stack_section.start() = 0x80000000;
-  u_int32_t return_address1 = 0x50000100;
-  u_int32_t return_address2 = 0x50000900;
+  uint32_t return_address1 = 0x50000100;
+  uint32_t return_address2 = 0x50000900;
   Label frame1_sp, frame2_sp;
   stack_section
     // frame 0
     .Append(32, 0)                      // space
 
     .D32(0x40090000)                    // junk that's not
     .D32(0x60000000)                    // a return address
 
@@ -669,18 +669,18 @@
     system_info.os_short = "ios";
   }
 };
 
 class GetFramesByFramePointer: public StackwalkerARMFixtureIOS, public Test { };
 
 TEST_F(GetFramesByFramePointer, OnlyFramePointer) {
   stack_section.start() = 0x80000000;
-  u_int32_t return_address1 = 0x50000100;
-  u_int32_t return_address2 = 0x50000900;
+  uint32_t return_address1 = 0x50000100;
+  uint32_t return_address2 = 0x50000900;
   Label frame1_sp, frame2_sp;
   Label frame1_fp, frame2_fp;
   stack_section
     // frame 0
     .Append(32, 0)           // Whatever values on the stack.
     .D32(0x0000000D)         // junk that's not
     .D32(0xF0000000)         // a return address.
 
@@ -759,18 +759,18 @@
 
                      "STACK CFI INIT 4000 100 .cfa: sp 0 + .ra: lr\n"
                      "STACK CFI 4001 .cfa: sp 8 + .ra: .cfa -4 + ^"
                      " r7: .cfa -8 + ^\n"
                      "STACK CFI 4002 .cfa: r7 8 +\n"
                   );
 
   stack_section.start() = 0x80000000;
-  u_int32_t return_address1 = 0x40004010;
-  u_int32_t return_address2 = 0x50000900;
+  uint32_t return_address1 = 0x40004010;
+  uint32_t return_address2 = 0x50000900;
   Label frame1_sp, frame2_sp;
   Label frame1_fp, frame2_fp;
   stack_section
     // frame 0
     .Append(32, 0)           // Whatever values on the stack.
     .D32(0x0000000D)         // junk that's not
     .D32(0xF0000000)         // a return address.
 
diff --git a/src/processor/stackwalker_ppc.cc b/src/processor/stackwalker_ppc.cc
--- a/src/processor/stackwalker_ppc.cc
+++ b/src/processor/stackwalker_ppc.cc
@@ -97,29 +97,29 @@
   // an x86 is usually referred to as the stack pointer on a ppc.
 
   StackFramePPC* last_frame = static_cast<StackFramePPC*>(
       stack->frames()->back());
 
   // A caller frame must reside higher in memory than its callee frames.
   // Anything else is an error, or an indication that we've reached the
   // end of the stack.
-  u_int32_t stack_pointer;
+  uint32_t stack_pointer;
   if (!memory_->GetMemoryAtAddress(last_frame->context.gpr[1],
                                    &stack_pointer) ||
       stack_pointer <= last_frame->context.gpr[1]) {
     return NULL;
   }
 
   // Mac OS X/Darwin gives 1 as the return address from the bottom-most
   // frame in a stack (a thread's entry point).  I haven't found any
   // documentation on this, but 0 or 1 would be bogus return addresses,
   // so check for them here and return false (end of stack) when they're
   // hit to avoid having a phantom frame.
-  u_int32_t instruction;
+  uint32_t instruction;
   if (!memory_->GetMemoryAtAddress(stack_pointer + 8, &instruction) ||
       instruction <= 1) {
     return NULL;
   }
 
   StackFramePPC* frame = new StackFramePPC();
 
   frame->context = last_frame->context;
diff --git a/src/processor/stackwalker_selftest.cc b/src/processor/stackwalker_selftest.cc
--- a/src/processor/stackwalker_selftest.cc
+++ b/src/processor/stackwalker_selftest.cc
@@ -95,40 +95,40 @@
 
 #define RECURSION_DEPTH 100
 
 
 // A simple MemoryRegion subclass that provides direct access to this
 // process' memory space by pointer.
 class SelfMemoryRegion : public MemoryRegion {
  public:
-  virtual u_int64_t GetBase() { return 0; }
-  virtual u_int32_t GetSize() { return 0xffffffff; }
+  virtual uint64_t GetBase() { return 0; }
+  virtual uint32_t GetSize() { return 0xffffffff; }
 
-  bool GetMemoryAtAddress(u_int64_t address, u_int8_t*  value) {
+  bool GetMemoryAtAddress(uint64_t address, uint8_t*  value) {
       return GetMemoryAtAddressInternal(address, value); }
-  bool GetMemoryAtAddress(u_int64_t address, u_int16_t* value) {
+  bool GetMemoryAtAddress(uint64_t address, uint16_t* value) {
       return GetMemoryAtAddressInternal(address, value); }
-  bool GetMemoryAtAddress(u_int64_t address, u_int32_t* value) {
+  bool GetMemoryAtAddress(uint64_t address, uint32_t* value) {
       return GetMemoryAtAddressInternal(address, value); }
-  bool GetMemoryAtAddress(u_int64_t address, u_int64_t* value) {
+  bool GetMemoryAtAddress(uint64_t address, uint64_t* value) {
       return GetMemoryAtAddressInternal(address, value); }
 
  private:
-  template<typename T> bool GetMemoryAtAddressInternal(u_int64_t address,
+  template<typename T> bool GetMemoryAtAddressInternal(uint64_t address,
                                                        T*        value) {
     // Without knowing what addresses are actually mapped, just assume that
     // everything low is not mapped.  This helps the stackwalker catch the
     // end of a stack when it tries to dereference a null or low pointer
     // in an attempt to find the caller frame.  Other unmapped accesses will
     // cause the program to crash, but that would properly be a test failure.
     if (address < 0x100)
       return false;
 
-    u_int8_t* memory = 0;
+    uint8_t* memory = 0;
     *value = *reinterpret_cast<const T*>(&memory[address]);
     return true;
   }
 };
 
 
 #if defined(__GNUC__)
 
@@ -137,35 +137,35 @@
 
 // GetEBP returns the current value of the %ebp register.  Because it's
 // implemented as a function, %ebp itself contains GetEBP's frame pointer
 // and not the caller's frame pointer.  Dereference %ebp to obtain the
 // caller's frame pointer, which the compiler-generated preamble stored
 // on the stack (provided frame pointers are not being omitted.)  Because
 // this function depends on the compiler-generated preamble, inlining is
 // disabled.
-static u_int32_t GetEBP() __attribute__((noinline));
-static u_int32_t GetEBP() {
-  u_int32_t ebp;
+static uint32_t GetEBP() __attribute__((noinline));
+static uint32_t GetEBP() {
+  uint32_t ebp;
   __asm__ __volatile__(
     "movl (%%ebp), %0"
     : "=a" (ebp)
   );
   return ebp;
 }
 
 
 // The caller's %esp is 8 higher than the value of %ebp in this function,
 // assuming that it's not inlined and that the standard prolog is used.
 // The CALL instruction places a 4-byte return address on the stack above
 // the caller's %esp, and this function's prolog will save the caller's %ebp
 // on the stack as well, for another 4 bytes, before storing %esp in %ebp.
-static u_int32_t GetESP() __attribute__((noinline));
-static u_int32_t GetESP() {
-  u_int32_t ebp;
+static uint32_t GetESP() __attribute__((noinline));
+static uint32_t GetESP() {
+  uint32_t ebp;
   __asm__ __volatile__(
     "movl %%ebp, %0"
     : "=a" (ebp)
   );
   return ebp + 8;
 }
 
 
@@ -174,19 +174,19 @@
 // stack, where it was placed by the call instruction that called GetEIP.
 // This function depends on frame pointers not being omitted.  It is possible
 // to write a pure asm version of this routine that has no compiler-generated
 // preamble and uses %esp instead of %ebp; that would function in the
 // absence of frame pointers.  However, the simpler approach is used here
 // because GetEBP and stackwalking necessarily depends on access to frame
 // pointers.  Because this function depends on a call instruction and the
 // compiler-generated preamble, inlining is disabled.
-static u_int32_t GetEIP() __attribute__((noinline));
-static u_int32_t GetEIP() {
-  u_int32_t eip;
+static uint32_t GetEIP() __attribute__((noinline));
+static uint32_t GetEIP() {
+  uint32_t eip;
   __asm__ __volatile__(
     "movl 4(%%ebp), %0"
     : "=a" (eip)
   );
   return eip;
 }
 
 
@@ -194,35 +194,35 @@
 
 
 // GetSP returns the current value of the %r1 register, which by convention,
 // is the stack pointer on ppc.  Because it's implemented as a function,
 // %r1 itself contains GetSP's own stack pointer and not the caller's stack
 // pointer.  Dereference %r1 to obtain the caller's stack pointer, which the
 // compiler-generated prolog stored on the stack.  Because this function
 // depends on the compiler-generated prolog, inlining is disabled.
-static u_int32_t GetSP() __attribute__((noinline));
-static u_int32_t GetSP() {
-  u_int32_t sp;
+static uint32_t GetSP() __attribute__((noinline));
+static uint32_t GetSP() {
+  uint32_t sp;
   __asm__ __volatile__(
     "lwz %0, 0(r1)"
     : "=r" (sp)
   );
   return sp;
 }
 
 
 // GetPC returns the program counter identifying the next instruction to
 // execute after GetPC returns.  It obtains this information from the
 // link register, where it was placed by the branch instruction that called
 // GetPC.  Because this function depends on the caller's use of a branch
 // instruction, inlining is disabled.
-static u_int32_t GetPC() __attribute__((noinline));
-static u_int32_t GetPC() {
-  u_int32_t lr;
+static uint32_t GetPC() __attribute__((noinline));
+static uint32_t GetPC() {
+  uint32_t lr;
   __asm__ __volatile__(
     "mflr %0"
     : "=r" (lr)
   );
   return lr;
 }
 
 
@@ -231,73 +231,73 @@
 
 // GetSP returns the current value of the %sp/%o6/%g_r[14] register, which 
 // by convention, is the stack pointer on sparc.  Because it's implemented
 // as a function, %sp itself contains GetSP's own stack pointer and not 
 // the caller's stack pointer.  Dereference  to obtain the caller's stack 
 // pointer, which the compiler-generated prolog stored on the stack.
 // Because this function depends on the compiler-generated prolog, inlining
 // is disabled.
-static u_int32_t GetSP() __attribute__((noinline));
-static u_int32_t GetSP() {
-  u_int32_t sp;
+static uint32_t GetSP() __attribute__((noinline));
+static uint32_t GetSP() {
+  uint32_t sp;
   __asm__ __volatile__(
     "mov %%fp, %0"
     : "=r" (sp)
   );
   return sp;
 }
 
 // GetFP returns the current value of the %fp register.  Because it's
 // implemented as a function, %fp itself contains GetFP's frame pointer
 // and not the caller's frame pointer.  Dereference %fp to obtain the
 // caller's frame pointer, which the compiler-generated preamble stored
 // on the stack (provided frame pointers are not being omitted.)  Because
 // this function depends on the compiler-generated preamble, inlining is
 // disabled.
-static u_int32_t GetFP() __attribute__((noinline));
-static u_int32_t GetFP() {
-  u_int32_t fp;
+static uint32_t GetFP() __attribute__((noinline));
+static uint32_t GetFP() {
+  uint32_t fp;
   __asm__ __volatile__(
     "ld [%%fp+56], %0"
     : "=r" (fp)
   );
   return fp;
 }
 
 // GetPC returns the program counter identifying the next instruction to
 // execute after GetPC returns.  It obtains this information from the
 // link register, where it was placed by the branch instruction that called
 // GetPC.  Because this function depends on the caller's use of a branch
 // instruction, inlining is disabled.
-static u_int32_t GetPC() __attribute__((noinline));
-static u_int32_t GetPC() {
-  u_int32_t pc;
+static uint32_t GetPC() __attribute__((noinline));
+static uint32_t GetPC() {
+  uint32_t pc;
   __asm__ __volatile__(
     "mov %%i7, %0"
     : "=r" (pc)
   );
   return pc + 8;
 }
 
 #endif  // __i386__ || __ppc__ || __sparc__
 
 #elif defined(__SUNPRO_CC)
 
 #if defined(__i386__)
 extern "C" {
-extern u_int32_t GetEIP();
-extern u_int32_t GetEBP();
-extern u_int32_t GetESP();
+extern uint32_t GetEIP();
+extern uint32_t GetEBP();
+extern uint32_t GetESP();
 }
 #elif defined(__sparc__)
 extern "C" {
-extern u_int32_t GetPC();
-extern u_int32_t GetFP();
-extern u_int32_t GetSP();
+extern uint32_t GetPC();
+extern uint32_t GetFP();
+extern uint32_t GetSP();
 }
 #endif // __i386__ || __sparc__
 
 #endif // __GNUC__ || __SUNPRO_CC
 
 // CountCallerFrames returns the number of stack frames beneath the function
 // that called CountCallerFrames.  Because this function's return value
 // is dependent on the size of the stack beneath it, inlining is disabled,
diff --git a/src/processor/stackwalker_sparc.cc b/src/processor/stackwalker_sparc.cc
--- a/src/processor/stackwalker_sparc.cc
+++ b/src/processor/stackwalker_sparc.cc
@@ -88,28 +88,28 @@
   // %sp_new = %fp_old
   // %fp_new = *(%fp_old + 32 + 32 - 8), where the callee's %i6
   // %pc_new = *(%fp_old + 32 + 32 - 4) + 8
   // which is callee's %i7 plus 8
 
   // A caller frame must reside higher in memory than its callee frames.
   // Anything else is an error, or an indication that we've reached the
   // end of the stack.
-  u_int64_t stack_pointer = last_frame->context.g_r[30];
+  uint64_t stack_pointer = last_frame->context.g_r[30];
   if (stack_pointer <= last_frame->context.g_r[14]) {
     return NULL;
   }
 
-  u_int32_t instruction;
+  uint32_t instruction;
   if (!memory_->GetMemoryAtAddress(stack_pointer + 60,
                      &instruction) || instruction <= 1) {
     return NULL;
   }
 
-  u_int32_t stack_base;
+  uint32_t stack_base;
   if (!memory_->GetMemoryAtAddress(stack_pointer + 56,
                      &stack_base) || stack_base <= 1) {
     return NULL;
   }
 
   StackFrameSPARC* frame = new StackFrameSPARC();
 
   frame->context = last_frame->context;
diff --git a/src/processor/stackwalker_unittest_utils.h b/src/processor/stackwalker_unittest_utils.h
--- a/src/processor/stackwalker_unittest_utils.h
+++ b/src/processor/stackwalker_unittest_utils.h
@@ -50,94 +50,94 @@
 
 class MockMemoryRegion: public google_breakpad::MemoryRegion {
  public:
   MockMemoryRegion(): base_address_(0) { }
 
   // Set this region's address and contents. If we have placed an
   // instance of this class in a test fixture class, individual tests
   // can use this to provide the region's contents.
-  void Init(u_int64_t base_address, const string &contents) {
+  void Init(uint64_t base_address, const string &contents) {
     base_address_ = base_address;
     contents_ = contents;
   }
 
-  u_int64_t GetBase() const { return base_address_; }
-  u_int32_t GetSize() const { return contents_.size(); }
+  uint64_t GetBase() const { return base_address_; }
+  uint32_t GetSize() const { return contents_.size(); }
 
-  bool GetMemoryAtAddress(u_int64_t address, u_int8_t  *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint8_t  *value) const {
     return GetMemoryLittleEndian(address, value);
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int16_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint16_t *value) const {
     return GetMemoryLittleEndian(address, value);
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int32_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint32_t *value) const {
     return GetMemoryLittleEndian(address, value);
   }
-  bool GetMemoryAtAddress(u_int64_t address, u_int64_t *value) const {
+  bool GetMemoryAtAddress(uint64_t address, uint64_t *value) const {
     return GetMemoryLittleEndian(address, value);
   }
 
  private:
   // Fetch a little-endian value from ADDRESS in contents_ whose size
   // is BYTES, and store it in *VALUE. Return true on success.
   template<typename ValueType>
-  bool GetMemoryLittleEndian(u_int64_t address, ValueType *value) const {
+  bool GetMemoryLittleEndian(uint64_t address, ValueType *value) const {
     if (address < base_address_ ||
         address - base_address_ + sizeof(ValueType) > contents_.size())
       return false;
     ValueType v = 0;
     int start = address - base_address_;
     // The loop condition is odd, but it's correct for size_t.
     for (size_t i = sizeof(ValueType) - 1; i < sizeof(ValueType); i--)
       v = (v << 8) | static_cast<unsigned char>(contents_[start + i]);
     *value = v;
     return true;
   }
 
-  u_int64_t base_address_;
+  uint64_t base_address_;
   string contents_;
 };
 
 class MockCodeModule: public google_breakpad::CodeModule {
  public:
-  MockCodeModule(u_int64_t base_address, u_int64_t size,
+  MockCodeModule(uint64_t base_address, uint64_t size,
                  const string &code_file, const string &version)
       : base_address_(base_address), size_(size), code_file_(code_file) { }
 
-  u_int64_t base_address()       const { return base_address_; }
-  u_int64_t size()               const { return size_; }
+  uint64_t base_address()       const { return base_address_; }
+  uint64_t size()               const { return size_; }
   string code_file()        const { return code_file_; }
   string code_identifier()  const { return code_file_; }
   string debug_file()       const { return code_file_; }
   string debug_identifier() const { return code_file_; }
   string version()          const { return version_; }
   const google_breakpad::CodeModule *Copy() const {
     abort(); // Tests won't use this.
   }
 
  private:
-  u_int64_t base_address_;
-  u_int64_t size_;
+  uint64_t base_address_;
+  uint64_t size_;
   string code_file_;
   string version_;
 };
 
 class MockCodeModules: public google_breakpad::CodeModules {
  public:  
   typedef google_breakpad::CodeModule CodeModule;
   typedef google_breakpad::CodeModules CodeModules;
 
   void Add(const MockCodeModule *module) { 
     modules_.push_back(module);
   }
 
   unsigned int module_count() const { return modules_.size(); }
 
-  const CodeModule *GetModuleForAddress(u_int64_t address) const {
+  const CodeModule *GetModuleForAddress(uint64_t address) const {
     for (ModuleVector::const_iterator i = modules_.begin();
          i != modules_.end(); i++) {
       const MockCodeModule *module = *i;
       if (module->base_address() <= address &&
           address - module->base_address() < module->size())
         return module;
     }
     return NULL;
diff --git a/src/processor/stackwalker_x86.cc b/src/processor/stackwalker_x86.cc
--- a/src/processor/stackwalker_x86.cc
+++ b/src/processor/stackwalker_x86.cc
@@ -101,17 +101,17 @@
   if (windows_frame_info)
     delete windows_frame_info;
   windows_frame_info = NULL;
   if (cfi_frame_info)
     delete cfi_frame_info;
   cfi_frame_info = NULL;
 }
 
-u_int64_t StackFrameX86::ReturnAddress() const
+uint64_t StackFrameX86::ReturnAddress() const
 {
   assert(context_validity & StackFrameX86::CONTEXT_VALID_EIP);
   return context.eip;   
 }
 
 StackFrame* StackwalkerX86::GetContextFrame() {
   if (!context_) {
     BPLOG(ERROR) << "Can't get context frame without context";
@@ -174,17 +174,17 @@
   // If the last frame has no callee (because it's the context frame), just
   // set the callee parameter size to 0: the stack pointer can't point to
   // callee arguments because there's no callee.  This is correct as long
   // as the context wasn't captured while arguments were being pushed for
   // a function call.  Note that there may be functions whose parameter sizes
   // are unknown, 0 is also used in that case.  When that happens, it should
   // be possible to walk to the next frame without reference to %esp.
 
-  u_int32_t last_frame_callee_parameter_size = 0;
+  uint32_t last_frame_callee_parameter_size = 0;
   int frames_already_walked = frames.size();
   if (frames_already_walked >= 2) {
     const StackFrameX86* last_frame_callee
         = static_cast<StackFrameX86*>(frames[frames_already_walked - 2]);
     WindowsFrameInfo* last_frame_callee_info
         = last_frame_callee->windows_frame_info;
     if (last_frame_callee_info &&
         (last_frame_callee_info->valid
@@ -192,36 +192,36 @@
       last_frame_callee_parameter_size =
           last_frame_callee_info->parameter_size;
     }
   }
 
   // Set up the dictionary for the PostfixEvaluator.  %ebp and %esp are used
   // in each program string, and their previous values are known, so set them
   // here.
-  PostfixEvaluator<u_int32_t>::DictionaryType dictionary;
+  PostfixEvaluator<uint32_t>::DictionaryType dictionary;
   // Provide the current register values.
   dictionary["$ebp"] = last_frame->context.ebp;
   dictionary["$esp"] = last_frame->context.esp;
   // Provide constants from the debug info for last_frame and its callee.
   // .cbCalleeParams is a Breakpad extension that allows us to use the
   // PostfixEvaluator engine when certain types of debugging information
   // are present without having to write the constants into the program
   // string as literals.
   dictionary[".cbCalleeParams"] = last_frame_callee_parameter_size;
   dictionary[".cbSavedRegs"] = last_frame_info->saved_register_size;
   dictionary[".cbLocals"] = last_frame_info->local_size;
 
-  u_int32_t raSearchStart = last_frame->context.esp +
+  uint32_t raSearchStart = last_frame->context.esp +
                             last_frame_callee_parameter_size +
                             last_frame_info->local_size +
                             last_frame_info->saved_register_size;
 
-  u_int32_t raSearchStartOld = raSearchStart;
-  u_int32_t found = 0;  // dummy value
+  uint32_t raSearchStartOld = raSearchStart;
+  uint32_t found = 0;  // dummy value
   // Scan up to three words above the calculated search value, in case
   // the stack was aligned to a quadword boundary.
   if (ScanForReturnAddress(raSearchStart, &raSearchStart, &found, 3) &&
       last_frame->trust == StackFrame::FRAME_TRUST_CONTEXT &&
       last_frame->windows_frame_info != NULL &&
       last_frame_info->type_ == WindowsFrameInfo::STACK_INFO_FPO &&
       raSearchStartOld == raSearchStart &&
       found == last_frame->context.eip) {
@@ -321,30 +321,30 @@
     // %ebp_new = %ebp_old
     program_string = "$eip .raSearchStart ^ = "
         "$esp .raSearchStart 4 + =";
     recover_ebp = false;
   }
 
   // Now crank it out, making sure that the program string set at least the
   // two required variables.
-  PostfixEvaluator<u_int32_t> evaluator =
-      PostfixEvaluator<u_int32_t>(&dictionary, memory_);
-  PostfixEvaluator<u_int32_t>::DictionaryValidityType dictionary_validity;
+  PostfixEvaluator<uint32_t> evaluator =
+      PostfixEvaluator<uint32_t>(&dictionary, memory_);
+  PostfixEvaluator<uint32_t>::DictionaryValidityType dictionary_validity;
   if (!evaluator.Evaluate(program_string, &dictionary_validity) ||
       dictionary_validity.find("$eip") == dictionary_validity.end() ||
       dictionary_validity.find("$esp") == dictionary_validity.end()) {
     // Program string evaluation failed. It may be that %eip is not somewhere
     // with stack frame info, and %ebp is pointing to non-stack memory, so
     // our evaluation couldn't succeed. We'll scan the stack for a return
     // address. This can happen if the stack is in a module for which
     // we don't have symbols, and that module is compiled without a
     // frame pointer.
-    u_int32_t location_start = last_frame->context.esp;
-    u_int32_t location, eip;
+    uint32_t location_start = last_frame->context.esp;
+    uint32_t location, eip;
     if (!ScanForReturnAddress(location_start, &location, &eip)) {
       // if we can't find an instruction pointer even with stack scanning,
       // give up.
       return NULL;
     }
 
     // This seems like a reasonable return address. Since program string
     // evaluation failed, use it and set %esp to the location above the
@@ -371,22 +371,22 @@
     // solution is to check the minidump's memory map to see if the candidate
     // %eip value comes from a mapped executable page, although this would
     // require dumps that contain MINIDUMP_MEMORY_INFO, which the Breakpad
     // client doesn't currently write (it would need to call MiniDumpWriteDump
     // with the MiniDumpWithFullMemoryInfo type bit set).  Even given this
     // ability, older OSes (pre-XP SP2) and CPUs (pre-P4) don't enforce
     // an independent execute privilege on memory pages.
 
-    u_int32_t eip = dictionary["$eip"];
+    uint32_t eip = dictionary["$eip"];
     if (modules_ && !modules_->GetModuleForAddress(eip)) {
       // The instruction pointer at .raSearchStart was invalid, so start
       // looking one 32-bit word above that location.
-      u_int32_t location_start = dictionary[".raSearchStart"] + 4;
-      u_int32_t location;
+      uint32_t location_start = dictionary[".raSearchStart"] + 4;
+      uint32_t location;
       if (ScanForReturnAddress(location_start, &location, &eip)) {
         // This is a better return address that what program string
         // evaluation found.  Use it, and set %esp to the location above the
         // one where the return address was found.
         dictionary["$eip"] = eip;
         dictionary["$esp"] = location + 4;
         offset = location - location_start;
         trust = StackFrame::FRAME_TRUST_CFI_SCAN;
@@ -396,32 +396,32 @@
     if (recover_ebp) {
       // When trying to recover the previous value of the frame pointer (%ebp),
       // start looking at the lowest possible address in the saved-register
       // area, and look at the entire saved register area, increased by the
       // size of |offset| to account for additional data that may be on the
       // stack.  The scan is performed from the highest possible address to
       // the lowest, because the expectation is that the function's prolog
       // would have saved %ebp early.
-      u_int32_t ebp = dictionary["$ebp"];
+      uint32_t ebp = dictionary["$ebp"];
 
       // When a scan for return address is used, it is possible to skip one or
       // more frames (when return address is not in a known module).  One
       // indication for skipped frames is when the value of %ebp is lower than
       // the location of the return address on the stack
       bool has_skipped_frames =
         (trust != StackFrame::FRAME_TRUST_CFI && ebp <= raSearchStart + offset);
 
-      u_int32_t value;  // throwaway variable to check pointer validity
+      uint32_t value;  // throwaway variable to check pointer validity
       if (has_skipped_frames || !memory_->GetMemoryAtAddress(ebp, &value)) {
         int fp_search_bytes = last_frame_info->saved_register_size + offset;
-        u_int32_t location_end = last_frame->context.esp +
+        uint32_t location_end = last_frame->context.esp +
                                  last_frame_callee_parameter_size;
 
-        for (u_int32_t location = location_end + fp_search_bytes;
+        for (uint32_t location = location_end + fp_search_bytes;
              location >= location_end;
              location -= 4) {
           if (!memory_->GetMemoryAtAddress(location, &ebp))
             break;
 
           if (memory_->GetMemoryAtAddress(ebp, &value)) {
             // The candidate value is a pointer to the same memory region
             // (the stack).  Prefer it as a recovered %ebp result.
@@ -488,18 +488,18 @@
 
   return frame.release();
 }
 
 StackFrameX86* StackwalkerX86::GetCallerByEBPAtBase(
     const vector<StackFrame*> &frames) {
   StackFrame::FrameTrust trust;
   StackFrameX86* last_frame = static_cast<StackFrameX86*>(frames.back());
-  u_int32_t last_esp = last_frame->context.esp;
-  u_int32_t last_ebp = last_frame->context.ebp;
+  uint32_t last_esp = last_frame->context.esp;
+  uint32_t last_ebp = last_frame->context.ebp;
 
   // Assume that the standard %ebp-using x86 calling convention is in
   // use.
   //
   // The typical x86 calling convention, when frame pointers are present,
   // is for the calling procedure to use CALL, which pushes the return
   // address onto the stack and sets the instruction pointer (%eip) to
   // the entry point of the called routine.  The called routine then
@@ -514,17 +514,17 @@
   // procedure made the CALL: 4 bytes for the return address pushed by the
   // CALL itself, and 4 bytes for the callee's PUSH of the caller's frame
   // pointer.
   //
   // %eip_new = *(%ebp_old + 4)
   // %esp_new = %ebp_old + 8
   // %ebp_new = *(%ebp_old)
 
-  u_int32_t caller_eip, caller_esp, caller_ebp;
+  uint32_t caller_eip, caller_esp, caller_ebp;
 
   if (memory_->GetMemoryAtAddress(last_ebp + 4, &caller_eip) &&
       memory_->GetMemoryAtAddress(last_ebp, &caller_ebp)) {
     caller_esp = last_ebp + 8;
     trust = StackFrame::FRAME_TRUST_FP;
   } else {
     // We couldn't read the memory %ebp refers to. It may be that %ebp
     // is pointing to non-stack memory. We'll scan the stack for a
diff --git a/src/processor/stackwalker_x86.h b/src/processor/stackwalker_x86.h
--- a/src/processor/stackwalker_x86.h
+++ b/src/processor/stackwalker_x86.h
@@ -62,17 +62,17 @@
   StackwalkerX86(const SystemInfo* system_info,
                  const MDRawContextX86* context,
                  MemoryRegion* memory,
                  const CodeModules* modules,
                  StackFrameSymbolizer* frame_symbolizer);
 
  private:
   // A STACK CFI-driven frame walker for the X86.
-  typedef SimpleCFIWalker<u_int32_t, MDRawContextX86> CFIWalker;
+  typedef SimpleCFIWalker<uint32_t, MDRawContextX86> CFIWalker;
 
   // Implementation of Stackwalker, using x86 context (%ebp, %esp, %eip) and
   // stack conventions (saved %ebp at [%ebp], saved %eip at 4[%ebp], or
   // alternate conventions as guided by any WindowsFrameInfo available for the
   // code in question.).
   virtual StackFrame* GetContextFrame();
   virtual StackFrame* GetCallerFrame(const CallStack* stack);
 
diff --git a/src/processor/stackwalker_x86_unittest.cc b/src/processor/stackwalker_x86_unittest.cc
--- a/src/processor/stackwalker_x86_unittest.cc
+++ b/src/processor/stackwalker_x86_unittest.cc
@@ -113,19 +113,19 @@
   void RegionFromSection() {
     string contents;
     ASSERT_TRUE(stack_section.GetContents(&contents));
     stack_region.Init(stack_section.start().Value(), contents);
   }
 
   // Fill RAW_CONTEXT with pseudo-random data, for round-trip checking.
   void BrandContext(MDRawContextX86 *raw_context) {
-    u_int8_t x = 173;
+    uint8_t x = 173;
     for (size_t i = 0; i < sizeof(*raw_context); i++)
-      reinterpret_cast<u_int8_t *>(raw_context)[i] = (x += 17);
+      reinterpret_cast<uint8_t *>(raw_context)[i] = (x += 17);
   }
   
   SystemInfo system_info;
   MDRawContextX86 raw_context;
   Section stack_section;
   MockMemoryRegion stack_region;
   MockCodeModule module1;
   MockCodeModule module2;
diff --git a/src/processor/static_contained_range_map-inl.h b/src/processor/static_contained_range_map-inl.h
--- a/src/processor/static_contained_range_map-inl.h
+++ b/src/processor/static_contained_range_map-inl.h
@@ -41,17 +41,17 @@
 #include "processor/logging.h"
 
 namespace google_breakpad {
 
 template<typename AddressType, typename EntryType>
 StaticContainedRangeMap<AddressType, EntryType>::StaticContainedRangeMap(
     const char *base)
     : base_(*(reinterpret_cast<const AddressType*>(base))),
-      entry_size_(*(reinterpret_cast<const u_int32_t*>(base + sizeof(base_)))),
+      entry_size_(*(reinterpret_cast<const uint32_t*>(base + sizeof(base_)))),
       entry_ptr_(reinterpret_cast<const EntryType *>(
           base + sizeof(base_) + sizeof(entry_size_))),
       map_(base + sizeof(base_) + sizeof(entry_size_) + entry_size_) {
   if (entry_size_ == 0)
     entry_ptr_ = NULL;
 }
 
 
diff --git a/src/processor/static_contained_range_map.h b/src/processor/static_contained_range_map.h
--- a/src/processor/static_contained_range_map.h
+++ b/src/processor/static_contained_range_map.h
@@ -76,17 +76,17 @@
   // no key is unimportant.  For this reason, the base_ field should only be
   // is accessed on child ContainedRangeMap objects, and never on |this|.
   AddressType base_;
 
   // The entry corresponding to this range.  The root range does not
   // actually contain an entry, so its entry_ field is meaningless.  For
   // this reason, the entry_ field should only be accessed on child
   // ContainedRangeMap objects, and never on |this|.
-  u_int32_t entry_size_;
+  uint32_t entry_size_;
   const EntryType *entry_ptr_;
 
   // The map containing child ranges, keyed by each child range's high
   // address.  This is a pointer to avoid allocating map structures for
   // leaf nodes, where they are not needed.
   AddressToRangeMap map_;
 };
 
diff --git a/src/processor/static_map-inl.h b/src/processor/static_map-inl.h
--- a/src/processor/static_map-inl.h
+++ b/src/processor/static_map-inl.h
@@ -42,23 +42,23 @@
 
 namespace google_breakpad {
 
 template<typename Key, typename Value, typename Compare>
 StaticMap<Key, Value, Compare>::StaticMap(const char* raw_data)
     : raw_data_(raw_data),
       compare_() {
   // First 4 Bytes store the number of nodes.
-  num_nodes_ = *(reinterpret_cast<const u_int32_t*>(raw_data_));
+  num_nodes_ = *(reinterpret_cast<const uint32_t*>(raw_data_));
 
-  offsets_ = reinterpret_cast<const u_int32_t*>(
+  offsets_ = reinterpret_cast<const uint32_t*>(
       raw_data_ + sizeof(num_nodes_));
 
   keys_ = reinterpret_cast<const Key*>(
-      raw_data_ + (1 + num_nodes_) * sizeof(u_int32_t));
+      raw_data_ + (1 + num_nodes_) * sizeof(uint32_t));
 }
 
 // find(), lower_bound() and upper_bound() implement binary search algorithm.
 template<typename Key, typename Value, typename Compare>
 StaticMapIterator<Key, Value, Compare>
 StaticMap<Key, Value, Compare>::find(const Key &key) const {
   int begin = 0;
   int end = num_nodes_;
@@ -127,24 +127,24 @@
   int32_t num_nodes = *(reinterpret_cast<const int32_t*>(raw_data_));
   if (num_nodes < 0) {
     BPLOG(INFO) << "StaticMap check failed: negative number of nodes";
     return false;
   }
 
   int node_index = 0;
   if (num_nodes_) {
-    u_int64_t first_offset = sizeof(int32_t) * (num_nodes_ + 1)
+    uint64_t first_offset = sizeof(int32_t) * (num_nodes_ + 1)
                            + sizeof(Key) * num_nodes_;
     // Num_nodes_ is too large.
     if (first_offset > 0xffffffffUL) {
       BPLOG(INFO) << "StaticMap check failed: size exceeds limit";
       return false;
     }
-    if (offsets_[node_index] != static_cast<u_int32_t>(first_offset)) {
+    if (offsets_[node_index] != static_cast<uint32_t>(first_offset)) {
       BPLOG(INFO) << "StaticMap check failed: first node offset is incorrect";
       return false;
     }
   }
 
   for (node_index = 1; node_index < num_nodes_; ++node_index) {
     // Check offsets[i] is strictly increasing:
     if (offsets_[node_index] <= offsets_[node_index - 1]) {
diff --git a/src/processor/static_map.h b/src/processor/static_map.h
--- a/src/processor/static_map.h
+++ b/src/processor/static_map.h
@@ -126,17 +126,17 @@
   const char* raw_data_;
 
   // Number of nodes in the static map.
   int32_t num_nodes_;
 
   // Array of offset addresses for stored values.
   // For example:
   // address_of_i-th_node_value = raw_data_ + offsets_[i]
-  const u_int32_t* offsets_;
+  const uint32_t* offsets_;
 
   // keys_[i] = key of i_th node
   const Key* keys_;
 
   Compare compare_;
 };
 
 }  // namespace google_breakpad
diff --git a/src/processor/static_map_iterator-inl.h b/src/processor/static_map_iterator-inl.h
--- a/src/processor/static_map_iterator-inl.h
+++ b/src/processor/static_map_iterator-inl.h
@@ -43,17 +43,17 @@
 
 template<typename Key, typename Value, typename Compare>
 StaticMapIterator<Key, Value, Compare>::StaticMapIterator(const char* base,
                                                             const int &index):
       index_(index), base_(base) {
   // See static_map.h for documentation on
   // bytes format of serialized StaticMap data.
   num_nodes_ = *(reinterpret_cast<const int32_t*>(base_));
-  offsets_ = reinterpret_cast<const u_int32_t*>(base_ + sizeof(num_nodes_));
+  offsets_ = reinterpret_cast<const uint32_t*>(base_ + sizeof(num_nodes_));
   keys_ = reinterpret_cast<const Key*>(
       base_ + (1 + num_nodes_) * sizeof(num_nodes_));
 }
 
 // Increment & Decrement operators:
 template<typename Key, typename Value, typename Compare>
 StaticMapIterator<Key, Value, Compare>&
 StaticMapIterator<Key, Value, Compare>::operator++() {
diff --git a/src/processor/static_map_iterator.h b/src/processor/static_map_iterator.h
--- a/src/processor/static_map_iterator.h
+++ b/src/processor/static_map_iterator.h
@@ -34,17 +34,17 @@
 // pointer to data.  StaticMapIterator is essentially a const_iterator.
 //
 // Author: Siyang Xie (lambxsy@google.com)
 
 
 #ifndef PROCESSOR_STATIC_MAP_ITERATOR_H__
 #define PROCESSOR_STATIC_MAP_ITERATOR_H__
 
-#include <sys/types.h>
+#include "google_breakpad/common/breakpad_types.h"
 
 namespace google_breakpad {
 
 // Forward declaration.
 template<typename Key, typename Value, typename Compare> class StaticMap;
 
 // StaticMapIterator does not support operator*() or operator->(),
 // User should use GetKey(), GetKeyPtr(), GetValuePtr() instead;
@@ -96,17 +96,17 @@
   const char* base_;
 
   // Number of nodes in the map.  Use it to identify end() iterator.
   int32_t num_nodes_;
 
   // offsets_ is an array of offset addresses of mapped values.
   // For example:
   // address_of_i-th_node_value = base_ + offsets_[i]
-  const u_int32_t* offsets_;
+  const uint32_t* offsets_;
 
   // keys_[i] = key of i_th node.
   const Key* keys_;
 };
 
 }  // namespace google_breakpad
 
 #endif  // PROCESSOR_STATIC_MAP_ITERATOR_H__
diff --git a/src/processor/static_map_unittest.cc b/src/processor/static_map_unittest.cc
--- a/src/processor/static_map_unittest.cc
+++ b/src/processor/static_map_unittest.cc
@@ -44,31 +44,31 @@
 typedef std::map< KeyType, ValueType > StdMap;
 
 template<typename Key, typename Value>
 class SimpleMapSerializer {
  public:
   static char* Serialize(const std::map<Key, Value> &stdmap,
                    unsigned int* size = NULL) {
     unsigned int size_per_node =
-        sizeof(u_int32_t) + sizeof(Key) + sizeof(Value);
+        sizeof(uint32_t) + sizeof(Key) + sizeof(Value);
     unsigned int memsize = sizeof(int32_t) + size_per_node * stdmap.size();
     if (size) *size = memsize;
 
     // Allocate memory for serialized data:
     char* mem = reinterpret_cast<char*>(operator new(memsize));
     char* address = mem;
 
     // Writer the number of nodes:
-    new (address) u_int32_t(static_cast<u_int32_t>(stdmap.size()));
-    address += sizeof(u_int32_t);
+    new (address) uint32_t(static_cast<uint32_t>(stdmap.size()));
+    address += sizeof(uint32_t);
 
     // Nodes' offset:
-    u_int32_t* offsets = reinterpret_cast<u_int32_t*>(address);
-    address += sizeof(u_int32_t) * stdmap.size();
+    uint32_t* offsets = reinterpret_cast<uint32_t*>(address);
+    address += sizeof(uint32_t) * stdmap.size();
 
     // Keys:
     Key* keys = reinterpret_cast<Key*>(address);
     address += sizeof(Key) * stdmap.size();
 
     // Traversing map:
     typename std::map<Key, Value>::const_iterator iter = stdmap.begin();
     for (int index = 0; iter != stdmap.end(); ++iter, ++index) {
@@ -90,49 +90,49 @@
 
   // 40 Bytes memory can hold a StaticMap with up to 3 nodes.
   static const int kMemorySize = 40;
   char data[kMemorySize];
   TestMap test_map;
 };
 
 TEST_F(TestInvalidMap, TestNegativeNumberNodes) {
-  memset(data, 0xff, sizeof(u_int32_t));  // Set the number of nodes = -1
+  memset(data, 0xff, sizeof(uint32_t));  // Set the number of nodes = -1
   test_map = TestMap(data);
   ASSERT_FALSE(test_map.ValidateInMemoryStructure());
 }
 
 TEST_F(TestInvalidMap, TestWrongOffsets) {
-  u_int32_t* header = reinterpret_cast<u_int32_t*>(data);
-  const u_int32_t kNumNodes = 2;
-  const u_int32_t kHeaderOffset =
-        sizeof(u_int32_t) + kNumNodes * (sizeof(u_int32_t) + sizeof(KeyType));
+  uint32_t* header = reinterpret_cast<uint32_t*>(data);
+  const uint32_t kNumNodes = 2;
+  const uint32_t kHeaderOffset =
+        sizeof(uint32_t) + kNumNodes * (sizeof(uint32_t) + sizeof(KeyType));
 
   header[0] = kNumNodes;
   header[1] = kHeaderOffset + 3;   // Wrong offset for first node
   test_map = TestMap(data);
   ASSERT_FALSE(test_map.ValidateInMemoryStructure());
 
   header[1] = kHeaderOffset;       // Correct offset for first node
   header[2] = kHeaderOffset - 1;   // Wrong offset for second node
   test_map = TestMap(data);
   ASSERT_FALSE(test_map.ValidateInMemoryStructure());
 }
 
 TEST_F(TestInvalidMap, TestUnSortedKeys) {
-  u_int32_t* header = reinterpret_cast<u_int32_t*>(data);
-  const u_int32_t kNumNodes = 2;
-  const u_int32_t kHeaderOffset =
-      sizeof(u_int32_t) + kNumNodes * (sizeof(u_int32_t) + sizeof(KeyType));
+  uint32_t* header = reinterpret_cast<uint32_t*>(data);
+  const uint32_t kNumNodes = 2;
+  const uint32_t kHeaderOffset =
+      sizeof(uint32_t) + kNumNodes * (sizeof(uint32_t) + sizeof(KeyType));
   header[0] = kNumNodes;
   header[1] = kHeaderOffset;
   header[2] = kHeaderOffset + sizeof(ValueType);
 
   KeyType* keys = reinterpret_cast<KeyType*>(
-      data + (kNumNodes + 1) * sizeof(u_int32_t));
+      data + (kNumNodes + 1) * sizeof(uint32_t));
   // Set keys in non-increasing order.
   keys[0] = 10;
   keys[1] = 7;
   test_map = TestMap(data);
   ASSERT_FALSE(test_map.ValidateInMemoryStructure());
 }
 
 
@@ -166,20 +166,20 @@
     for (int i = 0; i < 1000; ++i)
       std_map[testcase].insert(std::make_pair(rand(), rand()));
     map_data[testcase] =
         serializer.Serialize(std_map[testcase], &size[testcase]);
     test_map[testcase] = TestMap(map_data[testcase]);
 
     // Set correct size of memory allocation for each test case.
     unsigned int size_per_node =
-        sizeof(u_int32_t) + sizeof(KeyType) + sizeof(ValueType);
+        sizeof(uint32_t) + sizeof(KeyType) + sizeof(ValueType);
     for (testcase = 0; testcase < kNumberTestCases; ++testcase) {
       correct_size[testcase] =
-          sizeof(u_int32_t) + std_map[testcase].size() * size_per_node;
+          sizeof(uint32_t) + std_map[testcase].size() * size_per_node;
     }
   }
 
   void TearDown() {
     for (int i = 0;i < kNumberTestCases; ++i)
       delete map_data[i];
   }
 
diff --git a/src/processor/synth_minidump.cc b/src/processor/synth_minidump.cc
--- a/src/processor/synth_minidump.cc
+++ b/src/processor/synth_minidump.cc
@@ -188,35 +188,35 @@
   for (int i = 0; i < MD_FLOATINGSAVEAREA_ARM_FPR_COUNT; ++i)
     D64(context.float_save.regs[i]);
   for (int i = 0; i < MD_FLOATINGSAVEAREA_ARM_FPEXTRA_COUNT; ++i)
     D32(context.float_save.extra[i]);
   assert(Size() == sizeof(MDRawContextARM));
 }
 
 Thread::Thread(const Dump &dump,
-               u_int32_t thread_id, const Memory &stack, const Context &context,
-               u_int32_t suspend_count, u_int32_t priority_class,
-               u_int32_t priority, u_int64_t teb) : Section(dump) {
+               uint32_t thread_id, const Memory &stack, const Context &context,
+               uint32_t suspend_count, uint32_t priority_class,
+               uint32_t priority, uint64_t teb) : Section(dump) {
   D32(thread_id);
   D32(suspend_count);
   D32(priority_class);
   D32(priority);
   D64(teb);
   stack.CiteMemoryIn(this);
   context.CiteLocationIn(this);
   assert(Size() == sizeof(MDRawThread));
 }
 
 Module::Module(const Dump &dump,
-               u_int64_t base_of_image,
-               u_int32_t size_of_image,
+               uint64_t base_of_image,
+               uint32_t size_of_image,
                const String &name,
-               u_int32_t time_date_stamp,
-               u_int32_t checksum,
+               uint32_t time_date_stamp,
+               uint32_t checksum,
                const MDVSFixedFileInfo &version_info,
                const Section *cv_record,
                const Section *misc_record) : Section(dump) {
   D64(base_of_image);
   D32(size_of_image);
   D32(checksum);
   D32(time_date_stamp);
   name.CiteStringIn(this);
@@ -252,39 +252,39 @@
   MD_VSFIXEDFILEINFO_FILE_TYPE_APP,     // file_type
   MD_VSFIXEDFILEINFO_FILE_SUBTYPE_UNKNOWN, // file_subtype
   0,                                    // file_date_hi
   0                                     // file_date_lo
 };
 
 Exception::Exception(const Dump &dump,
                      const Context &context,
-                     u_int32_t thread_id,
-                     u_int32_t exception_code,
-                     u_int32_t exception_flags,
-                     u_int64_t exception_address)
+                     uint32_t thread_id,
+                     uint32_t exception_code,
+                     uint32_t exception_flags,
+                     uint64_t exception_address)
   : Stream(dump, MD_EXCEPTION_STREAM) {
   D32(thread_id);
   D32(0);  // __align
   D32(exception_code);
   D32(exception_flags);
   D64(0);  // exception_record
   D64(exception_address);
   D32(0);  // number_parameters
   D32(0);  // __align
   for (int i = 0; i < MD_EXCEPTION_MAXIMUM_PARAMETERS; ++i)
     D64(0);  // exception_information
   context.CiteLocationIn(this);
   assert(Size() == sizeof(MDRawExceptionStream));
 }
 
-Dump::Dump(u_int64_t flags,
+Dump::Dump(uint64_t flags,
            Endianness endianness,
-           u_int32_t version,
-           u_int32_t date_time_stamp)
+           uint32_t version,
+           uint32_t date_time_stamp)
     : test_assembler::Section(endianness),
       file_start_(0),
       stream_directory_(*this),
       stream_count_(0),
       thread_list_(*this, MD_THREAD_LIST_STREAM),
       module_list_(*this, MD_MODULE_LIST_STREAM),
       memory_list_(*this, MD_MEMORY_LIST_STREAM)
  {
diff --git a/src/processor/synth_minidump.h b/src/processor/synth_minidump.h
--- a/src/processor/synth_minidump.h
+++ b/src/processor/synth_minidump.h
@@ -161,24 +161,24 @@
 };
 
 // A stream within a minidump file. 'Add'ing a stream to a minidump
 // creates an entry for it in the minidump's stream directory.
 class Stream: public Section {
  public:
   // Create a stream of type TYPE.  You can append whatever contents
   // you like to this stream using the test_assembler::Section methods.
-  Stream(const Dump &dump, u_int32_t type) : Section(dump), type_(type) { }
+  Stream(const Dump &dump, uint32_t type) : Section(dump), type_(type) { }
 
   // Append an MDRawDirectory referring to this stream to SECTION.
   void CiteStreamIn(test_assembler::Section *section) const;
 
  private:
   // The type of this stream.
-  u_int32_t type_;
+  uint32_t type_;
 };
 
 class SystemInfo: public Stream {
  public:
   // Create an MD_SYSTEM_INFO_STREAM stream belonging to DUMP holding
   // an MDRawSystem info structure initialized with the values from
   // SYSTEM_INFO, except that the csd_version field is replaced with
   // the file offset of the string CSD_VERSION, which can be 'Add'ed
@@ -206,26 +206,26 @@
 };
 
 // A range of memory contents. 'Add'ing a memory range to a minidump
 // creates n entry for it in the minidump's memory list. By
 // convention, the 'start', 'Here', and 'Mark' member functions refer
 // to memory addresses.
 class Memory: public Section {
  public:
-  Memory(const Dump &dump, u_int64_t address)
+  Memory(const Dump &dump, uint64_t address)
       : Section(dump), address_(address) { start() = address; }
 
   // Append an MDMemoryDescriptor referring to this memory range to SECTION.
   void CiteMemoryIn(test_assembler::Section *section) const;
 
  private:
   // The process address from which these memory contents were taken.
   // Shouldn't this be a Label?
-  u_int64_t address_;
+  uint64_t address_;
 };
 
 class Context: public Section {
  public:
   // Create a context belonging to DUMP whose contents are a copy of CONTEXT.
   Context(const Dump &dump, const MDRawContextX86 &context);
   Context(const Dump &dump, const MDRawContextARM &context);
   // Add an empty context to the dump.
@@ -233,63 +233,63 @@
   // Add constructors for other architectures here. Remember to byteswap.
 };
 
 class Thread: public Section {
  public:
   // Create a thread belonging to DUMP with the given values, citing
   // STACK and CONTEXT (which you must Add to the dump separately).
   Thread(const Dump &dump,
-         u_int32_t thread_id,
+         uint32_t thread_id,
          const Memory &stack,
          const Context &context,
-         u_int32_t suspend_count = 0,
-         u_int32_t priority_class = 0,
-         u_int32_t priority = 0,
-         u_int64_t teb = 0);
+         uint32_t suspend_count = 0,
+         uint32_t priority_class = 0,
+         uint32_t priority = 0,
+         uint64_t teb = 0);
 };
 
 class Module: public Section {
  public:
   // Create a module with the given values. Note that CV_RECORD and
   // MISC_RECORD can be NULL, in which case the corresponding location
   // descriptior in the minidump will have a length of zero.
   Module(const Dump &dump,
-         u_int64_t base_of_image,
-         u_int32_t size_of_image,
+         uint64_t base_of_image,
+         uint32_t size_of_image,
          const String &name,
-         u_int32_t time_date_stamp = 1262805309,
-         u_int32_t checksum = 0,
+         uint32_t time_date_stamp = 1262805309,
+         uint32_t checksum = 0,
          const MDVSFixedFileInfo &version_info = Module::stock_version_info,
          const Section *cv_record = NULL,
          const Section *misc_record = NULL);
 
  private:
   // A standard MDVSFixedFileInfo structure to use as a default for
   // minidumps.  There's no reason to make users write out all this crap
   // over and over.
   static const MDVSFixedFileInfo stock_version_info;
 };
 
 class Exception : public Stream {
 public:
   Exception(const Dump &dump,
             const Context &context,
-            u_int32_t thread_id = 0,
-            u_int32_t exception_code = 0,
-            u_int32_t exception_flags = 0,
-            u_int64_t exception_address = 0);
+            uint32_t thread_id = 0,
+            uint32_t exception_code = 0,
+            uint32_t exception_flags = 0,
+            uint64_t exception_address = 0);
 };
 
 // A list of entries starting with a 32-bit count, like a memory list
 // or a thread list.
 template<typename Element>
 class List: public Stream {
  public:
-  List(const Dump &dump, u_int32_t type) : Stream(dump, type), count_(0) {
+  List(const Dump &dump, uint32_t type) : Stream(dump, type), count_(0) {
     D32(count_label_);
   }
 
   // Add ELEMENT to this list.
   void Add(Element *element) {
     element->Finish(file_offset_ + Size());
     Append(*element);
     count_++;
@@ -312,20 +312,20 @@
 
 class Dump: public test_assembler::Section {
  public:
 
   // Create a test_assembler::Section containing a minidump file whose
   // header uses the given values. ENDIANNESS determines the
   // endianness of the signature; we set this section's default
   // endianness by this.
-  Dump(u_int64_t flags,
+  Dump(uint64_t flags,
        Endianness endianness = kLittleEndian,
-       u_int32_t version = MD_HEADER_VERSION,
-       u_int32_t date_time_stamp = 1262805309);
+       uint32_t version = MD_HEADER_VERSION,
+       uint32_t date_time_stamp = 1262805309);
 
   // The following functions call OBJECT->Finish(), and append the
   // contents of OBJECT to this minidump. They also record OBJECT in
   // whatever directory or list is appropriate for its type. The
   // stream directory, memory list, thread list, and module list are
   // accumulated this way.
   Dump &Add(SynthMinidump::Section *object); // simply append data
   Dump &Add(Stream *object); // append, record in stream directory
diff --git a/src/processor/synth_minidump_unittest.cc b/src/processor/synth_minidump_unittest.cc
--- a/src/processor/synth_minidump_unittest.cc
+++ b/src/processor/synth_minidump_unittest.cc
@@ -170,17 +170,17 @@
   google_breakpad::SynthMinidump::Thread thread(
       dump, 0x3d7ec360, stack, context,
       0x3593f44d, // suspend count
       0xab352b82, // priority class
       0x2753d838, // priority
       0xeb2de4be3f29e3e9ULL); // thread environment block
   string contents;
   ASSERT_TRUE(thread.GetContents(&contents));
-  static const u_int8_t expected_bytes[] = {
+  static const uint8_t expected_bytes[] = {
     0x60, 0xc3, 0x7e, 0x3d, // thread id
     0x4d, 0xf4, 0x93, 0x35, // suspend count
     0x82, 0x2b, 0x35, 0xab, // priority class
     0x38, 0xd8, 0x53, 0x27, // priority
     0xe9, 0xe3, 0x29, 0x3f, 0xbe, 0xe4, 0x2d, 0xeb, // thread environment block
     0xfc, 0x0e, 0x3c, 0xcc, 0x93, 0x5a, 0xd5, 0xaa, // stack address
     0x0e, 0x00, 0x00, 0x00, // stack size
     0xd1, 0xdb, 0x8c, 0xe0, // stack MDRVA
@@ -198,17 +198,17 @@
   
   Exception exception(dump, context,
                       0x1234abcd, // thread id
                       0xdcba4321, // exception code
                       0xf0e0d0c0, // exception flags
                       0x0919a9b9c9d9e9f9ULL); // exception address
   string contents;
   ASSERT_TRUE(exception.GetContents(&contents));
-  static const u_int8_t expected_bytes[] = {
+  static const uint8_t expected_bytes[] = {
     0xcd, 0xab, 0x34, 0x12, // thread id
     0x00, 0x00, 0x00, 0x00, // __align
     0x21, 0x43, 0xba, 0xdc, // exception code
     0xc0, 0xd0, 0xe0, 0xf0, // exception flags
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // exception record
     0xf9, 0xe9, 0xd9, 0xc9, 0xb9, 0xa9, 0x19, 0x09, // exception address
     0x00, 0x00, 0x00, 0x00, // number parameters
     0x00, 0x00, 0x00, 0x00, // __align
diff --git a/src/processor/synth_minidump_unittest_data.h b/src/processor/synth_minidump_unittest_data.h
--- a/src/processor/synth_minidump_unittest_data.h
+++ b/src/processor/synth_minidump_unittest_data.h
@@ -125,17 +125,17 @@
     0x00, 0x5e, 0x01, 0x56, 0x3b, 0xfd, 0x5b, 0xa1,
     0x2f, 0x63, 0x1d, 0xbf, 0xf9, 0xd8, 0x13, 0xf7,
     0x4d, 0xb7, 0x1e, 0x3d, 0x98, 0xd2, 0xee, 0xb8,
     0x48, 0xc8, 0x5b, 0x91, 0x0f, 0x54, 0x9e, 0x26,
     0xb2, 0xc7, 0x3a, 0x6c, 0x8a, 0x35, 0xe1, 0xba
   }
 };
 
-static const u_int8_t x86_expected_contents[] = {
+static const uint8_t x86_expected_contents[] = {
   0x1b, 0xd7, 0xd5, 0xde,
   0x2e, 0x43, 0xdb, 0x9f,
   0x1a, 0xa8, 0xb7, 0x26,
   0x48, 0xe3, 0xc7, 0xca,
   0x09, 0xec, 0x99, 0xcf,
   0xcd, 0xc2, 0xc8, 0x7d,
   0x80, 0xb8, 0xde, 0x21,
   0xb0, 0x2b, 0x5d, 0x8a,
@@ -315,17 +315,17 @@
       0x3c012f19,
       0x6436637c,
       0x46ccedcb,
       0x7b341be7,
     }
   }
 };
 
-static const u_int8_t arm_expected_contents[] = {
+static const uint8_t arm_expected_contents[] = {
   0x6a, 0x9e, 0x1b, 0x59,
   0xde, 0x94, 0x15, 0xa2,
   0x25, 0x8a, 0x0d, 0x82,
   0xb2, 0x33, 0xe1, 0xc4,
   0x02, 0x1c, 0x3a, 0x17,
   0x75, 0xb1, 0x5f, 0x10,
   0x3f, 0x79, 0x71, 0xe8,
   0xb3, 0x70, 0xef, 0x5d,
diff --git a/src/processor/windows_frame_info.h b/src/processor/windows_frame_info.h
--- a/src/processor/windows_frame_info.h
+++ b/src/processor/windows_frame_info.h
@@ -80,22 +80,22 @@
                      parameter_size(0),
                      saved_register_size(0),
                      local_size(0),
                      max_stack_size(0),
                      allocates_base_pointer(0),
                      program_string() {}
 
   WindowsFrameInfo(StackInfoTypes type,
-                 u_int32_t set_prolog_size,
-                 u_int32_t set_epilog_size,
-                 u_int32_t set_parameter_size,
-                 u_int32_t set_saved_register_size,
-                 u_int32_t set_local_size,
-                 u_int32_t set_max_stack_size,
+                 uint32_t set_prolog_size,
+                 uint32_t set_epilog_size,
+                 uint32_t set_parameter_size,
+                 uint32_t set_saved_register_size,
+                 uint32_t set_local_size,
+                 uint32_t set_max_stack_size,
                  int set_allocates_base_pointer,
                  const string set_program_string)
       : type_(type),
         valid(VALID_ALL),
         prolog_size(set_prolog_size),
         epilog_size(set_epilog_size),
         parameter_size(set_parameter_size),
         saved_register_size(set_saved_register_size),
@@ -105,40 +105,40 @@
         program_string(set_program_string) {}
 
   // Parse a textual serialization of a WindowsFrameInfo object from
   // a string. Returns NULL if parsing fails, or a new object
   // otherwise. type, rva and code_size are present in the STACK line,
   // but not the StackFrameInfo structure, so return them as outparams.
   static WindowsFrameInfo *ParseFromString(const string string,
                                            int &type,
-                                           u_int64_t &rva,
-                                           u_int64_t &code_size) {
+                                           uint64_t &rva,
+                                           uint64_t &code_size) {
     // The format of a STACK WIN record is documented at: 
     //
     // http://code.google.com/p/google-breakpad/wiki/SymbolFiles
 
     std::vector<char>  buffer;
     StringToVector(string, buffer);
     std::vector<char*> tokens;
     if (!Tokenize(&buffer[0], " \r\n", 11, &tokens))
       return NULL;
 
     type = strtol(tokens[0], NULL, 16);
     if (type < 0 || type > STACK_INFO_LAST - 1)
       return NULL;
 
     rva                           = strtoull(tokens[1],  NULL, 16);
     code_size                     = strtoull(tokens[2],  NULL, 16);
-    u_int32_t prolog_size         =  strtoul(tokens[3],  NULL, 16);
-    u_int32_t epilog_size         =  strtoul(tokens[4],  NULL, 16);
-    u_int32_t parameter_size      =  strtoul(tokens[5],  NULL, 16);
-    u_int32_t saved_register_size =  strtoul(tokens[6],  NULL, 16);
-    u_int32_t local_size          =  strtoul(tokens[7],  NULL, 16);
-    u_int32_t max_stack_size      =  strtoul(tokens[8],  NULL, 16);
+    uint32_t prolog_size         =  strtoul(tokens[3],  NULL, 16);
+    uint32_t epilog_size         =  strtoul(tokens[4],  NULL, 16);
+    uint32_t parameter_size      =  strtoul(tokens[5],  NULL, 16);
+    uint32_t saved_register_size =  strtoul(tokens[6],  NULL, 16);
+    uint32_t local_size          =  strtoul(tokens[7],  NULL, 16);
+    uint32_t max_stack_size      =  strtoul(tokens[8],  NULL, 16);
     int has_program_string        =  strtoul(tokens[9], NULL, 16);
 
     const char *program_string = "";
     int allocates_base_pointer = 0;
     if (has_program_string) {
       program_string = tokens[10];
     } else {
       allocates_base_pointer = strtoul(tokens[10], NULL, 16);
@@ -181,22 +181,22 @@
 
   // Identifies which fields in the structure are valid.  This is of
   // type Validity, but it is defined as an int because it's not
   // possible to OR values into an enumerated type.  Users must check
   // this field before using any other.
   int valid;
 
   // These values come from IDiaFrameData.
-  u_int32_t prolog_size;
-  u_int32_t epilog_size;
-  u_int32_t parameter_size;
-  u_int32_t saved_register_size;
-  u_int32_t local_size;
-  u_int32_t max_stack_size;
+  uint32_t prolog_size;
+  uint32_t epilog_size;
+  uint32_t parameter_size;
+  uint32_t saved_register_size;
+  uint32_t local_size;
+  uint32_t max_stack_size;
 
   // Only one of allocates_base_pointer or program_string will be valid.
   // If program_string is empty, use allocates_base_pointer.
   bool allocates_base_pointer;
   string program_string;
 };
 
 }  // namespace google_breakpad
diff --git a/src/tools/linux/md2core/minidump-2-core.cc b/src/tools/linux/md2core/minidump-2-core.cc
--- a/src/tools/linux/md2core/minidump-2-core.cc
+++ b/src/tools/linux/md2core/minidump-2-core.cc
@@ -495,19 +495,19 @@
 }
 
 static void
 ParseMaps(CrashedProcess* crashinfo, const MinidumpMemoryRange& range) {
   if (verbose) {
     fputs("MD_LINUX_MAPS:\n", stderr);
     fwrite(range.data(), range.length(), 1, stderr);
   }
-  for (const u_int8_t* ptr = range.data();
+  for (const uint8_t* ptr = range.data();
        ptr < range.data() + range.length();) {
-    const u_int8_t* eol = (u_int8_t*)memchr(ptr, '\n',
+    const uint8_t* eol = (uint8_t*)memchr(ptr, '\n',
                                        range.data() + range.length() - ptr);
     std::string line((const char*)ptr,
                      eol ? eol - ptr : range.data() + range.length() - ptr);
     ptr = eol ? eol + 1 : range.data() + range.length();
     unsigned long long start, stop, offset;
     char* permissions = NULL;
     char* filename = NULL;
     sscanf(line.c_str(), "%llx-%llx %m[-rwxp] %llx %*[:0-9a-f] %*d %ms",
diff --git a/src/tools/linux/md2core/minidump_memory_range.h b/src/tools/linux/md2core/minidump_memory_range.h
--- a/src/tools/linux/md2core/minidump_memory_range.h
+++ b/src/tools/linux/md2core/minidump_memory_range.h
@@ -70,18 +70,18 @@
 
   // Gets a STL string from a MDString at |sub_offset| bytes of this memory
   // range. This method only works correctly for ASCII characters and does
   // not convert between UTF-16 and UTF-8.
   const std::string GetAsciiMDString(size_t sub_offset) const {
     std::string str;
     const MDString* md_str = GetData<MDString>(sub_offset);
     if (md_str) {
-      const u_int16_t* buffer = &md_str->buffer[0];
-      for (u_int32_t i = 0; i < md_str->length && buffer[i]; ++i) {
+      const uint16_t* buffer = &md_str->buffer[0];
+      for (uint32_t i = 0; i < md_str->length && buffer[i]; ++i) {
         str.push_back(buffer[i]);
       }
     }
     return str;
   }
 };
 
 }  // namespace google_breakpad
diff --git a/src/tools/linux/md2core/minidump_memory_range_unittest.cc b/src/tools/linux/md2core/minidump_memory_range_unittest.cc
--- a/src/tools/linux/md2core/minidump_memory_range_unittest.cc
+++ b/src/tools/linux/md2core/minidump_memory_range_unittest.cc
@@ -33,19 +33,19 @@
 #include "breakpad_googletest_includes.h"
 #include "tools/linux/md2core/minidump_memory_range.h"
 
 using google_breakpad::MinidumpMemoryRange;
 using testing::Message;
 
 namespace {
 
-const u_int32_t kBuffer[10] = { 0 };
+const uint32_t kBuffer[10] = { 0 };
 const size_t kBufferSize = sizeof(kBuffer);
-const u_int8_t* kBufferPointer = reinterpret_cast<const u_int8_t*>(kBuffer);
+const uint8_t* kBufferPointer = reinterpret_cast<const uint8_t*>(kBuffer);
 
 // Test vectors for verifying Covers, GetData, and Subrange.
 const struct {
   bool valid;
   size_t offset;
   size_t length;
 } kSubranges[] = {
   { true, 0, 0 },
@@ -217,28 +217,28 @@
   MinidumpMemoryRange range(kBuffer, kBufferSize);
   const char* char_pointer = range.GetArrayElement<char>(0, 0);
   EXPECT_EQ(reinterpret_cast<const char*>(kBufferPointer), char_pointer);
   const int* int_pointer = range.GetArrayElement<int>(0, 0);
   EXPECT_EQ(reinterpret_cast<const int*>(kBufferPointer), int_pointer);
 }
 
 TEST(MinidumpMemoryRangeTest, GetAsciiMDString) {
-  u_int8_t buffer[100] = { 0 };
+  uint8_t buffer[100] = { 0 };
 
   MDString* md_str = reinterpret_cast<MDString*>(buffer);
   md_str->length = 4;
   md_str->buffer[0] = 'T';
   md_str->buffer[1] = 'e';
   md_str->buffer[2] = 's';
   md_str->buffer[3] = 't';
   md_str->buffer[4] = '\0';
 
   size_t str2_offset =
-      sizeof(MDString) + (md_str->length + 1) * sizeof(u_int16_t);
+      sizeof(MDString) + (md_str->length + 1) * sizeof(uint16_t);
 
   md_str = reinterpret_cast<MDString*>(buffer + str2_offset);
   md_str->length = 9;  // Test length larger than actual string
   md_str->buffer[0] = 'S';
   md_str->buffer[1] = 't';
   md_str->buffer[2] = 'r';
   md_str->buffer[3] = 'i';
   md_str->buffer[4] = 'n';
