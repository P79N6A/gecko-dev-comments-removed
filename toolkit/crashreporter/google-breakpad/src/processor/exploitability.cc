



































#include <cassert>

#include "common/scoped_ptr.h"
#include "google_breakpad/processor/exploitability.h"
#include "google_breakpad/processor/minidump.h"
#include "google_breakpad/processor/process_state.h"
#include "processor/exploitability_win.h"
#include "processor/logging.h"

namespace google_breakpad {

Exploitability::Exploitability(Minidump *dump,
                               ProcessState *process_state)
    : dump_(dump),
      process_state_(process_state) {}

ExploitabilityRating Exploitability::CheckExploitability() {
  return CheckPlatformExploitability();
}

Exploitability *Exploitability::ExploitabilityForPlatform(
    Minidump *dump,
    ProcessState *process_state) {
  Exploitability *platform_exploitability = NULL;
  MinidumpSystemInfo *minidump_system_info = dump->GetSystemInfo();
  if (!minidump_system_info)
    return NULL;

  const MDRawSystemInfo *raw_system_info =
    minidump_system_info->system_info();
  if (!raw_system_info)
    return NULL;

  switch (raw_system_info->platform_id) {
    case MD_OS_WIN32_NT:
    case MD_OS_WIN32_WINDOWS: {
      platform_exploitability = new ExploitabilityWin(dump,
                                                      process_state);
      break;
    }
    case MD_OS_MAC_OS_X:
    case MD_OS_IOS:
    case MD_OS_LINUX:
    case MD_OS_UNIX:
    case MD_OS_SOLARIS:
    case MD_OS_ANDROID:
    default: {
      platform_exploitability = NULL;
      break;
    }
  }

  BPLOG_IF(ERROR, !platform_exploitability) <<
    "No Exploitability module for platform: " <<
    process_state->system_info()->os;
  return platform_exploitability;
}

bool Exploitability::AddressIsAscii(uint64_t address) {
  for (int i = 0; i < 8; i++) {
    uint8_t byte = (address >> (8*i)) & 0xff;
    if ((byte >= ' ' && byte <= '~') || byte == 0)
      continue;
    return false;
  }
  return true;
}

}  

