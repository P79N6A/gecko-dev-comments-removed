




#include "unicode/utypes.h"

#if U_PLATFORM_HAS_WIN32_API
#   define VC_EXTRALEAN
#   define WIN32_LEAN_AND_MEAN
#   define NOUSER
#   define NOSERVICE
#   define NOIME
#   define NOMCX
#include <windows.h>
#include <time.h>
#   ifdef __GNUC__
#       define WINDOWS_WITH_GNUC
#   endif
#endif

#if U_PLATFORM_IS_LINUX_BASED
#   define U_ELF
#endif

#ifdef U_ELF
#   include <elf.h>
#   if defined(ELFCLASS64)
#       define U_ELF64
#   endif
    
#   ifndef EM_X86_64
#       define EM_X86_64 62
#   endif
#   define ICU_ENTRY_OFFSET 0
#endif

#include <stdio.h>
#include <stdlib.h>
#include "unicode/putil.h"
#include "cmemory.h"
#include "cstring.h"
#include "filestrm.h"
#include "toolutil.h"
#include "unicode/uclean.h"
#include "uoptions.h"
#include "pkg_genc.h"

#define MAX_COLUMN ((uint32_t)(0xFFFFFFFFU))

#define HEX_0X 0 /*  0x1234 */
#define HEX_0H 1 /*  01234h */




#ifndef __USER_LABEL_PREFIX__
#define __USER_LABEL_PREFIX__ _
#endif
#define GCC_LABEL_PREFIX_INTERNAL(a) #a
#define GCC_LABEL_PREFIX(a) GCC_LABEL_PREFIX_INTERNAL(a)


static void
getOutFilename(const char *inFilename, const char *destdir, char *outFilename, char *entryName, const char *newSuffix, const char *optFilename);

static uint32_t
write8(FileStream *out, uint8_t byte, uint32_t column);

static uint32_t
write32(FileStream *out, uint32_t byte, uint32_t column);

#if U_PLATFORM == U_PF_OS400
static uint32_t
write8str(FileStream *out, uint8_t byte, uint32_t column);
#endif








































static const struct AssemblyType {
    const char *name;
    const char *header;
    const char *beginLine;
    const char *footer;
    int8_t      hexType; 
} assemblyHeader[] = {
    {"gcc",
        ".globl %s\n"
        "\t.section .note.GNU-stack,\"\",%%progbits\n"
        "\t.section .rodata\n"
        "\t.align 8\n" 
        "\t.type %s,%%object\n"
        "%s:\n\n",

        ".long ","",HEX_0X
    },
    {"gcc-darwin",
        

        ".globl _%s\n"
        "\t.data\n"
        "\t.const\n"
        "\t.align 4\n"  
        "_%s:\n\n",

        ".long ","",HEX_0X
    },
    {"gcc-cygwin",
        ".globl "GCC_LABEL_PREFIX(__USER_LABEL_PREFIX__) "%s\n"
        "\t.section .rodata\n"
        "\t.align 8\n" 
        GCC_LABEL_PREFIX(__USER_LABEL_PREFIX__) "%s:\n\n",

        ".long ","",HEX_0X
    },
    {"sun",
        "\t.section \".rodata\"\n"
        "\t.align   8\n"
        ".globl     %s\n"
        "%s:\n",

        ".word ","",HEX_0X
    },
    {"sun-x86",
        "Drodata.rodata:\n"
        "\t.type   Drodata.rodata,@object\n"
        "\t.size   Drodata.rodata,0\n"
        "\t.globl  %s\n"
        "\t.align  8\n"
        "%s:\n",

        ".4byte ","",HEX_0X
    },
    {"xlc",
        ".globl %s{RO}\n"
        "\t.toc\n"
        "%s:\n"
        "\t.csect %s{RO}, 4\n",

        ".long ","",HEX_0X
    },
    {"aCC-ia64",
        "\t.file   \"%s.s\"\n"
        "\t.type   %s,@object\n"
        "\t.global %s\n"
        "\t.secalias .abe$0.rodata, \".rodata\"\n"
        "\t.section .abe$0.rodata = \"a\", \"progbits\"\n"
        "\t.align  16\n"
        "%s::\t",

        "data4 ","",HEX_0X
    },
    {"aCC-parisc",
        "\t.SPACE  $TEXT$\n"
        "\t.SUBSPA $LIT$\n"
        "%s\n"
        "\t.EXPORT %s\n"
        "\t.ALIGN  16\n",

        ".WORD ","",HEX_0X
    },
    { "masm",
      "\tTITLE %s\n"
      "; generated by genccode\n"
      ".386\n"
      ".model flat\n"
      "\tPUBLIC _%s\n"
      "ICUDATA_%s\tSEGMENT READONLY PARA PUBLIC FLAT 'DATA'\n"
      "\tALIGN 16\n"
      "_%s\tLABEL DWORD\n",
      "\tDWORD ","\nICUDATA_%s\tENDS\n\tEND\n",HEX_0H
    }
};

static int32_t assemblyHeaderIndex = -1;
static int32_t hexType = HEX_0X;

U_CAPI UBool U_EXPORT2
checkAssemblyHeaderName(const char* optAssembly) {
    int32_t idx;
    assemblyHeaderIndex = -1;
    for (idx = 0; idx < (int32_t)(sizeof(assemblyHeader)/sizeof(assemblyHeader[0])); idx++) {
        if (uprv_strcmp(optAssembly, assemblyHeader[idx].name) == 0) {
            assemblyHeaderIndex = idx;
            hexType = assemblyHeader[idx].hexType; 
            return TRUE;
        }
    }

    return FALSE;
}


U_CAPI void U_EXPORT2
printAssemblyHeadersToStdErr(void) {
    int32_t idx;
    fprintf(stderr, "%s", assemblyHeader[0].name);
    for (idx = 1; idx < (int32_t)(sizeof(assemblyHeader)/sizeof(assemblyHeader[0])); idx++) {
        fprintf(stderr, ", %s", assemblyHeader[idx].name);
    }
    fprintf(stderr,
        ")\n");
}

U_CAPI void U_EXPORT2
writeAssemblyCode(const char *filename, const char *destdir, const char *optEntryPoint, const char *optFilename, char *outFilePath) {
    uint32_t column = MAX_COLUMN;
    char entry[64];
    uint32_t buffer[1024];
    char *bufferStr = (char *)buffer;
    FileStream *in, *out;
    size_t i, length;

    in=T_FileStream_open(filename, "rb");
    if(in==NULL) {
        fprintf(stderr, "genccode: unable to open input file %s\n", filename);
        exit(U_FILE_ACCESS_ERROR);
    }

    getOutFilename(filename, destdir, bufferStr, entry, ".s", optFilename);
    out=T_FileStream_open(bufferStr, "w");
    if(out==NULL) {
        fprintf(stderr, "genccode: unable to open output file %s\n", bufferStr);
        exit(U_FILE_ACCESS_ERROR);
    }

    if (outFilePath != NULL) {
        uprv_strcpy(outFilePath, bufferStr);
    }

#ifdef WINDOWS_WITH_GNUC
    
    swapFileSepChar(outFilePath, U_FILE_SEP_CHAR, '/');
#endif

    if(optEntryPoint != NULL) {
        uprv_strcpy(entry, optEntryPoint);
        uprv_strcat(entry, "_dat");
    }

    
    length=uprv_strlen(entry);
    for(i=0; i<length; ++i) {
        if(entry[i]=='-' || entry[i]=='.') {
            entry[i]='_';
        }
    }

    sprintf(bufferStr, assemblyHeader[assemblyHeaderIndex].header,
        entry, entry, entry, entry,
        entry, entry, entry, entry);
    T_FileStream_writeLine(out, bufferStr);
    T_FileStream_writeLine(out, assemblyHeader[assemblyHeaderIndex].beginLine);

    for(;;) {
        length=T_FileStream_read(in, buffer, sizeof(buffer));
        if(length==0) {
            break;
        }
        if (length != sizeof(buffer)) {
            
            for(i=0; i < (length % sizeof(uint32_t)); ++i) {
                buffer[length+i] = 0;
            }
        }
        for(i=0; i<(length/sizeof(buffer[0])); i++) {
            column = write32(out, buffer[i], column);
        }
    }

    T_FileStream_writeLine(out, "\n");

    sprintf(bufferStr, assemblyHeader[assemblyHeaderIndex].footer,
        entry, entry, entry, entry,
        entry, entry, entry, entry);
    T_FileStream_writeLine(out, bufferStr);

    if(T_FileStream_error(in)) {
        fprintf(stderr, "genccode: file read error while generating from file %s\n", filename);
        exit(U_FILE_ACCESS_ERROR);
    }

    if(T_FileStream_error(out)) {
        fprintf(stderr, "genccode: file write error while generating from file %s\n", filename);
        exit(U_FILE_ACCESS_ERROR);
    }

    T_FileStream_close(out);
    T_FileStream_close(in);
}

U_CAPI void U_EXPORT2
writeCCode(const char *filename, const char *destdir, const char *optName, const char *optFilename, char *outFilePath) {
    uint32_t column = MAX_COLUMN;
    char buffer[4096], entry[64];
    FileStream *in, *out;
    size_t i, length;

    in=T_FileStream_open(filename, "rb");
    if(in==NULL) {
        fprintf(stderr, "genccode: unable to open input file %s\n", filename);
        exit(U_FILE_ACCESS_ERROR);
    }

    if(optName != NULL) { 
      strcpy(entry, optName);
      strcat(entry, "_");
    } else {
      entry[0] = 0;
    }

    getOutFilename(filename, destdir, buffer, entry+uprv_strlen(entry), ".c", optFilename);
    if (outFilePath != NULL) {
        uprv_strcpy(outFilePath, buffer);
    }
    out=T_FileStream_open(buffer, "w");
    if(out==NULL) {
        fprintf(stderr, "genccode: unable to open output file %s\n", buffer);
        exit(U_FILE_ACCESS_ERROR);
    }

    
    length=uprv_strlen(entry);
    for(i=0; i<length; ++i) {
        if(entry[i]=='-' || entry[i]=='.') {
            entry[i]='_';
        }
    }

#if U_PLATFORM == U_PF_OS400
    











    sprintf(buffer,
        "#ifndef IN_GENERATED_CCODE\n"
        "#define IN_GENERATED_CCODE\n"
        "#define U_DISABLE_RENAMING 1\n"
        "#include \"unicode/umachine.h\"\n"
        "#endif\n"
        "U_CDECL_BEGIN\n"
        "const struct {\n"
        "    double bogus;\n"
        "    const char *bytes; \n"
        "} %s={ 0.0, \n",
        entry);
    T_FileStream_writeLine(out, buffer);

    for(;;) {
        length=T_FileStream_read(in, buffer, sizeof(buffer));
        if(length==0) {
            break;
        }
        for(i=0; i<length; ++i) {
            column = write8str(out, (uint8_t)buffer[i], column);
        }
    }

    T_FileStream_writeLine(out, "\"\n};\nU_CDECL_END\n");
#else
    
    sprintf(buffer,
        "#ifndef IN_GENERATED_CCODE\n"
        "#define IN_GENERATED_CCODE\n"
        "#define U_DISABLE_RENAMING 1\n"
        "#include \"unicode/umachine.h\"\n"
        "#endif\n"
        "U_CDECL_BEGIN\n"
        "const struct {\n"
        "    double bogus;\n"
        "    uint8_t bytes[%ld]; \n"
        "} %s={ 0.0, {\n",
        (long)T_FileStream_size(in), entry);
    T_FileStream_writeLine(out, buffer);

    for(;;) {
        length=T_FileStream_read(in, buffer, sizeof(buffer));
        if(length==0) {
            break;
        }
        for(i=0; i<length; ++i) {
            column = write8(out, (uint8_t)buffer[i], column);
        }
    }

    T_FileStream_writeLine(out, "\n}\n};\nU_CDECL_END\n");
#endif

    if(T_FileStream_error(in)) {
        fprintf(stderr, "genccode: file read error while generating from file %s\n", filename);
        exit(U_FILE_ACCESS_ERROR);
    }

    if(T_FileStream_error(out)) {
        fprintf(stderr, "genccode: file write error while generating from file %s\n", filename);
        exit(U_FILE_ACCESS_ERROR);
    }

    T_FileStream_close(out);
    T_FileStream_close(in);
}

static uint32_t
write32(FileStream *out, uint32_t bitField, uint32_t column) {
    int32_t i;
    char bitFieldStr[64]; 
    char *s = bitFieldStr;
    uint8_t *ptrIdx = (uint8_t *)&bitField;
    static const char hexToStr[16] = {
        '0','1','2','3',
        '4','5','6','7',
        '8','9','A','B',
        'C','D','E','F'
    };

    
    if(column==MAX_COLUMN) {
        
        column=1;
    } else if(column<32) {
        *(s++)=',';
        ++column;
    } else {
        *(s++)='\n';
        uprv_strcpy(s, assemblyHeader[assemblyHeaderIndex].beginLine);
        s+=uprv_strlen(s);
        column=1;
    }

    if (bitField < 10) {
        
        *(s++)=hexToStr[bitField];
    }
    else {
        int seenNonZero = 0; 

        if(hexType==HEX_0X) {
         *(s++)='0';
         *(s++)='x';
        } else if(hexType==HEX_0H) {
         *(s++)='0';
        }

        
#if U_IS_BIG_ENDIAN
        for (i = 0; i < sizeof(uint32_t); i++)
#else
        for (i = sizeof(uint32_t)-1; i >= 0 ; i--)
#endif
        {
            uint8_t value = ptrIdx[i];
            if (value || seenNonZero) {
                *(s++)=hexToStr[value>>4];
                *(s++)=hexToStr[value&0xF];
                seenNonZero = 1;
            }
        }
        if(hexType==HEX_0H) {
         *(s++)='h';
        }
    }

    *(s++)=0;
    T_FileStream_writeLine(out, bitFieldStr);
    return column;
}

static uint32_t
write8(FileStream *out, uint8_t byte, uint32_t column) {
    char s[4];
    int i=0;

    
    if(byte>=100) {
        s[i++]=(char)('0'+byte/100);
        byte%=100;
    }
    if(i>0 || byte>=10) {
        s[i++]=(char)('0'+byte/10);
        byte%=10;
    }
    s[i++]=(char)('0'+byte);
    s[i]=0;

    
    if(column==MAX_COLUMN) {
        
        column=1;
    } else if(column<16) {
        T_FileStream_writeLine(out, ",");
        ++column;
    } else {
        T_FileStream_writeLine(out, ",\n");
        column=1;
    }
    T_FileStream_writeLine(out, s);
    return column;
}

#if U_PLATFORM == U_PF_OS400
static uint32_t
write8str(FileStream *out, uint8_t byte, uint32_t column) {
    char s[8];

    if (byte > 7)
        sprintf(s, "\\x%X", byte);
    else
        sprintf(s, "\\%X", byte);

    
    if(column==MAX_COLUMN) {
        
        column=1;
        T_FileStream_writeLine(out, "\"");
    } else if(column<24) {
        ++column;
    } else {
        T_FileStream_writeLine(out, "\"\n\"");
        column=1;
    }
    T_FileStream_writeLine(out, s);
    return column;
}
#endif

static void
getOutFilename(const char *inFilename, const char *destdir, char *outFilename, char *entryName, const char *newSuffix, const char *optFilename) {
    const char *basename=findBasename(inFilename), *suffix=uprv_strrchr(basename, '.');

    
    if(destdir!=NULL && *destdir!=0) {
        do {
            *outFilename++=*destdir++;
        } while(*destdir!=0);
        if(*(outFilename-1)!=U_FILE_SEP_CHAR) {
            *outFilename++=U_FILE_SEP_CHAR;
        }
        inFilename=basename;
    } else {
        while(inFilename<basename) {
            *outFilename++=*inFilename++;
        }
    }

    if(suffix==NULL) {
        
        uprv_strcpy(entryName, inFilename);
        if(optFilename != NULL) {
          uprv_strcpy(outFilename, optFilename);
        } else {
          uprv_strcpy(outFilename, inFilename);
        }
        uprv_strcat(outFilename, newSuffix);
    } else {
        char *saveOutFilename = outFilename;
        
        while(inFilename<suffix) {
            if(*inFilename=='-') {
                
                *outFilename++=*entryName++='_';
                inFilename++;
            }
            else {
                *outFilename++=*entryName++=*inFilename++;
            }
        }

        
        *outFilename++=*entryName++='_';
        ++inFilename;

        
        while(*inFilename!=0) {
            *outFilename++=*entryName++=*inFilename++;
        }

        *entryName=0;

        if(optFilename != NULL) {
            uprv_strcpy(saveOutFilename, optFilename);
            uprv_strcat(saveOutFilename, newSuffix);
        } else {
            
            uprv_strcpy(outFilename, newSuffix);
        }
    }
}

#ifdef CAN_GENERATE_OBJECTS
static void
getArchitecture(uint16_t *pCPU, uint16_t *pBits, UBool *pIsBigEndian, const char *optMatchArch) {
    union {
        char        bytes[2048];
#ifdef U_ELF
        Elf32_Ehdr  header32;
        
#elif U_PLATFORM_HAS_WIN32_API
        IMAGE_FILE_HEADER header;
#endif
    } buffer;

    const char *filename;
    FileStream *in;
    int32_t length;

#ifdef U_ELF

#elif U_PLATFORM_HAS_WIN32_API
    const IMAGE_FILE_HEADER *pHeader;
#else
#   error "Unknown platform for CAN_GENERATE_OBJECTS."
#endif

    if(optMatchArch != NULL) {
        filename=optMatchArch;
    } else {
        
#ifdef U_ELF
        
        *pCPU=EM_386;
        *pBits=32;
        *pIsBigEndian=(UBool)(U_IS_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB);
#elif U_PLATFORM_HAS_WIN32_API

#   if defined(_M_IA64)
        *pCPU=IMAGE_FILE_MACHINE_IA64;
#   elif defined(_M_AMD64)
        *pCPU=IMAGE_FILE_MACHINE_AMD64;
#   else
        *pCPU=IMAGE_FILE_MACHINE_I386;
#   endif
        *pBits= *pCPU==IMAGE_FILE_MACHINE_I386 ? 32 : 64;
        *pIsBigEndian=FALSE;
#else
#   error "Unknown platform for CAN_GENERATE_OBJECTS."
#endif
        return;
    }

    in=T_FileStream_open(filename, "rb");
    if(in==NULL) {
        fprintf(stderr, "genccode: unable to open match-arch file %s\n", filename);
        exit(U_FILE_ACCESS_ERROR);
    }
    length=T_FileStream_read(in, buffer.bytes, sizeof(buffer.bytes));

#ifdef U_ELF
    if(length<sizeof(Elf32_Ehdr)) {
        fprintf(stderr, "genccode: match-arch file %s is too short\n", filename);
        exit(U_UNSUPPORTED_ERROR);
    }
    if(
        buffer.header32.e_ident[0]!=ELFMAG0 ||
        buffer.header32.e_ident[1]!=ELFMAG1 ||
        buffer.header32.e_ident[2]!=ELFMAG2 ||
        buffer.header32.e_ident[3]!=ELFMAG3 ||
        buffer.header32.e_ident[EI_CLASS]<ELFCLASS32 || buffer.header32.e_ident[EI_CLASS]>ELFCLASS64
    ) {
        fprintf(stderr, "genccode: match-arch file %s is not an ELF object file, or not supported\n", filename);
        exit(U_UNSUPPORTED_ERROR);
    }

    *pBits= buffer.header32.e_ident[EI_CLASS]==ELFCLASS32 ? 32 : 64; 
#ifdef U_ELF64
    if(*pBits!=32 && *pBits!=64) {
        fprintf(stderr, "genccode: currently only supports 32-bit and 64-bit ELF format\n");
        exit(U_UNSUPPORTED_ERROR);
    }
#else
    if(*pBits!=32) {
        fprintf(stderr, "genccode: built with elf.h missing 64-bit definitions\n");
        exit(U_UNSUPPORTED_ERROR);
    }
#endif

    *pIsBigEndian=(UBool)(buffer.header32.e_ident[EI_DATA]==ELFDATA2MSB);
    if(*pIsBigEndian!=U_IS_BIG_ENDIAN) {
        fprintf(stderr, "genccode: currently only same-endianness ELF formats are supported\n");
        exit(U_UNSUPPORTED_ERROR);
    }
    

    *pCPU=buffer.header32.e_machine;
#elif U_PLATFORM_HAS_WIN32_API
    if(length<sizeof(IMAGE_FILE_HEADER)) {
        fprintf(stderr, "genccode: match-arch file %s is too short\n", filename);
        exit(U_UNSUPPORTED_ERROR);
    }
    
    pHeader=(const IMAGE_FILE_HEADER *)buffer.bytes;
    *pCPU=pHeader->Machine;
    



    *pBits= *pCPU==IMAGE_FILE_MACHINE_I386 ? 32 : 64;
    
    *pIsBigEndian=FALSE;
#else
#   error "Unknown platform for CAN_GENERATE_OBJECTS."
#endif

    T_FileStream_close(in);
}

U_CAPI void U_EXPORT2
writeObjectCode(const char *filename, const char *destdir, const char *optEntryPoint, const char *optMatchArch, const char *optFilename, char *outFilePath) {
    
    char buffer[4096], entry[40]={ 0 };
    FileStream *in, *out;
    const char *newSuffix;
    int32_t i, entryLength, length, size, entryOffset=0, entryLengthOffset=0;

    uint16_t cpu, bits;
    UBool makeBigEndian;

    
#ifdef U_ELF
    
    static Elf32_Ehdr header32={
        {
            
            ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3,
            ELFCLASS32,
            U_IS_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB,
            EV_CURRENT 
        },
        ET_REL,
        EM_386,
        EV_CURRENT, 
        0, 
        0, 
        (Elf32_Off)sizeof(Elf32_Ehdr), 
        0, 
        (Elf32_Half)sizeof(Elf32_Ehdr), 
        0, 
        0, 
        (Elf32_Half)sizeof(Elf32_Shdr), 
        5, 
        2 
    };

    
    static Elf32_Shdr sectionHeaders32[5]={
        { 
            0
        },
        { 
            1, 
            SHT_SYMTAB,
            0, 
            0, 
            (Elf32_Off)(sizeof(header32)+sizeof(sectionHeaders32)), 
            (Elf32_Word)(2*sizeof(Elf32_Sym)), 
            3, 
            1, 

            4, 
            (Elf32_Word)(sizeof(Elf32_Sym)) 
        },
        { 
            9, 
            SHT_STRTAB,
            0, 
            0, 
            (Elf32_Off)(sizeof(header32)+sizeof(sectionHeaders32)+2*sizeof(Elf32_Sym)), 
            40, 
            0, 
            0, 
            1, 
            0 
        },
        { 
            19, 
            SHT_STRTAB,
            0, 
            0, 
            (Elf32_Off)(sizeof(header32)+sizeof(sectionHeaders32)+2*sizeof(Elf32_Sym)+40), 
            (Elf32_Word)sizeof(entry), 
            0, 
            0, 
            1, 
            0 
        },
        { 
            27, 
            SHT_PROGBITS,
            SHF_ALLOC, 
            0, 
            (Elf32_Off)(sizeof(header32)+sizeof(sectionHeaders32)+2*sizeof(Elf32_Sym)+40+sizeof(entry)), 
            0, 
            0, 
            0, 
            16, 
            0 
        }
    };

    
    static Elf32_Sym symbols32[2]={
        { 
            0
        },
        { 
            1, 
            0, 
            0, 
            ELF64_ST_INFO(STB_GLOBAL, STT_OBJECT),
            0, 
            4 
        }
    };

    
    static const char sectionStrings[40]=
         "\0"
         ".symtab\0"
         ".shstrtab\0"
         ".strtab\0"
         ".rodata\0"
         "\0\0\0\0"; 
        

    






    
    static const char padding[16]={ 0 };
    int32_t paddingSize;

#ifdef U_ELF64
    
    static Elf64_Ehdr header64={
        {
            
            ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3,
            ELFCLASS64,
            U_IS_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB,
            EV_CURRENT 
        },
        ET_REL,
        EM_X86_64,
        EV_CURRENT, 
        0, 
        0, 
        (Elf64_Off)sizeof(Elf64_Ehdr), 
        0, 
        (Elf64_Half)sizeof(Elf64_Ehdr), 
        0, 
        0, 
        (Elf64_Half)sizeof(Elf64_Shdr), 
        5, 
        2 
    };

    
    static Elf64_Shdr sectionHeaders64[5]={
        { 
            0
        },
        { 
            1, 
            SHT_SYMTAB,
            0, 
            0, 
            (Elf64_Off)(sizeof(header64)+sizeof(sectionHeaders64)), 
            (Elf64_Xword)(2*sizeof(Elf64_Sym)), 
            3, 
            1, 

            4, 
            (Elf64_Xword)(sizeof(Elf64_Sym)) 
        },
        { 
            9, 
            SHT_STRTAB,
            0, 
            0, 
            (Elf64_Off)(sizeof(header64)+sizeof(sectionHeaders64)+2*sizeof(Elf64_Sym)), 
            40, 
            0, 
            0, 
            1, 
            0 
        },
        { 
            19, 
            SHT_STRTAB,
            0, 
            0, 
            (Elf64_Off)(sizeof(header64)+sizeof(sectionHeaders64)+2*sizeof(Elf64_Sym)+40), 
            (Elf64_Xword)sizeof(entry), 
            0, 
            0, 
            1, 
            0 
        },
        { 
            27, 
            SHT_PROGBITS,
            SHF_ALLOC, 
            0, 
            (Elf64_Off)(sizeof(header64)+sizeof(sectionHeaders64)+2*sizeof(Elf64_Sym)+40+sizeof(entry)), 
            0, 
            0, 
            0, 
            16, 
            0 
        }
    };

    



    static Elf64_Sym symbols64[2]={
        { 
            0
        },
        { 
            1, 
            ELF64_ST_INFO(STB_GLOBAL, STT_OBJECT),
            0, 
            4, 
            0, 
            0 
        }
    };

#endif 

    
    entryOffset=1;

    
    entryLengthOffset=1;

    newSuffix=".o";

#elif U_PLATFORM_HAS_WIN32_API
    struct {
        IMAGE_FILE_HEADER fileHeader;
        IMAGE_SECTION_HEADER sections[2];
        char linkerOptions[100];
    } objHeader;
    IMAGE_SYMBOL symbols[1];
    struct {
        DWORD sizeofLongNames;
        char longNames[100];
    } symbolNames;

    




    entry[0]='_';

    newSuffix=".obj";
#else
#   error "Unknown platform for CAN_GENERATE_OBJECTS."
#endif

    
    getArchitecture(&cpu, &bits, &makeBigEndian, optMatchArch);
    printf("genccode: --match-arch cpu=%hu bits=%hu big-endian=%d\n", cpu, bits, makeBigEndian);
#if U_PLATFORM_HAS_WIN32_API
    if(cpu==IMAGE_FILE_MACHINE_I386) {
        entryOffset=1;
    }
#endif

    in=T_FileStream_open(filename, "rb");
    if(in==NULL) {
        fprintf(stderr, "genccode: unable to open input file %s\n", filename);
        exit(U_FILE_ACCESS_ERROR);
    }
    size=T_FileStream_size(in);

    getOutFilename(filename, destdir, buffer, entry+entryOffset, newSuffix, optFilename);
    if (outFilePath != NULL) {
        uprv_strcpy(outFilePath, buffer);
    }

    if(optEntryPoint != NULL) {
        uprv_strcpy(entry+entryOffset, optEntryPoint);
        uprv_strcat(entry+entryOffset, "_dat");
    }
    
    entryLength=(int32_t)uprv_strlen(entry+entryLengthOffset);
    for(i=0; i<entryLength; ++i) {
        if(entry[entryLengthOffset+i]=='-') {
            entry[entryLengthOffset+i]='_';
        }
    }

    
    out=T_FileStream_open(buffer, "wb");
    if(out==NULL) {
        fprintf(stderr, "genccode: unable to open output file %s\n", buffer);
        exit(U_FILE_ACCESS_ERROR);
    }

#ifdef U_ELF
    if(bits==32) {
        header32.e_ident[EI_DATA]= makeBigEndian ? ELFDATA2MSB : ELFDATA2LSB;
        header32.e_machine=cpu;

        
        paddingSize=sectionHeaders32[4].sh_offset & 0xf;
        if(paddingSize!=0) {
                paddingSize=0x10-paddingSize;
                sectionHeaders32[4].sh_offset+=paddingSize;
        }

        sectionHeaders32[4].sh_size=(Elf32_Word)size;

        symbols32[1].st_size=(Elf32_Word)size;

        
        T_FileStream_write(out, &header32, (int32_t)sizeof(header32));
        T_FileStream_write(out, sectionHeaders32, (int32_t)sizeof(sectionHeaders32));
        T_FileStream_write(out, symbols32, (int32_t)sizeof(symbols32));
    } else  {
#ifdef U_ELF64
        header64.e_ident[EI_DATA]= makeBigEndian ? ELFDATA2MSB : ELFDATA2LSB;
        header64.e_machine=cpu;

        
        paddingSize=sectionHeaders64[4].sh_offset & 0xf;
        if(paddingSize!=0) {
                paddingSize=0x10-paddingSize;
                sectionHeaders64[4].sh_offset+=paddingSize;
        }

        sectionHeaders64[4].sh_size=(Elf64_Xword)size;

        symbols64[1].st_size=(Elf64_Xword)size;

        
        T_FileStream_write(out, &header64, (int32_t)sizeof(header64));
        T_FileStream_write(out, sectionHeaders64, (int32_t)sizeof(sectionHeaders64));
        T_FileStream_write(out, symbols64, (int32_t)sizeof(symbols64));
#endif
    }

    T_FileStream_write(out, sectionStrings, (int32_t)sizeof(sectionStrings));
    T_FileStream_write(out, entry, (int32_t)sizeof(entry));
    if(paddingSize!=0) {
        T_FileStream_write(out, padding, paddingSize);
    }
#elif U_PLATFORM_HAS_WIN32_API
    
    uprv_memset(&objHeader, 0, sizeof(objHeader));
    uprv_memset(&symbols, 0, sizeof(symbols));
    uprv_memset(&symbolNames, 0, sizeof(symbolNames));

    
    uprv_strcpy(objHeader.linkerOptions, "-export:");
    length=8;
    uprv_strcpy(objHeader.linkerOptions+length, entry);
    length+=entryLength;
    uprv_strcpy(objHeader.linkerOptions+length, ",data ");
    length+=6;

    
    objHeader.fileHeader.Machine=cpu;
    objHeader.fileHeader.NumberOfSections=2;
    objHeader.fileHeader.TimeDateStamp=(DWORD)time(NULL);
    objHeader.fileHeader.PointerToSymbolTable=IMAGE_SIZEOF_FILE_HEADER+2*IMAGE_SIZEOF_SECTION_HEADER+length+size; 
    objHeader.fileHeader.NumberOfSymbols=1;

    
    uprv_strncpy((char *)objHeader.sections[0].Name, ".drectve", 8);
    objHeader.sections[0].SizeOfRawData=length;
    objHeader.sections[0].PointerToRawData=IMAGE_SIZEOF_FILE_HEADER+2*IMAGE_SIZEOF_SECTION_HEADER;
    objHeader.sections[0].Characteristics=IMAGE_SCN_LNK_INFO|IMAGE_SCN_LNK_REMOVE|IMAGE_SCN_ALIGN_1BYTES;

    
    uprv_strncpy((char *)objHeader.sections[1].Name, ".rdata", 6);
    objHeader.sections[1].SizeOfRawData=size;
    objHeader.sections[1].PointerToRawData=IMAGE_SIZEOF_FILE_HEADER+2*IMAGE_SIZEOF_SECTION_HEADER+length;
    objHeader.sections[1].Characteristics=IMAGE_SCN_CNT_INITIALIZED_DATA|IMAGE_SCN_ALIGN_16BYTES|IMAGE_SCN_MEM_READ;

    
    if(entryLength<=8) {
        uprv_strncpy((char *)symbols[0].N.ShortName, entry, entryLength);
        symbolNames.sizeofLongNames=4;
    } else {
        symbols[0].N.Name.Short=0;
        symbols[0].N.Name.Long=4;
        symbolNames.sizeofLongNames=4+entryLength+1;
        uprv_strcpy(symbolNames.longNames, entry);
    }
    symbols[0].SectionNumber=2;
    symbols[0].StorageClass=IMAGE_SYM_CLASS_EXTERNAL;

    
    T_FileStream_write(out, &objHeader, objHeader.sections[1].PointerToRawData);
#else
#   error "Unknown platform for CAN_GENERATE_OBJECTS."
#endif

    
    for(;;) {
        length=T_FileStream_read(in, buffer, sizeof(buffer));
        if(length==0) {
            break;
        }
        T_FileStream_write(out, buffer, (int32_t)length);
    }

#if U_PLATFORM_HAS_WIN32_API
    
    T_FileStream_write(out, symbols, IMAGE_SIZEOF_SYMBOL);
    T_FileStream_write(out, &symbolNames, symbolNames.sizeofLongNames);
#endif

    if(T_FileStream_error(in)) {
        fprintf(stderr, "genccode: file read error while generating from file %s\n", filename);
        exit(U_FILE_ACCESS_ERROR);
    }

    if(T_FileStream_error(out)) {
        fprintf(stderr, "genccode: file write error while generating from file %s\n", filename);
        exit(U_FILE_ACCESS_ERROR);
    }

    T_FileStream_close(out);
    T_FileStream_close(in);
}
#endif
